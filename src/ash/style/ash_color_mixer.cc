// Copyright 2022 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "ash/style/ash_color_mixer.h"

#include "ash/constants/ash_features.h"
#include "ash/public/cpp/style/scoped_light_mode_as_default.h"
#include "ash/style/ash_color_id.h"
#include "ash/style/ash_color_provider.h"
#include "ash/style/temp_palette.h"
#include "ash/system/tray/tray_constants.h"
#include "third_party/skia/include/core/SkColor.h"
#include "ui/chromeos/styles/cros_tokens_color_mappings.h"
#include "ui/color/color_id.h"
#include "ui/color/color_mixer.h"
#include "ui/color/color_provider.h"
#include "ui/color/color_recipe.h"

namespace ash {

namespace {

constexpr int kAlpha20 = SK_AlphaOPAQUE * 0.2f;
constexpr int kAlpha40 = SK_AlphaOPAQUE * 0.4f;
constexpr int kAlpha60 = SK_AlphaOPAQUE * 0.6f;
constexpr int kAlpha80 = SK_AlphaOPAQUE * 0.8f;
constexpr int kAlpha90 = SK_AlphaOPAQUE * 0.9f;
constexpr int kAlpha95 = SK_AlphaOPAQUE * 0.95f;

void AddShieldAndBaseColors(ui::ColorMixer& mixer,
                            const ui::ColorProviderManager::Key& key) {
  const bool use_dark_color =
      key.color_mode == ui::ColorProviderManager::ColorMode::kDark;

  // Colors of the Shield and Base layers.
  const SkColor default_background_color =
      use_dark_color ? gfx::kGoogleGrey900 : SK_ColorWHITE;
  // TODO(minch|skau): Investigate/fix whether should DCHECK the existence of
  // the value of `use_color` here.
  const SkColor background_color =
      key.user_color.value_or(default_background_color);
  mixer[kColorAshShieldAndBase20] = {SkColorSetA(background_color, kAlpha20)};
  mixer[kColorAshShieldAndBase40] = {SkColorSetA(background_color, kAlpha40)};
  mixer[kColorAshShieldAndBase60] = {SkColorSetA(background_color, kAlpha60)};
  mixer[kColorAshShieldAndBase80] = {SkColorSetA(background_color, kAlpha80)};
  mixer[kColorAshShieldAndBase90] = {SkColorSetA(background_color, kAlpha90)};
  mixer[kColorAshShieldAndBase95] = {SkColorSetA(background_color, kAlpha95)};
  mixer[kColorAshShieldAndBaseOpaque] = {
      SkColorSetA(background_color, SK_AlphaOPAQUE)};
}

// Mappings of Controls Colors for Material 2.
void AddControlsColors(ui::ColorMixer& mixer,
                       const ui::ColorProviderManager::Key& key) {
  const bool use_dark_color =
      key.color_mode == ui::ColorProviderManager::ColorMode::kDark;

  // ControlsLayer colors
  mixer[kColorAshHairlineBorderColor] =
      use_dark_color ? ui::ColorTransform(SkColorSetA(SK_ColorWHITE, 0x24))
                     : ui::ColorTransform(SkColorSetA(SK_ColorBLACK, 0x24));
  mixer[kColorAshControlBackgroundColorActive] =
      use_dark_color ? ui::ColorTransform(gfx::kGoogleBlue300)
                     : ui::ColorTransform(gfx::kGoogleBlue600);
  mixer[kColorAshControlBackgroundColorInactive] =
      use_dark_color ? ui::ColorTransform(SkColorSetA(SK_ColorWHITE, 0x1A))
                     : ui::ColorTransform(SkColorSetA(SK_ColorBLACK, 0x0D));
  mixer[kColorAshControlBackgroundColorAlert] =
      use_dark_color ? ui::ColorTransform(gfx::kGoogleRed300)
                     : ui::ColorTransform(gfx::kGoogleRed600);
  mixer[kColorAshControlBackgroundColorWarning] =
      use_dark_color ? ui::ColorTransform(gfx::kGoogleYellow300)
                     : ui::ColorTransform(gfx::kGoogleYellow600);
  mixer[kColorAshControlBackgroundColorPositive] =
      use_dark_color ? ui::ColorTransform(gfx::kGoogleGreen300)
                     : ui::ColorTransform(gfx::kGoogleGreen600);
  mixer[kColorAshFocusAuraColor] =
      use_dark_color
          ? ui::ColorTransform(SkColorSetA(gfx::kGoogleBlue300, 0x3D))
          : ui::ColorTransform(SkColorSetA(gfx::kGoogleBlue600, 0x3D));
  mixer[ui::kColorAshFocusRing] = use_dark_color
                                      ? ui::ColorTransform(gfx::kGoogleBlue300)
                                      : ui::ColorTransform(gfx::kGoogleBlue600);
}

// Remaps colors generated by cros_colors.json5 to point to equivalent tokens.
void RemapLegacySemanticColors(ui::ColorMixer& mixer) {
  // The colors here that have 'generate_per_mode: true' in the
  // cros_colors.json5 file need to remap the generated Light and Dark
  // variables instead of the original.
  mixer[cros_tokens::kColorPrimaryLight] = {
      cros_tokens::kCrosSysOnSurfaceLight};
  mixer[cros_tokens::kColorPrimaryDark] = {cros_tokens::kCrosSysOnSurfaceDark};

  mixer[cros_tokens::kColorSecondaryLight] = {
      cros_tokens::kCrosSysSecondaryLight};
  mixer[cros_tokens::kColorSecondaryDark] = {
      cros_tokens::kCrosSysSecondaryDark};

  mixer[cros_tokens::kColorProminentLight] = {
      cros_tokens::kCrosSysPrimaryLight};
  mixer[cros_tokens::kColorProminentDark] = {cros_tokens::kCrosSysPrimaryDark};

  mixer[cros_tokens::kColorDisabled] = {cros_tokens::kCrosSysDisabled};

  mixer[cros_tokens::kColorSelection] = {
      cros_tokens::kCrosSysOnPrimaryContainer};

  mixer[cros_tokens::kBgColor] = {cros_tokens::kCrosSysAppBase2};
  mixer[cros_tokens::kBgColorElevation1] = {
      cros_tokens::kCrosSysAppBaseElevated};
  mixer[cros_tokens::kBgColorElevation2Light] = {
      cros_tokens::kCrosSysAppBaseElevatedLight};
  mixer[cros_tokens::kBgColorElevation2Dark] = {
      cros_tokens::kCrosSysAppBaseElevatedDark};
  mixer[cros_tokens::kBgColorElevation3] = {
      cros_tokens::kCrosSysAppBaseElevated};
  mixer[cros_tokens::kBgColorElevation4] = {
      cros_tokens::kCrosSysAppBaseElevated};
  mixer[cros_tokens::kBgColorElevation5] = {
      cros_tokens::kCrosSysAppBaseElevated};
  mixer[cros_tokens::kBgColorDroppedElevation1] = {
      cros_tokens::kCrosSysAppBase1};
  mixer[cros_tokens::kBgColorDroppedElevation2] = {
      cros_tokens::kCrosSysAppBase1};
}

// Adds the dynamic color palette tokens based on user_color. This is the base
// palette so it is independent of ColorMode.
void AddRefPalette(ui::ColorMixer& mixer,
                   const ui::ColorProviderManager::Key& key) {
  // TODO(skau): Before this launches, make sure this is always populated.
  SkColor seed_color = key.user_color.value_or(gfx::kGoogleBlue400);

  // TODO(skau): Replace with official implementation when available.
  ToneMap tone_map = GetTempPalette(seed_color);

  mixer[cros_tokens::kCrosRefPrimary0] = {tone_map.primary[Luma::k0]};
  mixer[cros_tokens::kCrosRefPrimary10] = {tone_map.primary[Luma::k10]};
  mixer[cros_tokens::kCrosRefPrimary20] = {tone_map.primary[Luma::k20]};
  mixer[cros_tokens::kCrosRefPrimary30] = {tone_map.primary[Luma::k30]};
  mixer[cros_tokens::kCrosRefPrimary40] = {tone_map.primary[Luma::k40]};
  mixer[cros_tokens::kCrosRefPrimary50] = {tone_map.primary[Luma::k50]};
  mixer[cros_tokens::kCrosRefPrimary60] = {tone_map.primary[Luma::k60]};
  mixer[cros_tokens::kCrosRefPrimary70] = {tone_map.primary[Luma::k70]};
  mixer[cros_tokens::kCrosRefPrimary80] = {tone_map.primary[Luma::k80]};
  mixer[cros_tokens::kCrosRefPrimary90] = {tone_map.primary[Luma::k90]};
  mixer[cros_tokens::kCrosRefPrimary95] = {tone_map.primary[Luma::k95]};
  mixer[cros_tokens::kCrosRefPrimary99] = {tone_map.primary[Luma::k99]};
  mixer[cros_tokens::kCrosRefPrimary100] = {tone_map.primary[Luma::k100]};

  mixer[cros_tokens::kCrosRefSecondary0] = {tone_map.secondary[Luma::k0]};
  mixer[cros_tokens::kCrosRefSecondary10] = {tone_map.secondary[Luma::k10]};
  mixer[cros_tokens::kCrosRefSecondary20] = {tone_map.secondary[Luma::k20]};
  mixer[cros_tokens::kCrosRefSecondary30] = {tone_map.secondary[Luma::k30]};
  mixer[cros_tokens::kCrosRefSecondary40] = {tone_map.secondary[Luma::k40]};
  mixer[cros_tokens::kCrosRefSecondary50] = {tone_map.secondary[Luma::k50]};
  mixer[cros_tokens::kCrosRefSecondary60] = {tone_map.secondary[Luma::k60]};
  mixer[cros_tokens::kCrosRefSecondary70] = {tone_map.secondary[Luma::k70]};
  mixer[cros_tokens::kCrosRefSecondary80] = {tone_map.secondary[Luma::k80]};
  mixer[cros_tokens::kCrosRefSecondary90] = {tone_map.secondary[Luma::k90]};
  mixer[cros_tokens::kCrosRefSecondary95] = {tone_map.secondary[Luma::k95]};
  mixer[cros_tokens::kCrosRefSecondary99] = {tone_map.secondary[Luma::k99]};
  mixer[cros_tokens::kCrosRefSecondary100] = {tone_map.secondary[Luma::k100]};

  mixer[cros_tokens::kCrosRefTertiary0] = {tone_map.tertiary[Luma::k0]};
  mixer[cros_tokens::kCrosRefTertiary10] = {tone_map.tertiary[Luma::k10]};
  mixer[cros_tokens::kCrosRefTertiary20] = {tone_map.tertiary[Luma::k20]};
  mixer[cros_tokens::kCrosRefTertiary30] = {tone_map.tertiary[Luma::k30]};
  mixer[cros_tokens::kCrosRefTertiary40] = {tone_map.tertiary[Luma::k40]};
  mixer[cros_tokens::kCrosRefTertiary50] = {tone_map.tertiary[Luma::k50]};
  mixer[cros_tokens::kCrosRefTertiary60] = {tone_map.tertiary[Luma::k60]};
  mixer[cros_tokens::kCrosRefTertiary70] = {tone_map.tertiary[Luma::k70]};
  mixer[cros_tokens::kCrosRefTertiary80] = {tone_map.tertiary[Luma::k80]};
  mixer[cros_tokens::kCrosRefTertiary90] = {tone_map.tertiary[Luma::k90]};
  mixer[cros_tokens::kCrosRefTertiary95] = {tone_map.tertiary[Luma::k95]};
  mixer[cros_tokens::kCrosRefTertiary99] = {tone_map.tertiary[Luma::k99]};
  mixer[cros_tokens::kCrosRefTertiary100] = {tone_map.tertiary[Luma::k100]};

  mixer[cros_tokens::kCrosRefError0] = {tone_map.error[Luma::k0]};
  mixer[cros_tokens::kCrosRefError10] = {tone_map.error[Luma::k10]};
  mixer[cros_tokens::kCrosRefError20] = {tone_map.error[Luma::k20]};
  mixer[cros_tokens::kCrosRefError30] = {tone_map.error[Luma::k30]};
  mixer[cros_tokens::kCrosRefError40] = {tone_map.error[Luma::k40]};
  mixer[cros_tokens::kCrosRefError50] = {tone_map.error[Luma::k50]};
  mixer[cros_tokens::kCrosRefError60] = {tone_map.error[Luma::k60]};
  mixer[cros_tokens::kCrosRefError70] = {tone_map.error[Luma::k70]};
  mixer[cros_tokens::kCrosRefError80] = {tone_map.error[Luma::k80]};
  mixer[cros_tokens::kCrosRefError90] = {tone_map.error[Luma::k90]};
  mixer[cros_tokens::kCrosRefError95] = {tone_map.error[Luma::k95]};
  mixer[cros_tokens::kCrosRefError99] = {tone_map.error[Luma::k99]};
  mixer[cros_tokens::kCrosRefError100] = {tone_map.error[Luma::k100]};

  mixer[cros_tokens::kCrosRefNeutral0] = {tone_map.neutral1[Luma::k0]};
  mixer[cros_tokens::kCrosRefNeutral10] = {tone_map.neutral1[Luma::k10]};
  mixer[cros_tokens::kCrosRefNeutral20] = {tone_map.neutral1[Luma::k20]};
  mixer[cros_tokens::kCrosRefNeutral30] = {tone_map.neutral1[Luma::k30]};
  mixer[cros_tokens::kCrosRefNeutral40] = {tone_map.neutral1[Luma::k40]};
  mixer[cros_tokens::kCrosRefNeutral50] = {tone_map.neutral1[Luma::k50]};
  mixer[cros_tokens::kCrosRefNeutral60] = {tone_map.neutral1[Luma::k60]};
  mixer[cros_tokens::kCrosRefNeutral70] = {tone_map.neutral1[Luma::k70]};
  mixer[cros_tokens::kCrosRefNeutral80] = {tone_map.neutral1[Luma::k80]};
  mixer[cros_tokens::kCrosRefNeutral90] = {tone_map.neutral1[Luma::k90]};
  mixer[cros_tokens::kCrosRefNeutral95] = {tone_map.neutral1[Luma::k95]};
  mixer[cros_tokens::kCrosRefNeutral99] = {tone_map.neutral1[Luma::k99]};
  mixer[cros_tokens::kCrosRefNeutral100] = {tone_map.neutral1[Luma::k100]};

  mixer[cros_tokens::kCrosRefNeutralvariant0] = {tone_map.neutral2[Luma::k0]};
  mixer[cros_tokens::kCrosRefNeutralvariant10] = {tone_map.neutral2[Luma::k10]};
  mixer[cros_tokens::kCrosRefNeutralvariant20] = {tone_map.neutral2[Luma::k20]};
  mixer[cros_tokens::kCrosRefNeutralvariant30] = {tone_map.neutral2[Luma::k30]};
  mixer[cros_tokens::kCrosRefNeutralvariant40] = {tone_map.neutral2[Luma::k40]};
  mixer[cros_tokens::kCrosRefNeutralvariant50] = {tone_map.neutral2[Luma::k50]};
  mixer[cros_tokens::kCrosRefNeutralvariant60] = {tone_map.neutral2[Luma::k60]};
  mixer[cros_tokens::kCrosRefNeutralvariant70] = {tone_map.neutral2[Luma::k70]};
  mixer[cros_tokens::kCrosRefNeutralvariant80] = {tone_map.neutral2[Luma::k80]};
  mixer[cros_tokens::kCrosRefNeutralvariant90] = {tone_map.neutral2[Luma::k90]};
  mixer[cros_tokens::kCrosRefNeutralvariant95] = {tone_map.neutral2[Luma::k95]};
  mixer[cros_tokens::kCrosRefNeutralvariant99] = {tone_map.neutral2[Luma::k99]};
  mixer[cros_tokens::kCrosRefNeutralvariant100] = {
      tone_map.neutral2[Luma::k100]};
}

}  // namespace

void AddCrosStylesColorMixer(ui::ColorProvider* provider,
                             const ui::ColorProviderManager::Key& key) {
  ui::ColorMixer& mixer = provider->AddMixer();
  bool dark_mode = key.color_mode == ui::ColorProviderManager::ColorMode::kDark;
  if (ash::features::IsJellyEnabled()) {
    AddRefPalette(mixer, key);
  } else {
    cros_tokens::AddCrosRefColorsToMixer(mixer, dark_mode);
  }
  cros_tokens::AddCrosSysColorsToMixer(mixer, dark_mode);

  // TODO(b/234400002): Remove legacy colors once all usages are cleaned up.
  cros_tokens::AddLegacySemanticColorsToMixer(mixer, dark_mode);

  if (ash::features::IsJellyEnabled())
    RemapLegacySemanticColors(mixer);
}

void AddAshColorMixer(ui::ColorProvider* provider,
                      const ui::ColorProviderManager::Key& key) {
  auto* ash_color_provider = AshColorProvider::Get();
  ui::ColorMixer& mixer = provider->AddMixer();

  AddShieldAndBaseColors(mixer, key);
  AddControlsColors(mixer, key);

  mixer[ui::kColorAshActionLabelFocusRingEdit] = {gfx::kGoogleBlue300};
  mixer[ui::kColorAshActionLabelFocusRingError] = {gfx::kGoogleRed300};
  mixer[ui::kColorAshActionLabelFocusRingHover] =
      ui::SetAlpha(gfx::kGoogleGrey200, 0x60);

  mixer[ui::kColorAshAppListFocusRingNoKeyboard] = {SK_AlphaTRANSPARENT};
  mixer[ui::kColorAshAppListSeparatorLight] = {
      ui::kColorAshSystemUIMenuSeparator};
  mixer[ui::kColorAshAppListSeparator] =
      ui::SetAlpha(gfx::kGoogleGrey900, 0x24);
  mixer[ui::kColorAshArcInputMenuSeparator] = {SK_ColorGRAY};
  mixer[ui::kColorAshEditFinishFocusRing] = {gfx::kGoogleBlue300};
  mixer[ui::kColorAshIconInOobe] = {kIconColorInOobe};

  // TODO(skau): Remove when dark/light mode launches.
  mixer[ui::kColorAshAppListFocusRingCompat] = {gfx::kGoogleBlue600};

  mixer[ui::kColorAshLightFocusRing] = {gfx::kGoogleBlue300};

  mixer[ui::kColorAshOnboardingFocusRing] = {gfx::kGoogleBlue300};

  if (!features::IsDarkLightModeEnabled()) {
    ash::ScopedLightModeAsDefault scoped_light_mode_as_default;
    mixer[ui::kColorAshSystemUILightBorderColor1] = {
        ui::kColorHighlightBorderBorder1};
    mixer[ui::kColorAshSystemUILightBorderColor2] = {
        ui::kColorHighlightBorderBorder2};
    mixer[ui::kColorAshSystemUILightHighlightColor1] = {
        ui::kColorHighlightBorderHighlight1};
    mixer[ui::kColorAshSystemUILightHighlightColor2] = {
        ui::kColorHighlightBorderHighlight2};
    return;
  }

  mixer[ui::kColorAshSystemUIMenuBackground] = {
      ash_color_provider->GetBaseLayerColor(
          AshColorProvider::BaseLayerType::kTransparent80)};
  mixer[ui::kColorAshSystemUIMenuIcon] = {
      ash_color_provider->GetContentLayerColor(
          AshColorProvider::ContentLayerType::kIconColorPrimary)};

  auto [color, opacity] = ash_color_provider->GetInkDropBaseColorAndOpacity();
  mixer[ui::kColorAshSystemUIMenuItemBackgroundSelected] = {
      SkColorSetA(color, opacity * SK_AlphaOPAQUE)};
  mixer[ui::kColorAshSystemUIMenuSeparator] = {
      ash_color_provider->GetContentLayerColor(
          AshColorProvider::ContentLayerType::kSeparatorColor)};
}

}  // namespace ash

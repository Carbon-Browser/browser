// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package org.chromium.chrome.browser.provider;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Intent;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.net.Uri;
import android.util.Pair;

import androidx.annotation.GuardedBy;
import androidx.annotation.IntDef;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.VisibleForTesting;

import org.json.JSONException;
import org.json.JSONObject;

import org.chromium.base.ContextUtils;
import org.chromium.base.ThreadUtils;
import org.chromium.base.TimeUtils;
import org.chromium.base.TraceEvent;
import org.chromium.base.metrics.RecordHistogram;
import org.chromium.base.task.PostTask;
import org.chromium.base.task.TaskTraits;
import org.chromium.build.annotations.UsedByReflection;
import org.chromium.chrome.browser.ActivityTabProvider;
import org.chromium.chrome.browser.base.SplitCompatContentProvider;
import org.chromium.chrome.browser.content_extraction.InnerTextBridge;
import org.chromium.chrome.browser.flags.ChromeFeatureList;
import org.chromium.chrome.browser.gsa.GSAUtils;
import org.chromium.chrome.browser.provider.PageContentProviderImpl.PageContentInvocationState.PageExtractionState;
import org.chromium.chrome.browser.provider.PageContentProviderMetrics.PageContentProviderEvent;
import org.chromium.chrome.browser.tab.Tab;
import org.chromium.content_public.browser.RenderFrameHost;

import java.util.Optional;
import java.util.UUID;

/**
 * ContentProvider that returns the InnerText of the current web page. It generates a URI for the
 * current web page that is attached to {@link android.app.assist.AssistContent} whenever an
 * assistant is invoked when ChromeActivity is visible. The assistant app calls the query method to
 * start the text extraction process and it receives a notification when done, then it calls query
 * again to retrieve the text. Generated URIs can only be used once to retrieve text, and they
 * become invalid after a timeout period or if the current web page changes (e.g. navigation or tab
 * switches).
 */
@UsedByReflection("PageContentProvider.java")
public class PageContentProviderImpl extends SplitCompatContentProvider.Impl {

    private static final int INVALIDATE_URI_DELAY_MS = 10_000;
    private static final String[] AUTHORIZED_PACKAGE_NAMES =
            new String[] {GSAUtils.GSA_PACKAGE_NAME};

    static final class PageContentInvocationState {

        @IntDef({
            PageExtractionState.NOT_STARTED,
            PageExtractionState.STARTED,
            PageExtractionState.COMPLETE,
        })
        @interface PageExtractionState {
            int NOT_STARTED = 0;
            int STARTED = 1;
            int COMPLETE = 2;
        }

        public PageContentInvocationState(
                @NonNull String invocationId,
                @NonNull String invokedUrl,
                @NonNull ActivityTabProvider activityTabProvider) {
            mInvocationId = invocationId;
            mInvokedUrl = invokedUrl;
            mActivityTabProvider = activityTabProvider;
            mExtractionState = PageExtractionState.NOT_STARTED;
            mInvocationStartTimestampMs = TimeUtils.elapsedRealtimeMillis();
        }

        @NonNull private final String mInvocationId;
        @NonNull private final String mInvokedUrl;
        @Nullable private String mPageContents;
        @PageExtractionState private int mExtractionState;
        @NonNull private final ActivityTabProvider mActivityTabProvider;

        private long mInvocationStartTimestampMs;
        private long mExtractionStartTimestampMs;
        private long mExtractionFinishedTimestampMs;
    }

    private static final String AUTHORITY_SUFFIX = ".PageContentProvider";
    private static final String CONTENT_PATH = "*";

    private static final int URI_MATCH_INVOCATION_URL = 1;

    private UriMatcher mUriMatcher;

    @GuardedBy("sLock")
    private static PageContentInvocationState sInvocationState;

    private static final Object sLock = new Object();

    private void ensureUriMatcherInitialized() {
        if (mUriMatcher != null) {
            return;
        }

        mUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        String authority = ContextUtils.getApplicationContext().getPackageName() + AUTHORITY_SUFFIX;
        mUriMatcher.addURI(authority, CONTENT_PATH, URI_MATCH_INVOCATION_URL);
    }

    /**
     * Method called by external apps. {@link uri} must be a valid URI generated by {@code
     * getContentUriForURL()}.
     *
     * <p>The first call with a URI starts the text extraction process for the associated page.
     * External apps can be notified that the extraction process completed by observing changes to
     * {@link uri}. Calling this method after the extraction process is complete will return the
     * page's text and invalidate the URI.
     *
     * <p>If successful it returns a {@link Cursor} with 3 columns and 1 row: - "_id": The current
     * page URL. - "is_finished_loading": 1 if page extraction is complete, 0 otherwise. -
     * "contents": The text from the current page if page extraction is complete, empty string
     * otherwise.
     *
     * <p>In case of failure (e.g. timeout, page is no longer visible) then an empty {@link Cursor}
     * is returned.
     */
    @Nullable
    @Override
    public Cursor query(
            @NonNull Uri uri,
            @Nullable String[] strings,
            @Nullable String s,
            @Nullable String[] strings1,
            @Nullable String s1) {
        try (var t = TraceEvent.scoped("PageContentProviderImpl.query")) {
            if (!ChromeFeatureList.isEnabled(ChromeFeatureList.PAGE_CONTENT_PROVIDER)) {
                return null;
            }

            synchronized (sLock) {
                PageContentProviderMetrics.recordPageProviderEvent(PageContentProviderEvent.QUERY);
                ensureUriMatcherInitialized();
                final int match = mUriMatcher.match(uri);

                switch (match) {
                    case URI_MATCH_INVOCATION_URL -> {}
                    default -> {
                        PageContentProviderMetrics.recordPageProviderEvent(
                                PageContentProviderEvent.QUERY_FAILED_INVALID_URL);
                        throw new IllegalArgumentException("Unknown URL");
                    }
                }

                String id = uri.getLastPathSegment();
                MatrixCursor cursor =
                        new MatrixCursor(new String[] {"_id", "is_finished_loading", "contents"});

                if (id == null
                        || sInvocationState == null
                        || !id.equals(sInvocationState.mInvocationId)) {
                    PageContentProviderMetrics.recordPageProviderEvent(
                            PageContentProviderEvent.QUERY_FAILED_INVALID_ID);
                    return cursor;
                }

                ActivityTabProvider tabProvider = sInvocationState.mActivityTabProvider;
                Pair<String, RenderFrameHost> currentTabUrlAndFrameHost =
                        ThreadUtils.runOnUiThreadBlocking(
                                () -> {
                                    try (var u =
                                            TraceEvent.scoped(
                                                    "PageContentProviderImpl.queryGetVisibleUrl")) {
                                        Tab currentTab = tabProvider.get();

                                        if (currentTab == null
                                                || currentTab.getUrl() == null
                                                || currentTab.getWebContents() == null
                                                || currentTab.getWebContents().getMainFrame()
                                                        == null) {
                                            return null;
                                        }

                                        return Pair.create(
                                                currentTab.getUrl().getSpec(),
                                                currentTab.getWebContents().getMainFrame());
                                    }
                                });

                if (currentTabUrlAndFrameHost == null
                        || !sInvocationState.mInvokedUrl.equals(currentTabUrlAndFrameHost.first)) {
                    PageContentProviderMetrics.recordPageProviderEvent(
                            currentTabUrlAndFrameHost == null
                                    ? PageContentProviderEvent.QUERY_FAILED_TO_GET_CURRENT_TAB
                                    : PageContentProviderEvent.QUERY_FAILED_CURRENT_TAB_CHANGED);
                    return cursor;
                }

                var pageContents = "";
                var isFinishedLoading =
                        sInvocationState.mExtractionState == PageExtractionState.COMPLETE;
                if (isFinishedLoading) {
                    pageContents = sInvocationState.mPageContents;
                    recordExtractionEndToFinalQueryLatency();
                    clearCachedContent();
                    PageContentProviderMetrics.recordPageProviderEvent(
                            PageContentProviderEvent.QUERY_SUCCEEDED_RETURNED_EXTRACTED);
                } else if (sInvocationState.mExtractionState == PageExtractionState.NOT_STARTED) {
                    requestPageContents(
                            sInvocationState.mInvokedUrl, currentTabUrlAndFrameHost.second);
                    recordCreateToExtractionStartLatency();
                    PageContentProviderMetrics.recordPageProviderEvent(
                            PageContentProviderEvent.QUERY_SUCCEEDED_STARTED_EXTRACTION);
                    sInvocationState.mExtractionState = PageExtractionState.STARTED;

                } else {
                    PageContentProviderMetrics.recordPageProviderEvent(
                            PageContentProviderEvent.QUERY_SUCCEEDED_ALREADY_EXTRACTING);
                }

                cursor.addRow(
                        new Object[] {
                            currentTabUrlAndFrameHost.first, isFinishedLoading ? 1 : 0, pageContents
                        });

                return cursor;
            }
        }
    }

    @Nullable
    @Override
    public String getType(@NonNull Uri uri) {
        return null;
    }

    @Nullable
    @Override
    public Uri insert(@NonNull Uri uri, @Nullable ContentValues contentValues) {
        return null;
    }

    @Override
    public int delete(@NonNull Uri uri, @Nullable String s, @Nullable String[] strings) {
        return 0;
    }

    @Override
    public int update(
            @NonNull Uri uri,
            @Nullable ContentValues contentValues,
            @Nullable String s,
            @Nullable String[] strings) {
        return 0;
    }

    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
    protected static String getContentUriForUrl(
            String url, ActivityTabProvider activityTabProvider) {
        if (!ChromeFeatureList.isEnabled(ChromeFeatureList.PAGE_CONTENT_PROVIDER)) {
            return null;
        }

        synchronized (sLock) {
            if (url == null) return null;

            if (sInvocationState != null && sInvocationState.mInvokedUrl.equals(url)) {
                return buildContentUri(sInvocationState.mInvocationId).toString();
            } else {
                clearCachedContent();

                sInvocationState =
                        new PageContentInvocationState(
                                UUID.randomUUID().toString(), url, activityTabProvider);

                Uri uri = buildContentUri(sInvocationState.mInvocationId);
                grantAccessToUri(uri);

                // Invalidate this ID after 10 seconds.
                String invocationId = sInvocationState.mInvocationId;
                PostTask.postDelayedTask(
                        TaskTraits.USER_VISIBLE,
                        () -> clearCachedContentWithId(invocationId),
                        INVALIDATE_URI_DELAY_MS);

                return uri.toString();
            }
        }
    }

    /**
     * Generates a JSON string to be attached to AssistContent to be shared with an assistant app.
     *
     * @param url The URL of the currently active page, the returned URI will only work for this
     *     URL.
     * @param activityTabProvider Provider used to ensure that {@code url} is still active on all
     *     calls to {@code query()}
     * @return A JSON string containing a URI to be used with the {@code query()} method to extract
     *     the text of {@code url}.
     */
    @Nullable
    public static String getAssistContentStructuredDataForUrl(
            String url, ActivityTabProvider activityTabProvider) {
        String contentUri = getContentUriForUrl(url, activityTabProvider);
        if (contentUri == null) return null;

        String structuredData;

        try {
            structuredData =
                    new JSONObject()
                            .put("page_metadata", new JSONObject().put("content_uri", contentUri))
                            .toString();
        } catch (JSONException e) {
            return null;
        }

        return structuredData;
    }

    private static Uri buildContentUri(String id) {
        Uri uri =
                new Uri.Builder()
                        .scheme(ContentResolver.SCHEME_CONTENT)
                        .authority(
                                ContextUtils.getApplicationContext().getPackageName()
                                        + AUTHORITY_SUFFIX)
                        .path(id)
                        .build();
        return uri;
    }

    private static void grantAccessToUri(Uri uri) {
        for (String packageName : AUTHORIZED_PACKAGE_NAMES) {
            ContextUtils.getApplicationContext()
                    .grantUriPermission(packageName, uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        }
    }

    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
    protected static void clearCachedContent() {
        synchronized (sLock) {
            if (sInvocationState != null) {
                Uri previousUri = buildContentUri(sInvocationState.mInvocationId);
                ContextUtils.getApplicationContext()
                        .revokeUriPermission(previousUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
            }

            sInvocationState = null;
        }
    }

    /**
     * Clears the cached content related to an invocationId, meant to be used with a timer to clear
     * out data related to URIs that are never queried.
     *
     * @param invocationId Invocation ID to clear, used to avoid clearing a newer request
     *     prematurely.
     */
    private static void clearCachedContentWithId(String invocationId) {
        synchronized (sLock) {
            if (sInvocationState == null || !sInvocationState.mInvocationId.equals(invocationId)) {
                return;
            }

            PageContentProviderMetrics.recordPageProviderEvent(PageContentProviderEvent.TIMEOUT);
            clearCachedContent();
        }
    }

    private void requestPageContents(String requestedUrl, RenderFrameHost renderFrameHost) {
        try (var t = TraceEvent.scoped("PageContentProvider.requestPageContents")) {
            ThreadUtils.runOnUiThread(
                    new Runnable() {
                        @Override
                        public void run() {
                            try (var u =
                                    TraceEvent.scoped(
                                            "PageContentProvider.requestContentsOnUiThread")) {
                                InnerTextBridge.getInnerText(
                                        renderFrameHost,
                                        result -> onPageTextReceived(requestedUrl, result));
                            }
                        }
                    });
        }
    }

    private static void recordCreateToExtractionStartLatency() {
        synchronized (sLock) {
            if (sInvocationState == null) return;

            if (sInvocationState.mInvocationStartTimestampMs != 0) {
                RecordHistogram.recordMediumTimesHistogram(
                        "Android.AssistContent.WebPageContentProvider.Latency.CreateToExtractionStart",
                        TimeUtils.elapsedRealtimeMillis()
                                - sInvocationState.mInvocationStartTimestampMs);
                sInvocationState.mExtractionStartTimestampMs = TimeUtils.elapsedRealtimeMillis();
            }
        }
    }

    private static void recordExtractionStartToEndLatency() {
        synchronized (sLock) {
            if (sInvocationState == null) return;

            if (sInvocationState.mExtractionStartTimestampMs != 0) {
                RecordHistogram.recordMediumTimesHistogram(
                        "Android.AssistContent.WebPageContentProvider.Latency.ExtractionStartToEnd",
                        TimeUtils.elapsedRealtimeMillis()
                                - sInvocationState.mExtractionStartTimestampMs);
                sInvocationState.mExtractionStartTimestampMs = 0;
                sInvocationState.mExtractionFinishedTimestampMs = TimeUtils.elapsedRealtimeMillis();
            }
        }
    }

    private static void recordExtractionEndToFinalQueryLatency() {
        synchronized (sLock) {
            if (sInvocationState == null) return;

            if (sInvocationState.mExtractionFinishedTimestampMs != 0) {
                RecordHistogram.recordMediumTimesHistogram(
                        "Android.AssistContent.WebPageContentProvider.Latency.ExtractionEndToFinalQuery",
                        TimeUtils.elapsedRealtimeMillis()
                                - sInvocationState.mExtractionFinishedTimestampMs);
                sInvocationState.mExtractionFinishedTimestampMs = 0;
            }

            if (sInvocationState.mInvocationStartTimestampMs != 0) {
                RecordHistogram.recordMediumTimesHistogram(
                        "Android.AssistContent.WebPageContentProvider.Latency.CreateToFinalQuery",
                        TimeUtils.elapsedRealtimeMillis()
                                - sInvocationState.mInvocationStartTimestampMs);
                sInvocationState.mInvocationStartTimestampMs = 0;
            }
        }
    }

    private void onPageTextReceived(String requestedUrl, Optional<String> pageText) {
        try (var u = TraceEvent.scoped("PageContentProvider.onPageTextReceived")) {
            synchronized (sLock) {
                // TODO(salg@): Notify callers of error state.
                if (sInvocationState == null
                        || !sInvocationState.mInvokedUrl.equals(requestedUrl)
                        || pageText.isEmpty()) {
                    PageContentProviderMetrics.recordPageProviderEvent(
                            pageText.isEmpty()
                                    ? PageContentProviderEvent.TEXT_EXTRACTION_FAILED_EMPTY_RESULT
                                    : PageContentProviderEvent.TEXT_EXTRACTION_FAILED_TAB_CHANGED);
                    return;
                }

                sInvocationState.mExtractionState = PageExtractionState.COMPLETE;
                sInvocationState.mPageContents = pageText.get();
                Uri uriToNotify = buildContentUri(sInvocationState.mInvocationId);
                ContextUtils.getApplicationContext()
                        .getContentResolver()
                        .notifyChange(uriToNotify, null);
                PageContentProviderMetrics.recordPageProviderEvent(
                        PageContentProviderEvent.TEXT_EXTRACTION_SUCCEEDED);
                recordExtractionStartToEndLatency();
            }
        }
    }
}

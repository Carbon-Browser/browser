/**
    *   @eyeo/mlbrowserutils - v0.3.0
    *   ML utility package for ABP's snippet library
    *   Made by eyeo GmbH
    *   Under GPL-3.0-only License
    *
    *   The following npm packages may be included in this product:
    *
    *   - tfjs
    *   - tfjs-backend-cpu
    *   - tfjs-backend-webgl
    *   - tfjs-converter
    *   - tfjs-core
    *   - tfjs-data
    *   - tfjs-layers
    *
    *    These packages contain the following information about the license:
    *
    *  * @license
    *  * Copyright 2018-2022 Google LLC. All Rights Reserved.
    *  * Licensed under the Apache License, Version 2.0 (the "License");
    *  * you may not use this file except in compliance with the License.
    *  * You may obtain a copy of the License at
    *  *
    *  * http://www.apache.org/licenses/LICENSE-2.0
    *  *
    *  * Unless required by applicable law or agreed to in writing, software
    *  * distributed under the License is distributed on an "AS IS" BASIS,
    *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    *  * See the License for the specific language governing permissions and
    *  * limitations under the License.
    *  * =============================================================================
    */
function _mergeNamespaces(e,t){t.forEach((function(t){t&&typeof t!=="string"&&!Array.isArray(t)&&Object.keys(t).forEach((function(n){if(n!=="default"&&!(n in e)){var r=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,r.get?r:{enumerable:true,get:function(){return t[n]}});}}));}));return Object.freeze(e)}
const EPSILON_FLOAT32$1=1e-7;const EPSILON_FLOAT16$1=1e-4;class DataStorage{constructor(e,t){this.backend=e;this.dataMover=t;this.data=new WeakMap;this.dataIdsCount=0;}get(e){if(!this.data.has(e)){this.dataMover.moveData(this.backend,e);}return this.data.get(e)}set(e,t){this.dataIdsCount++;this.data.set(e,t);}has(e){return this.data.has(e)}delete(e){this.dataIdsCount--;return this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class KernelBackend{refCount(e){return notYetImplemented("refCount")}incRef(e){return notYetImplemented("incRef")}timerAvailable(){return true}time(e){return notYetImplemented("time")}read(e){return notYetImplemented("read")}readSync(e){return notYetImplemented("readSync")}readToGPU(e,t){return notYetImplemented("readToGPU")}numDataIds(){return notYetImplemented("numDataIds")}disposeData(e,t){return notYetImplemented("disposeData")}write(e,t,n){return notYetImplemented("write")}move(e,t,n,r,s){return notYetImplemented("move")}memory(){return notYetImplemented("memory")}floatPrecision(){return notYetImplemented("floatPrecision")}epsilon(){return this.floatPrecision()===32?EPSILON_FLOAT32$1:EPSILON_FLOAT16$1}dispose(){return notYetImplemented("dispose")}}
function nearestLargerEven(e){return e%2===0?e:e+1}function sum$2(e){let t=0;for(let n=0;n<e.length;n++){t+=e[n];}return t}function assert(e,t){if(!e){throw new Error(typeof t==="string"?t:t())}}function assertShapesMatch(e,t,n=""){assert(arraysEqual(e,t),(()=>n+` Shapes ${e} and ${t} must match`));}function assertNonNull(e){assert(e!=null,(()=>`The input to the tensor constructor must be a non-null value.`));}function flatten(e,t=[],n=false){if(t==null){t=[];}if(Array.isArray(e)||isTypedArray(e)&&!n){for(let r=0;r<e.length;++r){flatten(e[r],t,n);}}else {t.push(e);}return t}function sizeFromShape(e){if(e.length===0){return 1}let t=e[0];for(let n=1;n<e.length;n++){t*=e[n];}return t}function arraysEqual(e,t){if(e===t){return true}if(e==null||t==null){return false}if(e.length!==t.length){return false}for(let n=0;n<e.length;n++){if(e[n]!==t[n]){return false}}return true}function isInt(e){return e%1===0}function sizeToSquarishShape(e){const t=Math.ceil(Math.sqrt(e));return [t,Math.ceil(e/t)]}function rightPad(e,t){if(t<=e.length){return e}return e+" ".repeat(t-e.length)}function repeatedTry(e,t=(e=>0),n){return new Promise(((r,s)=>{let a=0;const o=()=>{if(e()){r();return}a++;const i=t(a);if(n!=null&&a>=n){s();return}setTimeout(o,i);};o();}))}function inferFromImplicitShape(e,t){let n=1;let r=-1;for(let t=0;t<e.length;++t){if(e[t]>=0){n*=e[t];}else if(e[t]===-1){if(r!==-1){throw Error(`Shapes can only have 1 implicit size. `+`Found -1 at dim ${r} and dim ${t}`)}r=t;}else if(e[t]<0){throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`)}}if(r===-1){if(t>0&&t!==n){throw Error(`Size(${t}) must match the product of shape ${e}`)}return e}if(n===0){throw Error(`Cannot infer the missing size in [${e}] when `+`there are 0 elements`)}if(t%n!==0){throw Error(`The implicit shape can't be a fractional number. `+`Got ${t} / ${n}`)}const s=e.slice();s[r]=t/n;return s}function parseAxisParam(e,t){const n=t.length;e=e==null?t.map(((e,t)=>t)):[].concat(e);assert(e.every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but `+`got axis ${e}`));assert(e.every((e=>isInt(e))),(()=>`All values in axis param must be integers but `+`got axis ${e}`));return e.map((e=>e<0?n+e:e))}function squeezeShape(e,t){const n=[];const r=[];const s=t!=null&&Array.isArray(t)&&t.length===0;const a=t==null||s?null:parseAxisParam(t,e).sort();let o=0;for(let t=0;t<e.length;++t){if(a!=null){if(a[o]===t&&e[t]!==1){throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`)}if((a[o]==null||a[o]>t)&&e[t]===1){n.push(e[t]);r.push(t);}if(a[o]<=t){o++;}}if(e[t]!==1){n.push(e[t]);r.push(t);}}return {newShape:n,keptDims:r}}function getTypedArrayFromDType(e,t){let n=null;if(e==null||e==="float32"){n=new Float32Array(t);}else if(e==="int32"){n=new Int32Array(t);}else if(e==="bool"){n=new Uint8Array(t);}else {throw new Error(`Unknown data type ${e}`)}return n}function getArrayFromDType(e,t){let n=null;if(e==null||e==="float32"){n=new Float32Array(t);}else if(e==="int32"){n=new Int32Array(t);}else if(e==="bool"){n=new Uint8Array(t);}else if(e==="string"){n=new Array(t);}else {throw new Error(`Unknown data type ${e}`)}return n}function isValidDtype(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function hasEncodingLoss(e,t){if(t==="complex64"){return false}if(t==="float32"&&e!=="complex64"){return false}if(t==="int32"&&e!=="float32"&&e!=="complex64"){return false}if(t==="bool"&&e==="bool"){return false}return true}function isTypedArray(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function bytesPerElement(e){if(e==="float32"||e==="int32"){return 4}else if(e==="complex64"){return 8}else if(e==="bool"){return 1}else {throw new Error(`Unknown dtype ${e}`)}}function bytesFromStringArray(e){if(e==null){return 0}let t=0;e.forEach((e=>t+=e.length));return t}function isNumber(e){return typeof e==="number"}function inferDtype(e){if(Array.isArray(e)){return inferDtype(e[0])}if(e instanceof Float32Array){return "float32"}else if(e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray){return "int32"}else if(isNumber(e)){return "float32"}else if(isString(e)){return "string"}else if(isBoolean(e)){return "bool"}return "float32"}function isFunction(e){return !!(e&&e.constructor&&e.call&&e.apply)}function nearestDivisor(e,t){for(let n=t;n<e;++n){if(e%n===0){return n}}return e}function computeStrides(e){const t=e.length;if(t<2){return []}const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r){n[r]=n[r+1]*e[r+1];}return n}function createNestedArray(e,t,n,r=false){const s=new Array;if(t.length===1){const a=t[0]*(r?2:1);for(let t=0;t<a;t++){s[t]=n[e+t];}}else {const a=t[0];const o=t.slice(1);const i=o.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<a;t++){s[t]=createNestedArray(e+t*i,o,n,r);}}return s}function toNestedArray(e,t,n=false){if(e.length===0){return t[0]}const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(r===0){return []}if(r!==t.length){throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`)}return createNestedArray(0,e,t,n)}function makeOnesTypedArray(e,t){const n=makeZerosTypedArray(e,t);for(let e=0;e<n.length;e++){n[e]=1;}return n}function makeZerosTypedArray(e,t){if(t==null||t==="float32"||t==="complex64"){return new Float32Array(e)}else if(t==="int32"){return new Int32Array(e)}else if(t==="bool"){return new Uint8Array(e)}else {throw new Error(`Unknown data type ${t}`)}}function assertNonNegativeIntegerDimensions(e){e.forEach((t=>{assert(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got `+`shape [${e}].`));}));}function locToIndex(e,t,n){if(t===0){return 0}else if(t===1){return e[0]}let r=e[e.length-1];for(let t=0;t<e.length-1;++t){r+=n[t]*e[t];}return r}function indexToLoc(e,t,n){if(t===0){return []}else if(t===1){return [e]}const r=new Array(t);for(let t=0;t<r.length-1;++t){r[t]=Math.floor(e/n[t]);e-=r[t]*n[t];}r[r.length-1]=e;return r}function isPromise(e){return e&&e.then&&typeof e.then==="function"}
const TENSORFLOWJS_FLAGS_PREFIX="tfjsflags";class Environment{constructor(e){this.global=e;this.flags={};this.flagRegistry={};this.urlFlags={};this.getQueryParams=getQueryParams;this.populateURLFlags();}setPlatform(e,t){if(this.platform!=null){if(!(env().getBool("IS_TEST")||env().getBool("PROD"))){console.warn(`Platform ${this.platformName} has already been set. `+`Overwriting the platform with ${e}.`);}}this.platformName=e;this.platform=t;}registerFlag(e,t,n){this.flagRegistry[e]={evaluationFn:t,setHook:n};if(this.urlFlags[e]!=null){const t=this.urlFlags[e];if(!(env().getBool("IS_TEST")||env().getBool("PROD"))){console.warn(`Setting feature override from URL ${e}: ${t}.`);}this.set(e,t);}}async getAsync(e){if(e in this.flags){return this.flags[e]}this.flags[e]=await this.evaluateFlag(e);return this.flags[e]}get(e){if(e in this.flags){return this.flags[e]}const t=this.evaluateFlag(e);if(isPromise(t)){throw new Error(`Flag ${e} cannot be synchronously evaluated. `+`Please use getAsync() instead.`)}this.flags[e]=t;return this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null){throw new Error(`Cannot set flag ${e} as it has not been registered.`)}this.flags[e]=t;if(this.flagRegistry[e].setHook!=null){this.flagRegistry[e].setHook(t);}}evaluateFlag(e){if(this.flagRegistry[e]==null){throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`)}return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e);}reset(){this.flags={};this.urlFlags={};this.populateURLFlags();}populateURLFlags(){if(typeof this.global==="undefined"||typeof this.global.location==="undefined"||typeof this.global.location.search==="undefined"){return}const e=this.getQueryParams(this.global.location.search);if(TENSORFLOWJS_FLAGS_PREFIX in e){const t=e[TENSORFLOWJS_FLAGS_PREFIX].split(",");t.forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=parseValue(t,n);}));}}}function getQueryParams(e){const t={};e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>{decodeParam(t,n[0],n[1]);return n.join("=")}));return t}function decodeParam(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"");}function env(){return ENV$3}let ENV$3=null;function setEnvironmentGlobal(e){ENV$3=e;}
let globalNameSpace;function getGlobalNamespace(){if(globalNameSpace==null){let e;if(typeof window!=="undefined"){e=window;}else if(typeof global!=="undefined"){e=global;}else if(typeof process!=="undefined"){e=process;}else if(typeof self!=="undefined"){e=self;}else {throw new Error("Could not find a global object")}globalNameSpace=e;}return globalNameSpace}function getGlobalMap(){const e=getGlobalNamespace();if(e._tfGlobals==null){e._tfGlobals=new Map;}return e._tfGlobals}function getGlobal(e,t){const n=getGlobalMap();if(n.has(e)){return n.get(e)}else {const r=t();n.set(e,r);return n.get(e)}}const Abs="Abs";const Add="Add";const BatchMatMul="BatchMatMul";const Bincount="Bincount";const Cast="Cast";const Complex="Complex";const ComplexAbs="ComplexAbs";const Concat="Concat";const Conv2DBackpropFilter="Conv2DBackpropFilter";const Conv2DBackpropInput="Conv2DBackpropInput";const DepthwiseConv2dNativeBackpropFilter="DepthwiseConv2dNativeBackpropFilter";const DepthwiseConv2dNativeBackpropInput="DepthwiseConv2dNativeBackpropInput";const RealDiv="RealDiv";const Equal="Equal";const Exp="Exp";const ExpandDims="ExpandDims";const FFT="FFT";const GatherV2="GatherV2";const Greater="Greater";const Identity="Identity";const IsFinite="IsFinite";const Log="Log";const Log1p="Log1p";const LogicalAnd="LogicalAnd";const Max="Max";const Maximum="Maximum";const Mean="Mean";const Minimum="Minimum";const Multiply="Multiply";const Neg="Neg";const NotEqual="NotEqual";const OneHot="OneHot";const Pack="Pack";const PadV2="PadV2";const Pow="Pow";const Prod="Prod";const Range="Range";const Real="Real";const Relu="Relu";const Reshape="Reshape";const Reverse="Reverse";const Select="Select";const Slice="Slice";const Sigmoid="Sigmoid";const Sum="Sum";const SquaredDifference="SquaredDifference";const Sub="Sub";const Tile="Tile";const Unpack="Unpack";const ZerosLike="ZerosLike";const _FusedMatMul="_FusedMatMul";function warn(...e){if(!(env().getBool("IS_TEST")||env().getBool("PROD"))){console.warn(...e);}}function log$1(...e){if(!(env().getBool("IS_TEST")||env().getBool("PROD"))){console.log(...e);}}
const kernelRegistry=getGlobal("kernelRegistry",(()=>new Map));const gradRegistry=getGlobal("gradRegistry",(()=>new Map));function getKernel(e,t){const n=makeKey(e,t);return kernelRegistry.get(n)}function getGradient(e){return gradRegistry.get(e)}function getKernelsForBackend(e){const t=kernelRegistry.entries();const n=[];while(true){const{done:r,value:s}=t.next();if(r){break}const[a,o]=s;const[i]=a.split("_");if(i===e){n.push(o);}}return n}function registerKernel(e){const{kernelName:t,backendName:n}=e;const r=makeKey(t,n);if(kernelRegistry.has(r)){warn(`The kernel '${t}' for backend `+`'${n}' is already registered`);}kernelRegistry.set(r,e);}function makeKey(e,t){return `${t}_${e}`}var commonjsGlobal=typeof globalThis!=="undefined"?globalThis:typeof window!=="undefined"?window:typeof global!=="undefined"?global:typeof self!=="undefined"?self:{};var long=Long$1;var wasm=null;try{wasm=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports;}catch(e){}function Long$1(e,t,n){this.low=e|0;this.high=t|0;this.unsigned=!!n;}Long$1.prototype.__isLong__;Object.defineProperty(Long$1.prototype,"__isLong__",{value:true});function isLong(e){return (e&&e["__isLong__"])===true}Long$1.isLong=isLong;var INT_CACHE={};var UINT_CACHE={};function fromInt(e,t){var n,r,s;if(t){e>>>=0;if(s=0<=e&&e<256){r=UINT_CACHE[e];if(r)return r}n=fromBits(e,(e|0)<0?-1:0,true);if(s)UINT_CACHE[e]=n;return n}else {e|=0;if(s=-128<=e&&e<128){r=INT_CACHE[e];if(r)return r}n=fromBits(e,e<0?-1:0,false);if(s)INT_CACHE[e]=n;return n}}Long$1.fromInt=fromInt;function fromNumber(e,t){if(isNaN(e))return t?UZERO:ZERO;if(t){if(e<0)return UZERO;if(e>=TWO_PWR_64_DBL)return MAX_UNSIGNED_VALUE}else {if(e<=-TWO_PWR_63_DBL)return MIN_VALUE;if(e+1>=TWO_PWR_63_DBL)return MAX_VALUE}if(e<0)return fromNumber(-e,t).neg();return fromBits(e%TWO_PWR_32_DBL|0,e/TWO_PWR_32_DBL|0,t)}Long$1.fromNumber=fromNumber;function fromBits(e,t,n){return new Long$1(e,t,n)}Long$1.fromBits=fromBits;var pow_dbl=Math.pow;function fromString(e,t,n){if(e.length===0)throw Error("empty string");if(e==="NaN"||e==="Infinity"||e==="+Infinity"||e==="-Infinity")return ZERO;if(typeof t==="number"){n=t,t=false;}else {t=!!t;}n=n||10;if(n<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");else if(r===0){return fromString(e.substring(1),t,n).neg()}var s=fromNumber(pow_dbl(n,8));var a=ZERO;for(var o=0;o<e.length;o+=8){var i=Math.min(8,e.length-o),c=parseInt(e.substring(o,o+i),n);if(i<8){var u=fromNumber(pow_dbl(n,i));a=a.mul(u).add(fromNumber(c));}else {a=a.mul(s);a=a.add(fromNumber(c));}}a.unsigned=t;return a}Long$1.fromString=fromString;function fromValue(e,t){if(typeof e==="number")return fromNumber(e,t);if(typeof e==="string")return fromString(e,t);return fromBits(e.low,e.high,typeof t==="boolean"?t:e.unsigned)}Long$1.fromValue=fromValue;var TWO_PWR_16_DBL=1<<16;var TWO_PWR_24_DBL=1<<24;var TWO_PWR_32_DBL=TWO_PWR_16_DBL*TWO_PWR_16_DBL;var TWO_PWR_64_DBL=TWO_PWR_32_DBL*TWO_PWR_32_DBL;var TWO_PWR_63_DBL=TWO_PWR_64_DBL/2;var TWO_PWR_24=fromInt(TWO_PWR_24_DBL);var ZERO=fromInt(0);Long$1.ZERO=ZERO;var UZERO=fromInt(0,true);Long$1.UZERO=UZERO;var ONE=fromInt(1);Long$1.ONE=ONE;var UONE=fromInt(1,true);Long$1.UONE=UONE;var NEG_ONE=fromInt(-1);Long$1.NEG_ONE=NEG_ONE;var MAX_VALUE=fromBits(4294967295|0,2147483647|0,false);Long$1.MAX_VALUE=MAX_VALUE;var MAX_UNSIGNED_VALUE=fromBits(4294967295|0,4294967295|0,true);Long$1.MAX_UNSIGNED_VALUE=MAX_UNSIGNED_VALUE;var MIN_VALUE=fromBits(0,2147483648|0,false);Long$1.MIN_VALUE=MIN_VALUE;var LongPrototype=Long$1.prototype;LongPrototype.toInt=function e(){return this.unsigned?this.low>>>0:this.low};LongPrototype.toNumber=function e(){if(this.unsigned)return (this.high>>>0)*TWO_PWR_32_DBL+(this.low>>>0);return this.high*TWO_PWR_32_DBL+(this.low>>>0)};LongPrototype.toString=function e(t){t=t||10;if(t<2||36<t)throw RangeError("radix");if(this.isZero())return "0";if(this.isNegative()){if(this.eq(MIN_VALUE)){var n=fromNumber(t),r=this.div(n),s=r.mul(n).sub(this);return r.toString(t)+s.toInt().toString(t)}else return "-"+this.neg().toString(t)}var a=fromNumber(pow_dbl(t,6),this.unsigned),o=this;var i="";while(true){var c=o.div(a),u=o.sub(c.mul(a)).toInt()>>>0,l=u.toString(t);o=c;if(o.isZero())return l+i;else {while(l.length<6)l="0"+l;i=""+l+i;}}};LongPrototype.getHighBits=function e(){return this.high};LongPrototype.getHighBitsUnsigned=function e(){return this.high>>>0};LongPrototype.getLowBits=function e(){return this.low};LongPrototype.getLowBitsUnsigned=function e(){return this.low>>>0};LongPrototype.getNumBitsAbs=function e(){if(this.isNegative())return this.eq(MIN_VALUE)?64:this.neg().getNumBitsAbs();var t=this.high!=0?this.high:this.low;for(var n=31;n>0;n--)if((t&1<<n)!=0)break;return this.high!=0?n+33:n+1};LongPrototype.isZero=function e(){return this.high===0&&this.low===0};LongPrototype.eqz=LongPrototype.isZero;LongPrototype.isNegative=function e(){return !this.unsigned&&this.high<0};LongPrototype.isPositive=function e(){return this.unsigned||this.high>=0};LongPrototype.isOdd=function e(){return (this.low&1)===1};LongPrototype.isEven=function e(){return (this.low&1)===0};LongPrototype.equals=function e(t){if(!isLong(t))t=fromValue(t);if(this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1)return false;return this.high===t.high&&this.low===t.low};LongPrototype.eq=LongPrototype.equals;LongPrototype.notEquals=function e(t){return !this.eq(t)};LongPrototype.neq=LongPrototype.notEquals;LongPrototype.ne=LongPrototype.notEquals;LongPrototype.lessThan=function e(t){return this.comp(t)<0};LongPrototype.lt=LongPrototype.lessThan;LongPrototype.lessThanOrEqual=function e(t){return this.comp(t)<=0};LongPrototype.lte=LongPrototype.lessThanOrEqual;LongPrototype.le=LongPrototype.lessThanOrEqual;LongPrototype.greaterThan=function e(t){return this.comp(t)>0};LongPrototype.gt=LongPrototype.greaterThan;LongPrototype.greaterThanOrEqual=function e(t){return this.comp(t)>=0};LongPrototype.gte=LongPrototype.greaterThanOrEqual;LongPrototype.ge=LongPrototype.greaterThanOrEqual;LongPrototype.compare=function e(t){if(!isLong(t))t=fromValue(t);if(this.eq(t))return 0;var n=this.isNegative(),r=t.isNegative();if(n&&!r)return -1;if(!n&&r)return 1;if(!this.unsigned)return this.sub(t).isNegative()?-1:1;return t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1};LongPrototype.comp=LongPrototype.compare;LongPrototype.negate=function e(){if(!this.unsigned&&this.eq(MIN_VALUE))return MIN_VALUE;return this.not().add(ONE)};LongPrototype.neg=LongPrototype.negate;LongPrototype.add=function e(t){if(!isLong(t))t=fromValue(t);var n=this.high>>>16;var r=this.high&65535;var s=this.low>>>16;var a=this.low&65535;var o=t.high>>>16;var i=t.high&65535;var c=t.low>>>16;var u=t.low&65535;var l=0,p=0,d=0,h=0;h+=a+u;d+=h>>>16;h&=65535;d+=s+c;p+=d>>>16;d&=65535;p+=r+i;l+=p>>>16;p&=65535;l+=n+o;l&=65535;return fromBits(d<<16|h,l<<16|p,this.unsigned)};LongPrototype.subtract=function e(t){if(!isLong(t))t=fromValue(t);return this.add(t.neg())};LongPrototype.sub=LongPrototype.subtract;LongPrototype.multiply=function e(t){if(this.isZero())return ZERO;if(!isLong(t))t=fromValue(t);if(wasm){var n=wasm.mul(this.low,this.high,t.low,t.high);return fromBits(n,wasm.get_high(),this.unsigned)}if(t.isZero())return ZERO;if(this.eq(MIN_VALUE))return t.isOdd()?MIN_VALUE:ZERO;if(t.eq(MIN_VALUE))return this.isOdd()?MIN_VALUE:ZERO;if(this.isNegative()){if(t.isNegative())return this.neg().mul(t.neg());else return this.neg().mul(t).neg()}else if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(TWO_PWR_24)&&t.lt(TWO_PWR_24))return fromNumber(this.toNumber()*t.toNumber(),this.unsigned);var r=this.high>>>16;var s=this.high&65535;var a=this.low>>>16;var o=this.low&65535;var i=t.high>>>16;var c=t.high&65535;var u=t.low>>>16;var l=t.low&65535;var p=0,d=0,h=0,m=0;m+=o*l;h+=m>>>16;m&=65535;h+=a*l;d+=h>>>16;h&=65535;h+=o*u;d+=h>>>16;h&=65535;d+=s*l;p+=d>>>16;d&=65535;d+=a*u;p+=d>>>16;d&=65535;d+=o*c;p+=d>>>16;d&=65535;p+=r*l+s*u+a*c+o*i;p&=65535;return fromBits(h<<16|m,p<<16|d,this.unsigned)};LongPrototype.mul=LongPrototype.multiply;LongPrototype.divide=function e(t){if(!isLong(t))t=fromValue(t);if(t.isZero())throw Error("division by zero");if(wasm){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1){return this}var n=(this.unsigned?wasm.div_u:wasm.div_s)(this.low,this.high,t.low,t.high);return fromBits(n,wasm.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?UZERO:ZERO;var r,s,a;if(!this.unsigned){if(this.eq(MIN_VALUE)){if(t.eq(ONE)||t.eq(NEG_ONE))return MIN_VALUE;else if(t.eq(MIN_VALUE))return ONE;else {var o=this.shr(1);r=o.div(t).shl(1);if(r.eq(ZERO)){return t.isNegative()?ONE:NEG_ONE}else {s=this.sub(t.mul(r));a=r.add(s.div(t));return a}}}else if(t.eq(MIN_VALUE))return this.unsigned?UZERO:ZERO;if(this.isNegative()){if(t.isNegative())return this.neg().div(t.neg());return this.neg().div(t).neg()}else if(t.isNegative())return this.div(t.neg()).neg();a=ZERO;}else {if(!t.unsigned)t=t.toUnsigned();if(t.gt(this))return UZERO;if(t.gt(this.shru(1)))return UONE;a=UZERO;}s=this;while(s.gte(t)){r=Math.max(1,Math.floor(s.toNumber()/t.toNumber()));var i=Math.ceil(Math.log(r)/Math.LN2),c=i<=48?1:pow_dbl(2,i-48),u=fromNumber(r),l=u.mul(t);while(l.isNegative()||l.gt(s)){r-=c;u=fromNumber(r,this.unsigned);l=u.mul(t);}if(u.isZero())u=ONE;a=a.add(u);s=s.sub(l);}return a};LongPrototype.div=LongPrototype.divide;LongPrototype.modulo=function e(t){if(!isLong(t))t=fromValue(t);if(wasm){var n=(this.unsigned?wasm.rem_u:wasm.rem_s)(this.low,this.high,t.low,t.high);return fromBits(n,wasm.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};LongPrototype.mod=LongPrototype.modulo;LongPrototype.rem=LongPrototype.modulo;LongPrototype.not=function e(){return fromBits(~this.low,~this.high,this.unsigned)};LongPrototype.and=function e(t){if(!isLong(t))t=fromValue(t);return fromBits(this.low&t.low,this.high&t.high,this.unsigned)};LongPrototype.or=function e(t){if(!isLong(t))t=fromValue(t);return fromBits(this.low|t.low,this.high|t.high,this.unsigned)};LongPrototype.xor=function e(t){if(!isLong(t))t=fromValue(t);return fromBits(this.low^t.low,this.high^t.high,this.unsigned)};LongPrototype.shiftLeft=function e(t){if(isLong(t))t=t.toInt();if((t&=63)===0)return this;else if(t<32)return fromBits(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned);else return fromBits(0,this.low<<t-32,this.unsigned)};LongPrototype.shl=LongPrototype.shiftLeft;LongPrototype.shiftRight=function e(t){if(isLong(t))t=t.toInt();if((t&=63)===0)return this;else if(t<32)return fromBits(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned);else return fromBits(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};LongPrototype.shr=LongPrototype.shiftRight;LongPrototype.shiftRightUnsigned=function e(t){if(isLong(t))t=t.toInt();t&=63;if(t===0)return this;else {var n=this.high;if(t<32){var r=this.low;return fromBits(r>>>t|n<<32-t,n>>>t,this.unsigned)}else if(t===32)return fromBits(n,0,this.unsigned);else return fromBits(n>>>t-32,0,this.unsigned)}};LongPrototype.shru=LongPrototype.shiftRightUnsigned;LongPrototype.shr_u=LongPrototype.shiftRightUnsigned;LongPrototype.toSigned=function e(){if(!this.unsigned)return this;return fromBits(this.low,this.high,false)};LongPrototype.toUnsigned=function e(){if(this.unsigned)return this;return fromBits(this.low,this.high,true)};LongPrototype.toBytes=function e(t){return t?this.toBytesLE():this.toBytesBE()};LongPrototype.toBytesLE=function e(){var t=this.high,n=this.low;return [n&255,n>>>8&255,n>>>16&255,n>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};LongPrototype.toBytesBE=function e(){var t=this.high,n=this.low;return [t>>>24,t>>>16&255,t>>>8&255,t&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};Long$1.fromBytes=function e(t,n,r){return r?Long$1.fromBytesLE(t,n):Long$1.fromBytesBE(t,n)};Long$1.fromBytesLE=function e(t,n){return new Long$1(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,n)};Long$1.fromBytesBE=function e(t,n){return new Long$1(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],n)};var LongExports=_mergeNamespaces({__proto__:null,default:long},[long]);
const Long=long||LongExports;function hexToLong(e){return Long.fromString(e,true,16)}hexToLong("c3a5c85c97cb3127");hexToLong("b492b66fbe98f273");hexToLong("9ae16a3b2f90404f");function createScalarValue(e,t){if(t==="string"){return encodeString(e)}return toTypedArray([e],t)}function noConversionNeeded(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function toTypedArray(e,t){if(t==="string"){throw new Error("Cannot convert a string[] to a TypedArray")}if(Array.isArray(e)){e=flatten(e);}if(env().getBool("DEBUG")){checkConversionForErrors(e,t);}if(noConversionNeeded(e,t)){return e}if(t==null||t==="float32"||t==="complex64"){return new Float32Array(e)}else if(t==="int32"){return new Int32Array(e)}else if(t==="bool"){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n){if(Math.round(e[n])!==0){t[n]=1;}}return t}else {throw new Error(`Unknown data type ${t}`)}}function now(){return env().platform.now()}
class Profiler{constructor(e,t){this.backendTimer=e;this.logger=t;if(t==null){this.logger=new Logger;}}profileKernel(e,t,n){let r;const s=()=>{r=n();};let a;const o=now();if(this.backendTimer.timerAvailable()){a=this.backendTimer.time(s);}else {s();for(const e of r){e.dataSync();}a=Promise.resolve({kernelMs:now()-o});}if(env().getBool("CHECK_COMPUTATION_FOR_ERRORS")){for(let t=0;t<r.length;t++){const n=r[t];n.data().then((t=>{checkComputationForErrors(t,n.dtype,e);}));}}const i={kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>e.getExtraProfileInfo!=null?e.getExtraProfileInfo():""))};return i}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach((e=>{Promise.all([e.data(),r,a]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2]);}));}));}}class Logger{logKernelProfile(e,t,n,r,s,a){const o=typeof r==="number"?rightPad(`${r}ms`,9):r["error"];const i=rightPad(e,25);const c=t.rank;const u=t.size;const l=rightPad(t.shape.toString(),14);let p="";for(const e in s){const n=s[e];if(n!=null){const r=n.shape||t.shape;const s=r.length;p+=`${e}: ${s}D ${s>0?r:""} `;}}console.log(`%c${i}\t%c${o}\t%c${c}D ${l}\t%c${u}\t%c${p}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue");}}
function getFilteredNodesXToY(e,t,n){const r={};const s={};for(let e=0;e<t.length;e++){r[t[e].id]=true;}for(let n=0;n<e.length;n++){const a=e[n];const o=a.inputs;for(const e in o){const n=o[e];let i=false;for(let e=0;e<t.length;e++){if(r[n.id]){a.outputs.forEach((e=>r[e.id]=true));i=true;s[a.id]=true;break}}if(i){break}}}const a={};a[n.id]=true;const o={};for(let t=e.length-1;t>=0;t--){const n=e[t];const r=n.inputs;for(let e=0;e<n.outputs.length;e++){if(a[n.outputs[e].id]){for(const e in r){a[r[e].id]=true;o[n.id]=true;}break}}}const i=[];for(let t=0;t<e.length;t++){const n=e[t];if(s[n.id]&&o[n.id]){const e={};for(const t in n.inputs){const s=n.inputs[t];if(r[s.id]){e[t]=s;}}const t=Object.assign({},n);t.inputs=e;t.outputs=n.outputs;i.push(t);}}return i}
class TensorBuffer{constructor(e,t,n){this.dtype=t;this.shape=e.slice();this.size=sizeFromShape(e);if(n!=null){const e=n.length;assert(e===this.size,(()=>`Length of values '${e}' does not match the size `+`inferred by the shape '${this.size}'.`));}if(t==="complex64"){throw new Error(`complex64 dtype TensorBuffers are not supported. Please create `+`a TensorBuffer for the real and imaginary parts separately and `+`call tf.complex(real, imag).`)}this.values=n||getArrayFromDType(t,this.size);this.strides=computeStrides(e);}set(e,...t){if(t.length===0){t=[0];}assert(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must `+`match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e;}get(...e){if(e.length===0){e=[0];}let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}. `+`  Buffer shape=${this.shape}`;throw new Error(t)}t++;}let n=e[e.length-1];for(let t=0;t<e.length-1;++t){n+=this.strides[t]*e[t];}return this.values[n]}locToIndex(e){if(this.rank===0){return 0}else if(this.rank===1){return e[0]}let t=e[e.length-1];for(let n=0;n<e.length-1;++n){t+=this.strides[n]*e[n];}return t}indexToLoc(e){if(this.rank===0){return []}else if(this.rank===1){return [e]}const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n){t[n]=Math.floor(e/this.strides[n]);e-=t[n]*this.strides[n];}t[t.length-1]=e;return t}get rank(){return this.shape.length}toTensor(){return trackerFn().makeTensor(this.values,this.shape,this.dtype)}}let trackerFn=null;let opHandler$1=null;function setTensorTracker(e){trackerFn=e;}function setOpHandler(e){opHandler$1=e;}class Tensor{constructor(e,t,n,r){this.kept=false;this.isDisposedInternal=false;this.shape=e.slice();this.dtype=t||"float32";this.size=sizeFromShape(e);this.strides=computeStrides(e);this.dataId=n;this.id=r;this.rankType=this.rank<5?this.rank.toString():"higher";}get rank(){return this.shape.length}async buffer(){const e=await this.data();return opHandler$1.buffer(this.shape,this.dtype,e)}bufferSync(){return opHandler$1.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return toNestedArray(this.shape,e,this.dtype==="complex64")}arraySync(){return toNestedArray(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=trackerFn().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map((e=>decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. "+"To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){this.throwIfDisposed();return trackerFn().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=trackerFn().readSync(this.dataId);if(this.dtype==="string"){try{return e.map((e=>decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. "+"To get the original bytes, call tensor.bytes().")}}return e}async bytes(){this.throwIfDisposed();const e=await trackerFn().read(this.dataId);if(this.dtype==="string"){return e}else {return new Uint8Array(e.buffer)}}dispose(){if(this.isDisposed){return}trackerFn().disposeTensor(this);this.isDisposedInternal=true;}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed){throw new Error(`Tensor is disposed.`)}}print(e=false){return opHandler$1.print(this,e)}clone(){this.throwIfDisposed();return opHandler$1.clone(this)}toString(e=false){const t=this.dataSync();return tensorToString(t,this.shape,this.dtype,e)}cast(e){this.throwIfDisposed();return opHandler$1.cast(this,e)}variable(e=true,t,n){this.throwIfDisposed();return trackerFn().makeVariable(this,e,t,n)}}Object.defineProperty(Tensor,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function getGlobalTensorClass(){return getGlobal("Tensor",(()=>Tensor))}getGlobalTensorClass();class Variable extends Tensor{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r);this.trainable=t;this.name=n;}assign(e){if(e.dtype!==this.dtype){throw new Error(`dtype of the new value (${e.dtype}) and `+`previous value (${this.dtype}) must match`)}if(!arraysEqual(e.shape,this.shape)){throw new Error(`shape of the new value (${e.shape}) and `+`previous value (${this.shape}) must match`)}trackerFn().disposeTensor(this);this.dataId=e.dataId;trackerFn().incRef(this,null);}dispose(){trackerFn().disposeVariable(this);this.isDisposedInternal=true;}}Object.defineProperty(Variable,Symbol.hasInstance,{value:e=>e instanceof Tensor&&e.assign!=null&&e.assign instanceof Function});
var Rank;(function(e){e["R0"]="R0";e["R1"]="R1";e["R2"]="R2";e["R3"]="R3";e["R4"]="R4";e["R5"]="R5";e["R6"]="R6";})(Rank||(Rank={}));var UpcastInt32AndMap;(function(e){e["float32"]="float32";e["int32"]="int32";e["bool"]="int32";e["complex64"]="complex64";})(UpcastInt32AndMap||(UpcastInt32AndMap={}));var UpcastBoolAndMap;(function(e){e["float32"]="float32";e["int32"]="int32";e["bool"]="bool";e["complex64"]="complex64";})(UpcastBoolAndMap||(UpcastBoolAndMap={}));var UpcastFloat32AndMap;(function(e){e["float32"]="float32";e["int32"]="float32";e["bool"]="float32";e["complex64"]="complex64";})(UpcastFloat32AndMap||(UpcastFloat32AndMap={}));var UpcastComplex64AndMap;(function(e){e["float32"]="complex64";e["int32"]="complex64";e["bool"]="complex64";e["complex64"]="complex64";})(UpcastComplex64AndMap||(UpcastComplex64AndMap={}));const upcastTypeMap={float32:UpcastFloat32AndMap,int32:UpcastInt32AndMap,bool:UpcastBoolAndMap,complex64:UpcastComplex64AndMap};function upcastType(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string"){return "string"}throw new Error(`Can not upcast ${e} with ${t}`)}return upcastTypeMap[e][t]}function sumOutType(e){return upcastType(e,"int32")}
function makeTypesMatch(e,t){if(e.dtype===t.dtype){return [e,t]}const n=upcastType(e.dtype,t.dtype);return [e.cast(n),t.cast(n)]}function getTensorsInContainer(e){const t=[];const n=new Set;walkTensorContainer(e,t,n);return t}function walkTensorContainer(e,t,n){if(e==null){return}if(e instanceof Tensor){t.push(e);return}if(!isIterable(e)){return}const r=e;for(const e in r){const s=r[e];if(!n.has(s)){n.add(s);walkTensorContainer(s,t,n);}}}function isIterable(e){return Array.isArray(e)||typeof e==="object"}
function isRegisteredKernelInvocation(e){return e.kernelName!=null}class EngineState{constructor(){this.registeredVariables={};this.nextTapeNodeId=0;this.numBytes=0;this.numTensors=0;this.numStringTensors=0;this.numDataBuffers=0;this.gradientDepth=0;this.kernelDepth=0;this.scopeStack=[];this.numDataMovesStack=[];this.nextScopeId=0;this.tensorInfo=new WeakMap;this.profiling=false;this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}};}dispose(){for(const e in this.registeredVariables){this.registeredVariables[e].dispose();}}}class Engine{constructor(e){this.ENV=e;this.registry={};this.registryFactory={};this.pendingBackendInitId=0;this.state=new EngineState;}async ready(){if(this.pendingBackendInit!=null){return this.pendingBackendInit.then((()=>{}))}if(this.backendInstance!=null){return}const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];const r=await this.initializeBackend(n).success;if(r){await this.setBackend(n);return}}throw new Error(`Could not initialize any backends, all backend initializations `+`failed.`)}get backend(){if(this.pendingBackendInit!=null){throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make `+`sure to await tf.ready() or await tf.setBackend() before calling `+`other methods`)}if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t){throw new Error(`The highest priority backend '${e}' has not yet been `+`initialized. Make sure to await tf.ready() or `+`await tf.setBackend() before calling other methods`)}this.setBackend(e);}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t){return null}}else {return null}}return this.registry[e]}findBackendFactory(e){if(!(e in this.registryFactory)){return null}return this.registryFactory[e].factory}registerBackend(e,t,n=1){if(e in this.registryFactory){warn(`${e} backend was already registered. `+`Reusing existing backend factory.`);return false}this.registryFactory[e]={factory:t,priority:n};return true}async setBackend(e){if(this.registryFactory[e]==null){throw new Error(`Backend name '${e}' not found in registry`)}this.backendName=e;if(this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);const r=n?await t:t;if(!r){return false}}this.backendInstance=this.registry[e];this.setupRegisteredKernels();this.profiler=new Profiler(this.backendInstance);return true}setupRegisteredKernels(){const e=getKernelsForBackend(this.backendName);e.forEach((e=>{if(e.setupFunc!=null){e.setupFunc(this.backendInstance);}}));}disposeRegisteredKernels(e){const t=getKernelsForBackend(e);t.forEach((t=>{if(t.disposeFunc!=null){t.disposeFunc(this.registry[e]);}}));}initializeBackend(e){const t=this.registryFactory[e];if(t==null){throw new Error(`Cannot initialize backend ${e}, no registration found.`)}try{const n=t.factory();if(n&&!(n instanceof KernelBackend)&&typeof n.then==="function"){const t=++this.pendingBackendInitId;const r=n.then((n=>{if(t<this.pendingBackendInitId){return false}this.registry[e]=n;this.pendingBackendInit=null;return true})).catch((n=>{if(t<this.pendingBackendInitId){return false}this.pendingBackendInit=null;warn(`Initialization of backend ${e} failed`);warn(n.stack||n.message);return false}));this.pendingBackendInit=r;return {success:r,asyncInit:true}}else {this.registry[e]=n;return {success:true,asyncInit:false}}}catch(t){warn(`Initialization of backend ${e} failed`);warn(t.stack||t.message);return {success:false,asyncInit:false}}}removeBackend(e){if(!(e in this.registryFactory)){throw new Error(`${e} backend not found in registry`)}if(this.backendName===e&&this.pendingBackendInit!=null){this.pendingBackendInitId++;}if(e in this.registry){this.disposeRegisteredKernels(e);this.registry[e].dispose();delete this.registry[e];}delete this.registryFactory[e];if(this.backendName===e){this.pendingBackendInit=null;this.backendName=null;this.backendInstance=null;}}getSortedBackends(){if(Object.keys(this.registryFactory).length===0){throw new Error("No backend found in registry.")}return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];const{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r){return {name:n,asyncInit:s}}}throw new Error(`Could not initialize any backends, all backend initializations `+`failed.`)}moveData(e,t){const n=this.state.tensorInfo.get(t);const r=n.backend;const s=this.readSync(t);const a=r.refCount(t);r.disposeData(t,true);n.backend=e;e.move(t,s,n.shape,n.dtype,a);if(this.shouldCheckForMemLeaks()){this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++;}}tidy(e,t){let n=null;if(t==null){if(typeof e!=="function"){throw new Error("Please provide a function to tidy()")}t=e;}else {if(typeof e!=="string"&&!(e instanceof String)){throw new Error("When calling with two arguments, the first argument "+"to tidy() must be a string")}if(typeof t!=="function"){throw new Error("When calling with two arguments, the 2nd argument "+"to tidy() must be a function")}n=e;}let r;return this.scopedRun((()=>this.startScope(n)),(()=>this.endScope(r)),(()=>{r=t();if(r instanceof Promise){console.error("Cannot return a Promise inside of tidy.");}return r}))}scopedRun(e,t,n){e();try{const e=n();t();return e}catch(e){t();throw e}}nextTensorId(){return Engine.nextTensorId++}nextVariableId(){return Engine.nextVariableId++}clone(e){const t=ENGINE.runKernel(Identity,{x:e});const n={x:e};const r=e=>({x:()=>{const t="float32";const n={x:e};const r={dtype:t};return ENGINE.runKernel(Cast,n,r)}});const s=[];this.addTapeNode(this.state.activeScope.name,n,[t],r,s,{});return t}runKernel(e,t,n){if(this.backendName==null){this.backend;}const r=getKernel(e,this.backendName)!=null;if(!r){throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`)}return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach((e=>{s+=e.dtype==="complex64"?3:1;}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];const o=r-t-s-a;if(o>0){throw new Error(`Backend '${this.backendName}' has an internal memory leak `+`(${o} data ids) after running '${e}'`)}}runKernelFunc(e){let t;let n=[];const r=this.isTapeOn();const s=this.state.numBytes;const a=this.state.numTensors;if(this.shouldCheckForMemLeaks()){this.state.numDataMovesStack.push(0);}let o;if(this.backendName==null){this.backend;}let i;const c=isRegisteredKernelInvocation(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(isRegisteredKernelInvocation(e)){const{kernelName:t,inputs:s,attrs:a}=e;if(this.backendName==null){this.backend;}const c=getKernel(t,this.backendName);assert(c!=null,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`));o=()=>{const e=this.backend.numDataIds();i=c.kernelFunc({inputs:s,attrs:a,backend:this.backend});const o=Array.isArray(i)?i:[i];if(this.shouldCheckForMemLeaks()){this.checkKernelForMemLeak(t,e,o);}const u=o.map((e=>{if(e.rank!=null){return e}return this.makeTensorFromTensorInfo(e)}));if(r){const e=this.getTensorsForGradient(t,s,u);n=this.saveTensorsForBackwardMode(e);}return u};}else {const{forwardFunc:t}=e;const s=e=>{if(!r){return}n=e.map((e=>this.keep(this.clone(e))));};o=()=>{const e=this.backend.numDataIds();i=this.tidy((()=>t(this.backend,s)));const n=Array.isArray(i)?i:[i];if(this.shouldCheckForMemLeaks()){this.checkKernelForMemLeak(c,e,n);}return n};}const{inputs:u,attrs:l}=e;const p=isRegisteredKernelInvocation(e)?null:e.backwardsFunc;let d;this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{if(!this.ENV.getBool("DEBUG")&&!this.state.profiling){t=o();}else {d=this.profiler.profileKernel(c,u,(()=>o()));if(this.ENV.getBool("DEBUG")){this.profiler.logKernelProfile(d);}t=d.outputs;}}));if(r){this.addTapeNode(c,u,t,p,n,l);}if(this.state.profiling){this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((e=>u[e]!=null?u[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo});}return Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=getGradient(e);if(r!=null){const e=r.inputsToSave||[];const s=r.outputsToSave||[];let a;if(r.saveAllInputs){assert(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array."));a=Object.keys(t).map((e=>t[e]));}else {a=e.map((e=>t[e]));}const o=n.filter(((e,t)=>s[t]));return a.concat(o)}return []}makeTensor(e,t,n,r){if(e==null){throw new Error("Values passed to engine.makeTensor() are null")}n=n||"float32";r=r||this.backend;let s=e;if(n==="string"&&isString(e[0])){s=e.map((e=>encodeString(e)));}const a=r.write(s,t,n);const o=new Tensor(t,n,a,this.nextTensorId());this.trackTensor(o,r);if(n==="string"){const e=this.state.tensorInfo.get(a);const t=bytesFromStringArray(s);this.state.numBytes+=t-e.bytes;e.bytes=t;}return o}makeTensorFromDataId(e,t,n,r){n=n||"float32";const s={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:s}=e;const a=new Tensor(r,s,n,this.nextTensorId());this.trackTensor(a,t);return a}makeVariable(e,t=true,n,r){n=n||this.nextVariableId().toString();if(r!=null&&r!==e.dtype){e=e.cast(r);}const s=new Variable(e,t,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null){throw new Error(`Variable with name ${s.name} was already registered`)}this.state.registeredVariables[s.name]=s;this.incRef(s,this.backend);return s}trackTensor(e,t){this.state.numTensors++;if(e.dtype==="string"){this.state.numStringTensors++;}let n=0;if(e.dtype!=="complex64"&&e.dtype!=="string"){n=e.size*bytesPerElement(e.dtype);}this.state.numBytes+=n;if(!this.state.tensorInfo.has(e.dataId)){this.state.numDataBuffers++;this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n});}if(!(e instanceof Variable)){this.track(e);}}incRef(e,t){this.trackTensor(e,t);this.backend.incRef(e.dataId);}removeDataId(e,t){if(this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t){this.state.tensorInfo.delete(e);this.state.numDataBuffers--;}}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId)){return}const t=this.state.tensorInfo.get(e.dataId);this.state.numTensors--;if(e.dtype==="string"){this.state.numStringTensors--;this.state.numBytes-=t.bytes;}if(e.dtype!=="complex64"&&e.dtype!=="string"){const t=e.size*bytesPerElement(e.dtype);this.state.numBytes-=t;}if(t.backend.disposeData(e.dataId)){this.removeDataId(e.dataId,t.backend);}}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t);}}disposeVariable(e){this.disposeTensor(e);if(this.state.registeredVariables[e.name]!=null){delete this.state.registeredVariables[e.name];}}memory(){const e=this.backend.memory();e.numTensors=this.state.numTensors;e.numDataBuffers=this.state.numDataBuffers;e.numBytes=this.state.numBytes;if(this.state.numStringTensors>0){e.unreliable=true;if(e.reasons==null){e.reasons=[];}e.reasons.push("Memory usage by string tensors is approximate "+"(2 bytes per character)");}return e}async profile(e){this.state.profiling=true;const t=this.state.numBytes;const n=this.state.numTensors;this.state.activeProfile.kernels=[];this.state.activeProfile.result=await e();this.state.profiling=false;this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot)));this.state.activeProfile.newBytes=this.state.numBytes-t;this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels){e.kernelTimeMs=await e.kernelTimeMs;e.extraInfo=await e.extraInfo;}return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,r,s,a){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s};const i=getGradient(e);if(i!=null){r=i.gradFunc;}if(r!=null){o.gradient=e=>{e=e.map(((e,t)=>{if(e==null){const e=n[t];const r=makeZerosTypedArray(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e}));return r(e.length>1?e:e[0],s,a)};}this.state.activeTape.push(o);}keep(e){e.kept=true;return e}startTape(){if(this.state.gradientDepth===0){this.state.activeTape=[];}this.state.gradientDepth++;}endTape(){this.state.gradientDepth--;}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};if(e){t.name=e;}this.state.scopeStack.push(t);this.state.activeScope=t;}endScope(e){const t=getTensorsInContainer(e);const n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];if(!t.kept&&!n.has(t.id)){t.dispose();}}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1];t.forEach((e=>{if(!e.kept&&e.scopeId===r.id){this.track(e);}}));}gradients(e,t,n,r=false){assert(t.length>0,(()=>"gradients() received an empty list of xs."));if(n!=null&&n.dtype!=="float32"){throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`)}const s=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));assert(s instanceof Tensor,(()=>"The result y returned by f() must be a tensor."));const a=getFilteredNodesXToY(this.state.activeTape,t,s);if(!r&&a.length===0&&t.length>0){throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure "+"that the f you passed encloses all operations that lead from x "+"to y.")}return this.tidy("backward",(()=>{const e={};e[s.id]=n==null?ones$1(s.shape):n;backpropagateGradients(e,a,(e=>this.tidy(e)),add$1);const r=t.map((t=>e[t.id]));if(this.state.gradientDepth===0){this.state.activeTape.forEach((e=>{for(const t of e.saved){t.dispose();}}));this.state.activeTape=null;}return {value:s,grads:r}}))}customGrad(e){assert(isFunction(e),(()=>"The f passed in customGrad(f) must be a function."));return (...t)=>{assert(t.every((e=>e instanceof Tensor)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be "+"tensors"));let n;const r={};t.forEach(((e,t)=>{r[t]=e;}));const s=(r,s)=>{n=e(...[...t,s]);assert(n.value instanceof Tensor,(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.value` is a tensor"));assert(isFunction(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.gradFunc` is a function."));return n.value};const a=(e,r)=>{const s=n.gradFunc(e,r);const a=Array.isArray(s)?s:[s];assert(a.length===t.length,(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.gradFunc` is a function that returns "+"the same number of tensors as inputs passed to f(...)."));assert(a.every((e=>e instanceof Tensor)),(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.gradFunc` is a function that returns "+"a list of only tensors."));const o={};a.forEach(((e,t)=>{o[t]=()=>e;}));return o};return this.runKernelFunc({forwardFunc:s,backwardsFunc:a,inputs:r})}}readSync(e){const t=this.state.tensorInfo.get(e);return t.backend.readSync(e)}read(e){const t=this.state.tensorInfo.get(e);return t.backend.read(e)}readToGPU(e,t){const n=this.state.tensorInfo.get(e);return n.backend.readToGPU(e,t)}async time(e){const t=now();const n=await this.backend.time(e);n.wallMs=now()-t;return n}track(e){if(this.state.activeScope!=null){e.scopeId=this.state.activeScope.id;this.state.activeScope.track.push(e);}return e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++;this.state.dispose();this.ENV.reset();this.state=new EngineState;for(const e in this.registry){this.disposeRegisteredKernels(e);this.registry[e].dispose();delete this.registry[e];}this.backendName=null;this.backendInstance=null;this.pendingBackendInit=null;}}Engine.nextTensorId=0;Engine.nextVariableId=0;function ones$1(e){const t=makeOnesTypedArray(sizeFromShape(e),"float32");return ENGINE.makeTensor(t,e,"float32")}function getOrMakeEngine(){const e=getGlobalNamespace();if(e._tfengine==null){const t=new Environment(e);e._tfengine=new Engine(t);}setEnvironmentGlobal(e._tfengine.ENV);setTensorTracker((()=>e._tfengine));return e._tfengine}const ENGINE=getOrMakeEngine();function add$1(e,t){const n={a:e,b:t};return ENGINE.runKernel(Add,n)}
function _isNavigatorDefined(){return typeof navigator!=="undefined"&&navigator!=null}function isMobile(e){if(e||_isNavigatorDefined()){if(!e){e=navigator;}if(e.product==="ReactNative"){return true}const t=e.userAgent||e.vendor||(typeof window!=="undefined"?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return false}function isBrowser(){return typeof window!=="undefined"&&window.document!=null||typeof WorkerGlobalScope!=="undefined"}
const ENV$2=env();ENV$2.registerFlag("DEBUG",(()=>false),(e=>{if(e){console.warn("Debugging mode is ON. The output of every math call will "+"be downloaded to CPU and checked for NaNs. "+"This significantly impacts performance.");}}));ENV$2.registerFlag("IS_BROWSER",(()=>isBrowser()));ENV$2.registerFlag("IS_NODE",(()=>typeof process!=="undefined"&&typeof process.versions!=="undefined"&&typeof process.versions.node!=="undefined"));ENV$2.registerFlag("IS_CHROME",(()=>typeof navigator!=="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)));ENV$2.registerFlag("PROD",(()=>false));ENV$2.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>ENV$2.getBool("DEBUG")));ENV$2.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>true));ENV$2.registerFlag("IS_TEST",(()=>false));ENV$2.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>true));ENV$2.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>false));ENV$2.registerFlag("ENGINE_COMPILE_ONLY",(()=>false));
function inferShape(e,t){let n=e;if(isTypedArray(e)){return t==="string"?[]:[e.length]}if(!Array.isArray(e)){return []}const r=[];while(Array.isArray(n)||isTypedArray(n)&&t!=="string"){r.push(n.length);n=n[0];}if(Array.isArray(e)&&env().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")){deepAssertShapeConsistency(e,r,[]);}return r}function assertDtype(e,t,n,r){if(e==="string_or_numeric"){return}if(e==null){throw new Error(`Expected dtype cannot be null.`)}if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string"){throw new Error(`Argument '${n}' passed to '${r}' must `+`be ${e} tensor, but got ${t} tensor`)}}function convertToTensor(e,t,n,r="numeric"){if(e instanceof Tensor){assertDtype(r,e.dtype,t,n);return e}let s=inferDtype(e);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0){s=r;}assertDtype(r,s,t,n);if(e==null||!isTypedArray(e)&&!Array.isArray(e)&&typeof e!=="number"&&typeof e!=="boolean"&&typeof e!=="string"){const r=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a `+`Tensor or TensorLike, but got '${r}'`)}const a=inferShape(e,s);if(!isTypedArray(e)&&!Array.isArray(e)){e=[e];}const o=true;const i=s!=="string"?toTypedArray(e,s):flatten(e,[],o);return ENGINE.makeTensor(i,a,s)}function convertToTensorArray(e,t,n,r="numeric"){if(!Array.isArray(e)){throw new Error(`Argument ${t} passed to ${n} must be a `+"`Tensor[]` or `TensorLike[]`")}const s=e;return s.map(((e,s)=>convertToTensor(e,`${t}[${s}]`,n,r)))}
const OP_SCOPE_SUFFIX="__op";function op(e){const t=Object.keys(e);if(t.length!==1){throw new Error(`Please provide an object with a single key `+`(operation name) mapping to a function. Got an object with `+`${t.length} keys.`)}let n=t[0];const r=e[n];if(n.endsWith("_")){n=n.substring(0,n.length-1);}n=n+OP_SCOPE_SUFFIX;const s=(...e)=>{ENGINE.startScope(n);try{const t=r(...e);if(isPromise(t)){console.error("Cannot return a Promise inside of tidy.");}ENGINE.endScope(t);return t}catch(e){ENGINE.endScope(null);throw e}};Object.defineProperty(s,"name",{value:n,configurable:true});return s}
function complex_(e,t){const n=convertToTensor(e,"real","complex");const r=convertToTensor(t,"imag","complex");assertShapesMatch(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, `+`must match in call to tf.complex().`);const s={real:n,imag:r};return ENGINE.runKernel(Complex,s)}const complex$1=op({complex_:complex_});
function makeTensor(e,t,n,r){if(r==null){r=inferDtype(e);}if(r==="complex64"){throw new Error(`Cannot construct a complex64 tensor directly. `+`Please use tf.complex(real, imag).`)}if(!isTypedArray(e)&&!Array.isArray(e)&&typeof e!=="number"&&typeof e!=="boolean"&&typeof e!=="string"){throw new Error("values passed to tensor(values) must be a number/boolean/string or "+"an array of numbers/booleans/strings, or a TypedArray")}if(t!=null){assertNonNegativeIntegerDimensions(t);const e=sizeFromShape(t);const r=sizeFromShape(n);assert(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have `+`${e} values but has ${r}`));for(let e=0;e<n.length;++e){const r=n[e];const s=e===n.length-1?r!==sizeFromShape(t.slice(e)):true;assert(n[e]===t[e]||!s,(()=>`Error creating a new Tensor. Inferred shape `+`(${n}) does not match the provided `+`shape (${t}). `));}}if(!isTypedArray(e)&&!Array.isArray(e)){e=[e];}t=t||n;e=r!=="string"?toTypedArray(e,r):flatten(e,[],true);return ENGINE.makeTensor(e,t,r)}
function tensor(e,t,n){const r=inferShape(e,n);return makeTensor(e,t,r,n)}
const DTYPE_VALUE_SIZE_MAP={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};
const NUM_BYTES_STRING_LENGTH=4;function decodeWeights(e,t){const n={};let r;let s=0;for(const a of t){const t=a.name;const o=a.dtype;const i=a.shape;const c=sizeFromShape(i);let u;if("quantization"in a){const n=a.quantization;if(n.dtype==="uint8"||n.dtype==="uint16"){if(!("min"in n&&"scale"in n)){throw new Error(`Weight ${a.name} with quantization ${n.dtype} `+`doesn't have corresponding metadata min and scale.`)}}else if(n.dtype==="float16"){if(o!=="float32"){throw new Error(`Weight ${a.name} is quantized with ${n.dtype} `+`which only supports weights of type float32 not ${o}.`)}}else {throw new Error(`Weight ${a.name} has unknown `+`quantization dtype ${n.dtype}. `+`Supported quantization dtypes are: `+`'uint8', 'uint16', and 'float16'.`)}const i=DTYPE_VALUE_SIZE_MAP[n.dtype];const l=e.slice(s,s+c*i);const p=n.dtype==="uint8"?new Uint8Array(l):new Uint16Array(l);if(o==="float32"){if(n.dtype==="uint8"||n.dtype==="uint16"){u=new Float32Array(p.length);for(let e=0;e<p.length;e++){const t=p[e];u[e]=t*n.scale+n.min;}}else if(n.dtype==="float16"){if(r===undefined){r=getFloat16Decoder();}u=r(p);}else {throw new Error(`Unsupported quantization type ${n.dtype} `+`for weight type float32.`)}}else if(o==="int32"){if(n.dtype!=="uint8"&&n.dtype!=="uint16"){throw new Error(`Unsupported quantization type ${n.dtype} `+`for weight type int32.`)}u=new Int32Array(p.length);for(let e=0;e<p.length;e++){const t=p[e];u[e]=Math.round(t*n.scale+n.min);}}else {throw new Error(`Unsupported dtype in weight '${t}': ${o}`)}s+=c*i;}else if(o==="string"){const t=sizeFromShape(a.shape);u=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(s,s+NUM_BYTES_STRING_LENGTH))[0];s+=NUM_BYTES_STRING_LENGTH;const n=new Uint8Array(e.slice(s,s+t));u.push(n);s+=t;}}else {const r=DTYPE_VALUE_SIZE_MAP[o];const a=e.slice(s,s+c*r);if(o==="float32"){u=new Float32Array(a);}else if(o==="int32"){u=new Int32Array(a);}else if(o==="bool"){u=new Uint8Array(a);}else if(o==="complex64"){u=new Float32Array(a);const e=new Float32Array(u.length/2);const r=new Float32Array(u.length/2);for(let t=0;t<e.length;t++){e[t]=u[t*2];r[t]=u[t*2+1];}const s=tensor(e,i,"float32");const o=tensor(r,i,"float32");n[t]=complex$1(s,o);s.dispose();o.dispose();}else {throw new Error(`Unsupported dtype in weight '${t}': ${o}`)}s+=c*r;}if(o!=="complex64"){n[t]=tensor(u,i,o);}}return n}function getModelJSONForModelArtifacts(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};if(e.signature!=null){n.signature=e.signature;}if(e.userDefinedMetadata!=null){n.userDefinedMetadata=e.userDefinedMetadata;}if(e.modelInitializer!=null){n.modelInitializer=e.modelInitializer;}if(e.trainingConfig!=null){n.trainingConfig=e.trainingConfig;}return n}async function getModelArtifactsForJSON(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null){n.trainingConfig=e.trainingConfig;}if(e.weightsManifest!=null){const[r,s]=await t(e.weightsManifest);n.weightSpecs=r;n.weightData=s;}if(e.signature!=null){n.signature=e.signature;}if(e.userDefinedMetadata!=null){n.userDefinedMetadata=e.userDefinedMetadata;}if(e.modelInitializer!=null){n.modelInitializer=e.modelInitializer;}return n}function getModelArtifactsInfoForJSON(e){if(e.modelTopology instanceof ArrayBuffer){throw new Error("Expected JSON model topology, received ArrayBuffer.")}return {dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:stringByteLength(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:stringByteLength(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:e.weightData.byteLength}}class IORouterRegistry{constructor(){this.saveRouters=[];this.loadRouters=[];}static getInstance(){if(IORouterRegistry.instance==null){IORouterRegistry.instance=new IORouterRegistry;}return IORouterRegistry.instance}static registerSaveRouter(e){IORouterRegistry.getInstance().saveRouters.push(e);}static registerLoadRouter(e){IORouterRegistry.getInstance().loadRouters.push(e);}static getSaveHandlers(e){return IORouterRegistry.getHandlers(e,"save")}static getLoadHandlers(e,t){return IORouterRegistry.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];const s=t==="load"?IORouterRegistry.getInstance().loadRouters:IORouterRegistry.getInstance().saveRouters;s.forEach((t=>{const s=t(e,n);if(s!==null){r.push(s);}}));return r}}const registerSaveRouter=e=>IORouterRegistry.registerSaveRouter(e);const registerLoadRouter=e=>IORouterRegistry.registerLoadRouter(e);const getSaveHandlers=e=>IORouterRegistry.getSaveHandlers(e);const getLoadHandlers=(e,t)=>IORouterRegistry.getLoadHandlers(e,t)
;const DATABASE_NAME$1="tensorflowjs";const DATABASE_VERSION=1;const MODEL_STORE_NAME="models_store";const INFO_STORE_NAME="model_info_store";class BrowserIndexedDB{constructor(e){this.indexedDB=getIndexedDBFactory();if(e==null||!e){throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.")}this.modelPath=e;}async save(e){if(e.modelTopology instanceof ArrayBuffer){throw new Error("BrowserLocalStorage.save() does not support saving model topology "+"in binary formats yet.")}return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(DATABASE_NAME$1,DATABASE_VERSION);r.onupgradeneeded=()=>setUpDatabase(r);r.onsuccess=()=>{const s=r.result;if(t==null){const t=s.transaction(MODEL_STORE_NAME,"readonly");const r=t.objectStore(MODEL_STORE_NAME);const a=r.get(this.modelPath);a.onsuccess=()=>{if(a.result==null){s.close();return n(new Error(`Cannot find model with path '${this.modelPath}' `+`in IndexedDB.`))}else {e(a.result.modelArtifacts);}};a.onerror=e=>{s.close();return n(a.error)};t.oncomplete=()=>s.close();}else {const r=getModelArtifactsInfoForJSON(t);const a=s.transaction(INFO_STORE_NAME,"readwrite");let o=a.objectStore(INFO_STORE_NAME);const i=o.put({modelPath:this.modelPath,modelArtifactsInfo:r});let c;i.onsuccess=()=>{c=s.transaction(MODEL_STORE_NAME,"readwrite");const i=c.objectStore(MODEL_STORE_NAME);const u=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r});u.onsuccess=()=>e({modelArtifactsInfo:r});u.onerror=e=>{o=a.objectStore(INFO_STORE_NAME);const t=o.delete(this.modelPath);t.onsuccess=()=>{s.close();return n(u.error)};t.onerror=e=>{s.close();return n(u.error)};};};i.onerror=e=>{s.close();return n(i.error)};a.oncomplete=()=>{if(c==null){s.close();}else {c.oncomplete=()=>s.close();}};}};r.onerror=e=>n(r.error);}))}}BrowserIndexedDB.URL_SCHEME="indexeddb://";const indexedDBRouter=e=>{if(!env().getBool("IS_BROWSER")){return null}else {if(!Array.isArray(e)&&e.startsWith(BrowserIndexedDB.URL_SCHEME)){return browserIndexedDB(e.slice(BrowserIndexedDB.URL_SCHEME.length))}else {return null}}};IORouterRegistry.registerSaveRouter(indexedDBRouter);IORouterRegistry.registerLoadRouter(indexedDBRouter);class BrowserIndexedDBManager{constructor(){this.indexedDB=getIndexedDBFactory();}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(DATABASE_NAME$1,DATABASE_VERSION);n.onupgradeneeded=()=>setUpDatabase(n);n.onsuccess=()=>{const r=n.result;const s=r.transaction(INFO_STORE_NAME,"readonly");const a=s.objectStore(INFO_STORE_NAME);const o=a.getAll();o.onsuccess=()=>{const t={};for(const e of o.result){t[e.modelPath]=e.modelArtifactsInfo;}e(t);};o.onerror=e=>{r.close();return t(o.error)};s.oncomplete=()=>r.close();};n.onerror=e=>t(n.error);}))}async removeModel(e){e=maybeStripScheme$1(e);return new Promise(((t,n)=>{const r=this.indexedDB.open(DATABASE_NAME$1,DATABASE_VERSION);r.onupgradeneeded=()=>setUpDatabase(r);r.onsuccess=()=>{const s=r.result;const a=s.transaction(INFO_STORE_NAME,"readwrite");const o=a.objectStore(INFO_STORE_NAME);const i=o.get(e);let c;i.onsuccess=()=>{if(i.result==null){s.close();return n(new Error(`Cannot find model with path '${e}' `+`in IndexedDB.`))}else {const r=o.delete(e);const a=()=>{c=s.transaction(MODEL_STORE_NAME,"readwrite");const r=c.objectStore(MODEL_STORE_NAME);const a=r.delete(e);a.onsuccess=()=>t(i.result.modelArtifactsInfo);a.onerror=e=>n(i.error);};r.onsuccess=a;r.onerror=e=>{a();s.close();return n(i.error)};}};i.onerror=e=>{s.close();return n(i.error)};a.oncomplete=()=>{if(c==null){s.close();}else {c.oncomplete=()=>s.close();}};};r.onerror=e=>n(r.error);}))}}
const PATH_SEPARATOR="/";const PATH_PREFIX="tensorflowjs_models";const INFO_SUFFIX="info";const MODEL_TOPOLOGY_SUFFIX="model_topology";const WEIGHT_SPECS_SUFFIX="weight_specs";const WEIGHT_DATA_SUFFIX="weight_data";const MODEL_METADATA_SUFFIX="model_metadata";function getModelKeys(e){return {info:[PATH_PREFIX,e,INFO_SUFFIX].join(PATH_SEPARATOR),topology:[PATH_PREFIX,e,MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),weightSpecs:[PATH_PREFIX,e,WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),weightData:[PATH_PREFIX,e,WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),modelMetadata:[PATH_PREFIX,e,MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)}}function removeItems(e){for(const t of Object.values(e)){window.localStorage.removeItem(t);}}function getModelPathFromKey(e){const t=e.split(PATH_SEPARATOR);if(t.length<3){throw new Error(`Invalid key format: ${e}`)}return t.slice(1,t.length-1).join(PATH_SEPARATOR)}class BrowserLocalStorage{constructor(e){if(!env().getBool("IS_BROWSER")||typeof window==="undefined"||typeof window.localStorage==="undefined"){throw new Error("The current environment does not support local storage.")}this.LS=window.localStorage;if(e==null||!e){throw new Error("For local storage, modelPath must not be null, undefined or empty.")}this.modelPath=e;this.keys=getModelKeys(this.modelPath);}async save(e){if(e.modelTopology instanceof ArrayBuffer){throw new Error("BrowserLocalStorage.save() does not support saving model topology "+"in binary formats yet.")}else {const t=JSON.stringify(e.modelTopology);const n=JSON.stringify(e.weightSpecs);const r=getModelArtifactsInfoForJSON(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r));this.LS.setItem(this.keys.topology,t);this.LS.setItem(this.keys.weightSpecs,n);this.LS.setItem(this.keys.weightData,arrayBufferToBase64String(e.weightData));const s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:undefined,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:undefined,modelInitializer:e.modelInitializer!=null?e.modelInitializer:undefined,trainingConfig:e.trainingConfig!=null?e.trainingConfig:undefined};this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s));return {modelArtifactsInfo:r}}catch(e){removeItems(this.keys);throw new Error(`Failed to save model '${this.modelPath}' to local storage: `+`size quota being exceeded is a possible cause of this failure: `+`modelTopologyBytes=${r.modelTopologyBytes}, `+`weightSpecsBytes=${r.weightSpecsBytes}, `+`weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null){throw new Error(`In local storage, there is no model with name '${this.modelPath}'`)}if(e.modelTopologyType!=="JSON"){throw new Error("BrowserLocalStorage does not support loading non-JSON model "+"topology yet.")}const t={};const n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null){throw new Error(`In local storage, the topology of model '${this.modelPath}' `+`is missing.`)}t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null){throw new Error(`In local storage, the weight specs of model '${this.modelPath}' `+`are missing.`)}t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){const e=JSON.parse(s);t.format=e.format;t.generatedBy=e.generatedBy;t.convertedBy=e.convertedBy;if(e.signature!=null){t.signature=e.signature;}if(e.userDefinedMetadata!=null){t.userDefinedMetadata=e.userDefinedMetadata;}if(e.modelInitializer!=null){t.modelInitializer=e.modelInitializer;}if(e.trainingConfig!=null){t.trainingConfig=e.trainingConfig;}}const a=this.LS.getItem(this.keys.weightData);if(a==null){throw new Error(`In local storage, the binary weight values of model `+`'${this.modelPath}' are missing.`)}t.weightData=base64StringToArrayBuffer(a);return t}}BrowserLocalStorage.URL_SCHEME="localstorage://";const localStorageRouter=e=>{if(!env().getBool("IS_BROWSER")){return null}else {if(!Array.isArray(e)&&e.startsWith(BrowserLocalStorage.URL_SCHEME)){return browserLocalStorage(e.slice(BrowserLocalStorage.URL_SCHEME.length))}else {return null}}};IORouterRegistry.registerSaveRouter(localStorageRouter);IORouterRegistry.registerLoadRouter(localStorageRouter);class BrowserLocalStorageManager{constructor(){assert(env().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser"));assert(typeof window==="undefined"||typeof window.localStorage!=="undefined",(()=>"Current browser does not appear to support localStorage"));this.LS=window.localStorage;}async listModels(){const e={};const t=PATH_PREFIX+PATH_SEPARATOR;const n=PATH_SEPARATOR+INFO_SUFFIX;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){const t=getModelPathFromKey(s);e[t]=JSON.parse(this.LS.getItem(s));}}return e}async removeModel(e){e=maybeStripScheme(e);const t=getModelKeys(e);if(this.LS.getItem(t.info)==null){throw new Error(`Cannot find model at path '${e}'`)}const n=JSON.parse(this.LS.getItem(t.info));removeItems(t);return n}}
const URL_SCHEME_SUFFIX="://";class ModelStoreManagerRegistry{constructor(){this.managers={};}static getInstance(){if(ModelStoreManagerRegistry.instance==null){ModelStoreManagerRegistry.instance=new ModelStoreManagerRegistry;}return ModelStoreManagerRegistry.instance}static registerManager(e,t){assert(e!=null,(()=>"scheme must not be undefined or null."));if(e.endsWith(URL_SCHEME_SUFFIX)){e=e.slice(0,e.indexOf(URL_SCHEME_SUFFIX));}assert(e.length>0,(()=>"scheme must not be an empty string."));const n=ModelStoreManagerRegistry.getInstance();assert(n.managers[e]==null,(()=>`A model store manager is already registered for scheme '${e}'.`));n.managers[e]=t;}static getManager(e){const t=ModelStoreManagerRegistry.getInstance().managers[e];if(t==null){throw new Error(`Cannot find model manager for scheme '${e}'`)}return t}static getSchemes(){return Object.keys(ModelStoreManagerRegistry.getInstance().managers)}}class PlatformBrowser{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8"){throw new Error(`Browser's encoder only supports utf-8, but got ${t}`)}if(this.textEncoder==null){this.textEncoder=new TextEncoder;}return this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(env().get("IS_BROWSER")){env().setPlatform("browser",new PlatformBrowser);try{ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME,new BrowserLocalStorageManager);}catch(e){}try{ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME,new BrowserIndexedDBManager);}catch(e){}}
function buffer(e,t="float32",n){t=t||"float32";assertNonNegativeIntegerDimensions(e);return new TensorBuffer(e,t,n)}
function cast_(e,t){const n=convertToTensor(e,"x","cast");if(!isValidDtype(t)){throw new Error(`Failed to cast to unknown dtype ${t}`)}if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string"){throw new Error("Only strings can be casted to strings")}const r={x:n};const s={dtype:t};return ENGINE.runKernel(Cast,r,s)}const cast$1=op({cast_:cast_});
function clone_(e){const t=convertToTensor(e,"x","clone","string_or_numeric");const n={x:t};return ENGINE.runKernel(Identity,n)}const clone=op({clone_:clone_});
function print(e,t=false){console.log(e.toString(t));}
getOrMakeEngine();const opHandler={buffer:buffer,cast:cast$1,clone:clone,print:print};setOpHandler(opHandler);
const DEFAULT_FILE_NAME_PREFIX="model";const DEFAULT_JSON_EXTENSION_NAME=".json";const DEFAULT_WEIGHT_DATA_EXTENSION_NAME=".weights.bin";class BrowserDownloads{constructor(e){if(!env().getBool("IS_BROWSER")){throw new Error("browserDownloads() cannot proceed because the current environment "+"is not a browser.")}if(e.startsWith(BrowserDownloads.URL_SCHEME)){e=e.slice(BrowserDownloads.URL_SCHEME.length);}if(e==null||e.length===0){e=DEFAULT_FILE_NAME_PREFIX;}this.modelJsonFileName=e+DEFAULT_JSON_EXTENSION_NAME;this.weightDataFileName=e+DEFAULT_WEIGHT_DATA_EXTENSION_NAME;}async save(e){if(typeof document==="undefined"){throw new Error("Browser downloads are not supported in "+"this environment since `document` is not present")}const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer){throw new Error("BrowserDownloads.save() does not support saving model topology "+"in binary formats yet.")}else {const n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}];const r=getModelJSONForModelArtifacts(e,n);const s=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"}));const a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;a.download=this.modelJsonFileName;a.href=s;await defer((()=>a.dispatchEvent(new MouseEvent("click"))));if(e.weightData!=null){const e=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName;e.href=t;await defer((()=>e.dispatchEvent(new MouseEvent("click"))));}return {modelArtifactsInfo:getModelArtifactsInfoForJSON(e)}}}}BrowserDownloads.URL_SCHEME="downloads://";const browserDownloadsRouter=e=>{if(!env().getBool("IS_BROWSER")){return null}else {if(!Array.isArray(e)&&e.startsWith(BrowserDownloads.URL_SCHEME)){return browserDownloads(e.slice(BrowserDownloads.URL_SCHEME.length))}else {return null}}};IORouterRegistry.registerSaveRouter(browserDownloadsRouter);
function weightsLoaderFactory(e){return async(t,n="",r)=>{const s=t.map((()=>false));const a={};const o=r!=null?r.map((()=>false)):[];const i=[];t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const c="quantization"in e?e.quantization.dtype:e.dtype;const u=DTYPE_VALUE_SIZE_MAP[c]*sizeFromShape(e.shape);const l=()=>{s[t]=true;if(a[t]==null){a[t]=[];}a[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u});};if(r!=null){r.forEach(((t,n)=>{if(t===e.name){l();o[n]=true;}}));}else {l();}i.push(e.name);n+=u;}));}));if(!o.every((e=>e))){const e=r.filter(((e,t)=>!o[t]));throw new Error(`Could not find weights in manifest with names: `+`${e.join(", ")}. \n`+`Manifest JSON has weights with names: `+`${i.join(", ")}.`)}const c=s.reduce(((e,t,n)=>{if(t){e.push(n);}return e}),[]);const u=[];c.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(!n.endsWith("/")?"/":"")+e;u.push(t);}));}));const l=await e(u);const p={};let d=0;c.forEach((e=>{const n=t[e].paths.length;let r=0;for(let e=0;e<n;e++){r+=l[d+e].byteLength;}const s=new ArrayBuffer(r);const o=new Uint8Array(s);let i=0;for(let e=0;e<n;e++){const t=new Uint8Array(l[d+e]);o.set(t,i);i+=t.byteLength;}const c=a[e];c.forEach((e=>{const t=s.slice(e.groupOffset,e.groupOffset+e.sizeBytes);const n=decodeWeights(t,[e.manifestEntry]);for(const e in n){p[e]=n[e];}}));d+=n;}));return p}}
const httpRouter=(e,t)=>{if(typeof fetch==="undefined"&&(t==null||t.fetchFunc==null)){return null}else {let n=true;if(Array.isArray(e)){n=e.every((e=>isHTTPScheme(e)));}else {n=isHTTPScheme(e);}if(n){return http(e,t)}}return null};IORouterRegistry.registerSaveRouter(httpRouter);IORouterRegistry.registerLoadRouter(httpRouter);function browserHTTPRequest(e,t){return http(e,t)}
var io=Object.freeze({__proto__:null,browserFiles:()=>{},browserHTTPRequest:browserHTTPRequest,concatenateArrayBuffers:()=>{},decodeWeights:decodeWeights,encodeWeights:()=>{},fromMemory:()=>{},fromMemorySync:()=>{},getLoadHandlers:getLoadHandlers,getModelArtifactsForJSON:getModelArtifactsForJSON,getModelArtifactsInfoForJSON:getModelArtifactsInfoForJSON,getSaveHandlers:getSaveHandlers,http:()=>{},isHTTPScheme:()=>{},loadWeights:()=>{},registerLoadRouter:registerLoadRouter,registerSaveRouter:registerSaveRouter,weightsLoaderFactory:weightsLoaderFactory,withSaveHandler:()=>{},withSaveHandlerSync:()=>{},copyModel:()=>{},listModels:()=>{},moveModel:()=>{},removeModel:()=>{}});
function matMul_(e,t,n=false,r=false){let s=convertToTensor(e,"a","matMul");let a=convertToTensor(t,"b","matMul");[s,a]=makeTypesMatch(s,a);const o={a:s,b:a};const i={transposeA:n,transposeB:r};return ENGINE.runKernel(BatchMatMul,o,i)}const matMul$1=op({matMul_:matMul_});
function oneHot_(e,t,n=1,r=0){if(t<2){throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`)}const s=convertToTensor(e,"indices","oneHot","int32");const a={indices:s};const o={depth:t,onValue:n,offValue:r};return ENGINE.runKernel(OneHot,a,o)}const oneHot=op({oneHot_:oneHot_});
function enableProdMode(){env().set("PROD",true);}function engine(){return ENGINE}function tidy(e,t){return ENGINE.tidy(e,t)}function dispose(e){const t=getTensorsInContainer(e);t.forEach((e=>e.dispose()));}function keep(e){return ENGINE.keep(e)}function registerBackend(e,t,n=1){return ENGINE.registerBackend(e,t,n)}
function neg_(e){const t=convertToTensor(e,"x","neg");const n={x:t};return ENGINE.runKernel(Neg,n)}const neg=op({neg_:neg_});
function real_(e){const t=convertToTensor(e,"input","real");const n={input:t};return ENGINE.runKernel(Real,n)}const real$1=op({real_:real_});
op({confusionMatrix_:()=>{}});
function getBroadcastDims$1(e,t){const n=e.length;const r=[];for(let s=0;s<n;s++){const a=n-1-s;const o=e[a]||1;const i=t[t.length-1-s]||1;if(i>1&&o===1){r.unshift(a);}}return r}function getReductionAxes(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1];const a=t.length-r-1;const o=t[a];if(s==null||s===1&&o>1){n.unshift(a);}}return n}function assertAndGetBroadcastShape(e,t){const n=[];const r=Math.max(e.length,t.length);for(let s=0;s<r;s++){let r=e[e.length-s-1];if(r==null){r=1;}let a=t[t.length-s-1];if(a==null){a=1;}if(r===1){n.unshift(a);}else if(a===1){n.unshift(r);}else if(r!==a){const n=`Operands could not be broadcast together with shapes `+`${e} and ${t}.`;throw Error(n)}else {n.unshift(r);}}return n}
op({fromPixels_:()=>{}});function validateInput$1(e,t,n){if(t.rank<1){throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+` but the rank was ${t.rank}.`)}if(e.rank<1){throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+` but the rank was ${e.rank}.`)}if(t.dtype!=="int32"){throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`)}if(n.length<1){throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`)}if(n.length===0){if(t.size===0){throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`)}if(e.size===0){throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}}validateUpdateShape(n,t,e);}
function assertParamsValid(e,t,n){const r=e.shape.length;assert(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must `+`match the rank of the array (${r}).`));assert(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must `+`match the rank of the array (${r}).`));for(let s=0;s<r;++s){assert(t[s]+n[s]<=e.shape[s],(()=>`Error in slice${r}D: begin[${s}] + size[${s}] `+`(${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`));}}function isSliceContinous(e,t,n){let r=n.length;for(let e=0;e<n.length;e++){if(n[e]>1){r=e;break}}for(let s=r+1;s<n.length;s++){if(t[s]>0||n[s]!==e[s]){return false}}return true}function computeFlatOffset(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++){n+=e[r]*t[r];}return n}function parseSliceParams(e,t,n){let r;const s=e.shape.length;if(typeof t==="number"){r=[t,...new Array(s-1).fill(0)];}else if(t.length<s){r=t.concat(new Array(s-t.length).fill(0));}else {r=t.slice();}r.forEach((e=>{assert(e!==-1,(()=>"slice() does not support negative begin indexing."));}));let a;if(n==null){a=new Array(s).fill(-1);}else if(typeof n==="number"){a=[n,...new Array(s-1).fill(-1)];}else if(n.length<s){a=n.concat(new Array(s-n.length).fill(-1));}else {a=n;}a=a.map(((t,n)=>{if(t>=0){return t}else {assert(t===-1,(()=>`Negative size values should be exactly -1 but got `+`${t} for the slice() size at index ${n}.`));return e.shape[n]-r[n]}}));return [r,a]}var slice_util=Object.freeze({__proto__:null,assertParamsValid:assertParamsValid,maskToAxes:()=>{},computeOutShape$2:()=>{},stridesWithElidedDims:()=>{},getNormalizedAxes:()=>{},startIndicesWithElidedDims:()=>{},stopIndicesWithElidedDims:()=>{},stridesForAxis:()=>{},startForAxis:()=>{},stopForAxis:()=>{},isSliceContinous:isSliceContinous,computeFlatOffset:computeFlatOffset,parseSliceParams:parseSliceParams,sliceInfo:()=>{}});
class Serializable{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class SerializationMap{constructor(){this.classNameMap={};}static getMap(){if(SerializationMap.instance==null){SerializationMap.instance=new SerializationMap;}return SerializationMap.instance}static register(e){SerializationMap.getMap().classNameMap[e.className]=[e,e.fromConfig];}}function registerClass(e){assert(e.className!=null,(()=>`Class being registered does not have the static className `+`property defined.`));assert(typeof e.className==="string",(()=>`className is required to be a string, but got type `+typeof e.className));assert(e.className.length>0,(()=>`Class being registered has an empty-string as its className, `+`which is disallowed.`));SerializationMap.register(e);}
function add_(e,t){let n=convertToTensor(e,"a","add");let r=convertToTensor(t,"b","add");[n,r]=makeTypesMatch(n,r);const s={a:n,b:r};return ENGINE.runKernel(Add,s)}const add=op({add_:add_});
function div_(e,t){let n=convertToTensor(e,"a","div");let r=convertToTensor(t,"b","div");[n,r]=makeTypesMatch(n,r);if(n.dtype==="int32"&&r.dtype==="int32"){return floorDiv(n,r)}const s={a:n,b:r};const a={};return ENGINE.runKernel(RealDiv,s,a)}const div=op({div_:div_});
function mul_(e,t){let n=convertToTensor(e,"a","mul");let r=convertToTensor(t,"b","mul");[n,r]=makeTypesMatch(n,r);const s={a:n,b:r};return ENGINE.runKernel(Multiply,s)}const mul=op({mul_:mul_});
function abs_(e){const t=convertToTensor(e,"x","abs");if(t.dtype==="complex64"){const e={x:t};return ENGINE.runKernel(ComplexAbs,e)}else {const e={x:t};return ENGINE.runKernel(Abs,e)}}const abs=op({abs_:abs_});
function computePool2DInfo(e,t,n,r,s,a,o="channelsLast"){const[i,c]=parseTupleParam(t);let u;if(o==="channelsLast"){u=[i,c,e[3],e[3]];}else if(o==="channelsFirst"){u=[i,c,e[1],e[1]];}else {throw new Error(`Unknown dataFormat ${o}`)}return computeConv2DInfo(e,u,n,r,s,a,false,o)}function computeConv2DInfo(e,t,n,r,s,a,o=false,i="channelsLast"){let[c,u,l,p]=[-1,-1,-1,-1];if(i==="channelsLast"){[c,u,l,p]=e;}else if(i==="channelsFirst"){[c,p,u,l]=e;}else {throw new Error(`Unknown dataFormat ${i}`)}const[d,h,,m]=t;const[f,g]=parseTupleParam(n);const[y,x]=parseTupleParam(r);const T=getEffectiveFilterSize(d,y);const b=getEffectiveFilterSize(h,x);const{padInfo:E,outHeight:S,outWidth:v}=getPadAndOutInfo(s,u,l,f,g,T,b,a,i);const N=o?m*p:m;let I;if(i==="channelsFirst"){I=[c,N,S,v];}else if(i==="channelsLast"){I=[c,S,v,N];}return {batchSize:c,dataFormat:i,inHeight:u,inWidth:l,inChannels:p,outHeight:S,outWidth:v,outChannels:N,padInfo:E,strideHeight:f,strideWidth:g,filterHeight:d,filterWidth:h,effectiveFilterHeight:T,effectiveFilterWidth:b,dilationHeight:y,dilationWidth:x,inShape:e,outShape:I,filterShape:t}}function getEffectiveFilterSize(e,t){if(t<=1){return e}return e+(e-1)*(t-1)}function convertConv2DDataFormat(e){if(e==="NHWC"){return "channelsLast"}else if(e==="NCHW"){return "channelsFirst"}else {throw new Error(`Unknown dataFormat ${e}`)}}
function reshape_(e,t){const n=convertToTensor(e,"x","reshape","string_or_numeric");const r={x:n};const s={shape:t};return ENGINE.runKernel(Reshape,r,s)}const reshape$1=op({reshape_:reshape_});
function concat_(e,t=0){assert(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=convertToTensorArray(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"){n.forEach((e=>{if(e.dtype!=="complex64"){throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)}}));}if(n.length===1){return clone(n[0])}const r=n;const s={axis:t};return ENGINE.runKernel(Concat,r,s)}const concat$1=op({concat_:concat_});
function sigmoid_(e){const t=convertToTensor(e,"x","sigmoid","float32");const n={x:t};return ENGINE.runKernel(Sigmoid,n)}const sigmoid$1=op({sigmoid_:sigmoid_});
function slice_(e,t,n){const r=convertToTensor(e,"x","slice","string_or_numeric");if(r.rank===0){throw new Error("Slicing scalar is not possible")}const s={x:r};const a={begin:t,size:n};return ENGINE.runKernel(Slice,s,a)}const slice$1=op({slice_:slice_});
op({batchNorm2d_:()=>{}});op({batchNorm3d_:()=>{}});op({batchNorm4d_:()=>{}});
function bincount_(e,t,n){const r=convertToTensor(e,"x","bincount");const s=convertToTensor(t,"weights","bincount");assert(r.dtype==="int32",(()=>`Error in bincount: input `+`dtype must be int32, but got ${r.dtype}`));assert(n>=0,(()=>`size must be non-negative, but got ${n}.`));assert(s.size===r.size||s.size===0,(()=>`Error in bincount: weights must have the same size as input or`+`0-length, but got input shape: ${r.shape}, weights shape: `+`${s.shape}.`));const a={x:r,weights:s};const o={size:n};return ENGINE.runKernel(Bincount,a,o)}const bincount=op({bincount_:bincount_});
function broadcastTo_(e,t){let n=convertToTensor(e,"broadcastTo","x");const r=n.shape;if(t.some((e=>!(e>0)||e%1!==0))){throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`)}if(t.length<n.rank){throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`)}if(t.length>n.rank){const e=n.shape.slice();while(e.length<t.length){e.unshift(1);}n=reshape$1(n,e);}const s=n.shape;const a=Array.from(t);for(let e=t.length-1;e>=0;e--){if(s[e]===t[e]){a[e]=1;}else if(n.shape[e]!==1){throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`)}}const o=a.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0));if(o.length===0){return clone(n)}const i={x:n};const c={reps:a};return ENGINE.runKernel(Tile,i,c)}const broadcastTo=op({broadcastTo_:broadcastTo_});
op({concat1d_:()=>{}});op({concat2d_:()=>{}});op({concat3d_:()=>{}});op({concat4d_:()=>{}});
op({conv1d_:()=>{}});
function conv2DBackpropInput_(e,t,n,r,s,a="NHWC",o){assert(e.length===t.rank,(()=>`Length of inShape `+`(${e.length}) and rank of dy (${t.rank}) must match`));let i=e;let c=t;let u=false;if(t.rank===3){u=true;c=reshape$1(t,[1,t.shape[0],t.shape[1],t.shape[2]]);i=[1,e[0],e[1],e[2]];}assert(i.length===4,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length `+`${i.length}.`));assert(c.rank===4,(()=>`Error in conv2dDerInput: dy must be rank 4, but got `+`rank ${c.rank}`));assert(n.rank===4,(()=>`Error in conv2dDerInput: filter must be rank 4, but got `+`rank ${n.rank}`));const l=a==="NHWC"?i[3]:i[1];const p=a==="NHWC"?c.shape[3]:c.shape[1];assert(l===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${l}) must `+`match input depth for filter ${n.shape[2]}.`));assert(p===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${p}) must `+`match output depth for filter ${n.shape[3]}.`));checkPadOnDimRoundingMode("conv2dDerInput",s,o);const d={dy:c,filter:n};const h={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,inputShape:i};const m=ENGINE.runKernel(Conv2DBackpropInput,d,h);if(u){return reshape$1(m,[m.shape[1],m.shape[2],m.shape[3]])}return m}op({conv2DBackpropInput_:conv2DBackpropInput_});op({conv2dTranspose_:()=>{}});
op({conv3dTranspose_:()=>{}});
function equal_(e,t){let n=convertToTensor(e,"a","equal","string_or_numeric");let r=convertToTensor(t,"b","equal","string_or_numeric");[n,r]=makeTypesMatch(n,r);assertAndGetBroadcastShape(n.shape,r.shape);const s={a:n,b:r};return ENGINE.runKernel(Equal,s)}const equal=op({equal_:equal_});
function where_(e,t,n){const r=convertToTensor(t,"a","where");const s=convertToTensor(n,"b","where");const a=convertToTensor(e,"condition","where","bool");const o=assertAndGetBroadcastShape(assertAndGetBroadcastShape(a.shape,r.shape),s.shape);const i=broadcastTo(a,o);const c=broadcastTo(r,o);const u=broadcastTo(s,o);const l={condition:i,t:c,e:u};return ENGINE.runKernel(Select,l)}const where=op({where_:where_});
function zerosLike_(e){const t=convertToTensor(e,"x","zerosLike");const n={x:t};return ENGINE.runKernel(ZerosLike,n)}const zerosLike=op({zerosLike_:zerosLike_});
function dot_(e,t){const n=convertToTensor(e,"t1","dot");const r=convertToTensor(t,"t2","dot");assert((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks `+`${n.rank} and ${r.rank}.`));const s=n.rank===1?n.size:n.shape[1];const a=r.rank===1?r.size:r.shape[0];assert(s===a,(()=>`Error in dot: inner dimensions of inputs must match, but got `+`${s} and ${a}.`));if(n.rank===1&&r.rank===1){const e=reshape$1(n,[1,-1]);const t=reshape$1(r,[-1,1]);const s=matMul$1(e,t);return reshape$1(s,[])}else if(n.rank===1&&r.rank===2){const e=reshape$1(n,[1,-1]);const t=reshape$1(r,[r.shape[0],r.shape[1]]);const s=matMul$1(e,t);return reshape$1(s,[s.size])}else if(n.rank===2&&r.rank===1){const e=reshape$1(r,[-1,1]);const t=matMul$1(n,e);return reshape$1(t,[t.size])}else {const e=reshape$1(r,[r.shape[0],r.shape[1]]);const t=matMul$1(n,e);return t}}const dot=op({dot_:dot_});
function axesAreInnerMostDims(e,t){for(let n=0;n<e.length;++n){if(e[e.length-n-1]!==t-1-n){return false}}return true}function computeOutAndReduceShapes(e,t){const n=[];const r=e.length;for(let s=0;s<r;s++){if(t.indexOf(s)===-1){n.push(e[s]);}}const s=t.map((t=>e[t]));return [n,s]}function expandShapeToKeepDim(e,t){const n=t.map((e=>1));return combineLocations(e,n,t)}function assertAxesAreInnerMostDims(e,t,n){assert(axesAreInnerMostDims(t,n),(()=>`${e} supports only inner-most axes for now. `+`Got axes ${t} and rank-${n} input.`));}function getAxesPermutation(e,t){if(axesAreInnerMostDims(e,t)){return null}const n=[];for(let r=0;r<t;++r){if(e.indexOf(r)===-1){n.push(r);}}e.forEach((e=>n.push(e)));return n}function getInnerMostAxes(e,t){const n=[];for(let r=t-e;r<t;++r){n.push(r);}return n}
function max_(e,t=null,n=false){const r=convertToTensor(e,"x","max");const s={x:r};const a={reductionIndices:t,keepDims:n};return ENGINE.runKernel(Max,s,a)}const max=op({max_:max_});
function scalar(e,t){if((isTypedArray(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64"){throw new Error("Error creating a new Scalar: value must be a primitive "+"(number|boolean|string)")}if(t==="string"&&isTypedArray(e)&&!(e instanceof Uint8Array)){throw new Error("When making a scalar from encoded string, "+"the value must be `Uint8Array`.")}const n=[];const r=[];return makeTensor(e,n,r,t)}
function square_(e){const t=convertToTensor(e,"x","square");const n={};return ENGINE.runKernel("Square",{x:t},n)}const square=op({square_:square_});
function sum_(e,t=null,n=false){let r=convertToTensor(e,"x","sum");if(r.dtype==="bool"){r=cast$1(r,"int32");}const s={x:r};const a={axis:t,keepDims:n};return ENGINE.runKernel(Sum,s,a)}const sum$1=op({sum_:sum_});
function norm_(e,t="euclidean",n=null,r=false){e=convertToTensor(e,"x","norm");const s=normImpl(e,t,n);let a=s.shape;if(r){const t=parseAxisParam(n,e.shape);a=expandShapeToKeepDim(s.shape,t);}return reshape$1(s,a)}function normImpl(e,t,n=null){if(e.rank===0){return abs(e)}if(e.rank!==1&&n===null){return normImpl(reshape$1(e,[-1]),t,n)}if(e.rank===1||typeof n==="number"||Array.isArray(n)&&n.length===1){if(t===1){return sum$1(abs(e),n)}if(t===Infinity){return max(abs(e),n)}if(t===-Infinity){return min(abs(e),n)}if(t==="euclidean"||t===2){return sqrt(sum$1(pow$1(abs(e),scalar(2,"int32")),n))}throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1){return max(sum$1(abs(e),n[0]),n[1]-1)}if(t===Infinity){return max(sum$1(abs(e),n[1]),n[0])}if(t===-Infinity){return min(sum$1(abs(e),n[1]),n[0])}if(t==="fro"||t==="euclidean"){return sqrt(sum$1(square(e),n))}throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const norm=op({norm_:norm_});
function exp_(e){const t=convertToTensor(e,"x","exp");const n={x:t};return ENGINE.runKernel(Exp,n)}const exp=op({exp_:exp_});
function expandDims_(e,t=0){const n=convertToTensor(e,"x","expandDims","string_or_numeric");assert(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n};const s={dim:t};return ENGINE.runKernel(ExpandDims,r,s)}const expandDims$1=op({expandDims_:expandDims_});
function gather_(e,t,n=0,r=0){const s=convertToTensor(e,"x","gather");const a=convertToTensor(t,"indices","gather","int32");const o={x:s,indices:a};const i={axis:n,batchDims:r};return ENGINE.runKernel(GatherV2,o,i)}const gather=op({gather_:gather_});
function greater_(e,t){let n=convertToTensor(e,"a","greater","string_or_numeric");let r=convertToTensor(t,"b","greater","string_or_numeric");[n,r]=makeTypesMatch(n,r);assertAndGetBroadcastShape(n.shape,r.shape);const s={a:n,b:r};return ENGINE.runKernel(Greater,s)}const greater=op({greater_:greater_});
function log_(e){const t=convertToTensor(e,"x","log","float32");const n={x:t};return ENGINE.runKernel(Log,n)}const log=op({log_:log_});
function log1p_(e){const t=convertToTensor(e,"x","log1p");const n={x:t};return ENGINE.runKernel(Log1p,n)}const log1p=op({log1p_:log1p_});
function customGrad(e){return ENGINE.customGrad(e)}
function sub_(e,t){let n=convertToTensor(e,"a","sub");let r=convertToTensor(t,"b","sub");[n,r]=makeTypesMatch(n,r);const s={a:n,b:r};return ENGINE.runKernel(Sub,s)}const sub=op({sub_:sub_});
function logSumExp_(e,t=null,n=false){const r=convertToTensor(e,"x","logSumExp");const s=parseAxisParam(t,r.shape);const a=max(r,s,true);const o=sub(r,a);const i=exp(o);const c=sum$1(i,s);const u=log(c);const l=add(reshape$1(a,u.shape),u);if(n){const e=expandShapeToKeepDim(l.shape,s);return reshape$1(l,e)}return l}const logSumExp=op({logSumExp_:logSumExp_});
function logicalAnd_(e,t){const n=convertToTensor(e,"a","logicalAnd","bool");const r=convertToTensor(t,"b","logicalAnd","bool");assertAndGetBroadcastShape(n.shape,r.shape);const s={a:n,b:r};return ENGINE.runKernel(LogicalAnd,s)}const logicalAnd=op({logicalAnd_:logicalAnd_});
op({searchSorted_:()=>{}});
function maximum_(e,t){let n=convertToTensor(e,"a","maximum");let r=convertToTensor(t,"b","maximum");[n,r]=makeTypesMatch(n,r);if(n.dtype==="bool"){n=cast$1(n,"int32");r=cast$1(r,"int32");}assertAndGetBroadcastShape(n.shape,r.shape);const s={a:n,b:r};return ENGINE.runKernel(Maximum,s)}const maximum=op({maximum_:maximum_});
function mean_(e,t=null,n=false){const r=convertToTensor(e,"x","mean");const s={x:r};const a={axis:t,keepDims:n};return ENGINE.runKernel(Mean,s,a)}const mean=op({mean_:mean_});
function zeros$1(e,t="float32"){if(t==="complex64"){const t=zeros$1(e,"float32");const n=zeros$1(e,"float32");return complex$1(t,n)}const n=makeZerosTypedArray(sizeFromShape(e),t);return ENGINE.makeTensor(n,e,t)}
function ones(e,t="float32"){if(t==="complex64"){const t=ones(e,"float32");const n=zeros$1(e,"float32");return complex$1(t,n)}const n=makeOnesTypedArray(sizeFromShape(e),t);return ENGINE.makeTensor(n,e,t)}
function minimum_(e,t){let n=convertToTensor(e,"a","minimum");let r=convertToTensor(t,"b","minimum");[n,r]=makeTypesMatch(n,r);if(n.dtype==="bool"){n=cast$1(n,"int32");r=cast$1(r,"int32");}assertAndGetBroadcastShape(n.shape,r.shape);const s={a:n,b:r};return ENGINE.runKernel(Minimum,s)}const minimum=op({minimum_:minimum_});
op({multiRNNCell_:()=>{}});
function notEqual_(e,t){let n=convertToTensor(e,"a","notEqual","string_or_numeric");let r=convertToTensor(t,"b","notEqual","string_or_numeric");[n,r]=makeTypesMatch(n,r);assertAndGetBroadcastShape(n.shape,r.shape);const s={a:n,b:r};return ENGINE.runKernel(NotEqual,s)}const notEqual$1=op({notEqual_:notEqual_});
op({outerProduct_:()=>{}});
function pad_(e,t,n=0){const r=convertToTensor(e,"x","pad");if(r.rank===0){throw new Error("pad(scalar) is not defined. Pass non-scalar to pad")}const s={paddings:t,constantValue:n};const a={x:r};return ENGINE.runKernel(PadV2,a,s)}const pad=op({pad_:pad_});op({pad1d_:()=>{}});op({pad2d_:()=>{}});op({pad3d_:()=>{}});op({pad4d_:()=>{}});
function prod_(e,t=null,n=false){let r=convertToTensor(e,"x","prod");if(r.dtype==="bool"){r=cast$1(r,"int32");}const s={x:r};const a={axis:t,keepDims:n};return ENGINE.runKernel(Prod,s,a)}const prod$1=op({prod_:prod_});
var alea$1={exports:{}};(function(e){(function(e,t,n){function r(e){var t=this,n=o();t.next=function(){var e=2091639*t.s0+t.c*2.3283064365386963e-10;t.s0=t.s1;t.s1=t.s2;return t.s2=e-(t.c=e|0)};t.c=1;t.s0=n(" ");t.s1=n(" ");t.s2=n(" ");t.s0-=n(e);if(t.s0<0){t.s0+=1;}t.s1-=n(e);if(t.s1<0){t.s1+=1;}t.s2-=n(e);if(t.s2<0){t.s2+=1;}n=null;}function s(e,t){t.c=e.c;t.s0=e.s0;t.s1=e.s1;t.s2=e.s2;return t}function a(e,t){var n=new r(e),a=t&&t.state,o=n.next;o.int32=function(){return n.next()*4294967296|0};o.double=function(){return o()+(o()*2097152|0)*11102230246251565e-32};o.quick=o;if(a){if(typeof a=="object")s(a,n);o.state=function(){return s(n,{})};}return o}function o(){var e=4022871197;var t=function(t){t=String(t);for(var n=0;n<t.length;n++){e+=t.charCodeAt(n);var r=.02519603282416938*e;e=r>>>0;r-=e;r*=e;e=r>>>0;r-=e;e+=r*4294967296;}return (e>>>0)*2.3283064365386963e-10};return t}if(t&&t.exports){t.exports=a;}else if(n&&n.amd){n((function(){return a}));}else {this.alea=a;}})(commonjsGlobal,e,typeof undefined=="function");})(alea$1);var xor128$1={exports:{}};(function(e){(function(e,t,n){function r(e){var t=this,n="";t.x=0;t.y=0;t.z=0;t.w=0;t.next=function(){var e=t.x^t.x<<11;t.x=t.y;t.y=t.z;t.z=t.w;return t.w^=t.w>>>19^e^e>>>8};if(e===(e|0)){t.x=e;}else {n+=e;}for(var r=0;r<n.length+64;r++){t.x^=n.charCodeAt(r)|0;t.next();}}function s(e,t){t.x=e.x;t.y=e.y;t.z=e.z;t.w=e.w;return t}function a(e,t){var n=new r(e),a=t&&t.state,o=function(){return (n.next()>>>0)/4294967296};o.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);}while(r===0);return r};o.int32=n.next;o.quick=o;if(a){if(typeof a=="object")s(a,n);o.state=function(){return s(n,{})};}return o}if(t&&t.exports){t.exports=a;}else if(n&&n.amd){n((function(){return a}));}else {this.xor128=a;}})(commonjsGlobal,e,typeof undefined=="function");})(xor128$1);var xorwow$1={exports:{}};(function(e){(function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;t.x=t.y;t.y=t.z;t.z=t.w;t.w=t.v;return (t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^(e^e<<1))|0};t.x=0;t.y=0;t.z=0;t.w=0;t.v=0;if(e===(e|0)){t.x=e;}else {n+=e;}for(var r=0;r<n.length+64;r++){t.x^=n.charCodeAt(r)|0;if(r==n.length){t.d=t.x<<10^t.x>>>4;}t.next();}}function s(e,t){t.x=e.x;t.y=e.y;t.z=e.z;t.w=e.w;t.v=e.v;t.d=e.d;return t}function a(e,t){var n=new r(e),a=t&&t.state,o=function(){return (n.next()>>>0)/4294967296};o.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);}while(r===0);return r};o.int32=n.next;o.quick=o;if(a){if(typeof a=="object")s(a,n);o.state=function(){return s(n,{})};}return o}if(t&&t.exports){t.exports=a;}else if(n&&n.amd){n((function(){return a}));}else {this.xorwow=a;}})(commonjsGlobal,e,typeof undefined=="function");})(xorwow$1);var xorshift7$1={exports:{}};(function(e){(function(e,t,n){function r(e){var t=this;t.next=function(){var e=t.x,n=t.i,r,s;r=e[n];r^=r>>>7;s=r^r<<24;r=e[n+1&7];s^=r^r>>>10;r=e[n+3&7];s^=r^r>>>3;r=e[n+4&7];s^=r^r<<7;r=e[n+7&7];r=r^r<<13;s^=r^r<<9;e[n]=s;t.i=n+1&7;return s};function n(e,t){var n,r=[];if(t===(t|0)){r[0]=t;}else {t=""+t;for(n=0;n<t.length;++n){r[n&7]=r[n&7]<<15^t.charCodeAt(n)+r[n+1&7]<<13;}}while(r.length<8)r.push(0);for(n=0;n<8&&r[n]===0;++n);if(n==8)r[7]=-1;else r[n];e.x=r;e.i=0;for(n=256;n>0;--n){e.next();}}n(t,e);}function s(e,t){t.x=e.x.slice();t.i=e.i;return t}function a(e,t){if(e==null)e=+new Date;var n=new r(e),a=t&&t.state,o=function(){return (n.next()>>>0)/4294967296};o.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);}while(r===0);return r};o.int32=n.next;o.quick=o;if(a){if(a.x)s(a,n);o.state=function(){return s(n,{})};}return o}if(t&&t.exports){t.exports=a;}else if(n&&n.amd){n((function(){return a}));}else {this.xorshift7=a;}})(commonjsGlobal,e,typeof undefined=="function");})(xorshift7$1);var xor4096$1={exports:{}};(function(e){(function(e,t,n){function r(e){var t=this;t.next=function(){var e=t.w,n=t.X,r=t.i,s,a;t.w=e=e+1640531527|0;a=n[r+34&127];s=n[r=r+1&127];a^=a<<13;s^=s<<17;a^=a>>>15;s^=s>>>12;a=n[r]=a^s;t.i=r;return a+(e^e>>>16)|0};function n(e,t){var n,r,s,a,o,i=[],c=128;if(t===(t|0)){r=t;t=null;}else {t=t+"\0";r=0;c=Math.max(c,t.length);}for(s=0,a=-32;a<c;++a){if(t)r^=t.charCodeAt((a+32)%t.length);if(a===0)o=r;r^=r<<10;r^=r>>>15;r^=r<<4;r^=r>>>13;if(a>=0){o=o+1640531527|0;n=i[a&127]^=r+o;s=0==n?s+1:0;}}if(s>=128){i[(t&&t.length||0)&127]=-1;}s=127;for(a=4*128;a>0;--a){r=i[s+34&127];n=i[s=s+1&127];r^=r<<13;n^=n<<17;r^=r>>>15;n^=n>>>12;i[s]=r^n;}e.w=o;e.X=i;e.i=s;}n(t,e);}function s(e,t){t.i=e.i;t.w=e.w;t.X=e.X.slice();return t}function a(e,t){if(e==null)e=+new Date;var n=new r(e),a=t&&t.state,o=function(){return (n.next()>>>0)/4294967296};o.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);}while(r===0);return r};o.int32=n.next;o.quick=o;if(a){if(a.X)s(a,n);o.state=function(){return s(n,{})};}return o}if(t&&t.exports){t.exports=a;}else if(n&&n.amd){n((function(){return a}));}else {this.xor4096=a;}})(commonjsGlobal,e,typeof undefined=="function");})(xor4096$1);var tychei$1={exports:{}};(function(e){(function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;e=e<<25^e>>>7^n;n=n-r|0;r=r<<24^r>>>8^s;s=s-e|0;t.b=e=e<<20^e>>>12^n;t.c=n=n-r|0;t.d=r<<16^n>>>16^s;return t.a=s-e|0};t.a=0;t.b=0;t.c=2654435769|0;t.d=1367130551;if(e===Math.floor(e)){t.a=e/4294967296|0;t.b=e|0;}else {n+=e;}for(var r=0;r<n.length+20;r++){t.b^=n.charCodeAt(r)|0;t.next();}}function s(e,t){t.a=e.a;t.b=e.b;t.c=e.c;t.d=e.d;return t}function a(e,t){var n=new r(e),a=t&&t.state,o=function(){return (n.next()>>>0)/4294967296};o.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);}while(r===0);return r};o.int32=n.next;o.quick=o;if(a){if(typeof a=="object")s(a,n);o.state=function(){return s(n,{})};}return o}if(t&&t.exports){t.exports=a;}else if(n&&n.amd){n((function(){return a}));}else {this.tychei=a;}})(commonjsGlobal,e,typeof undefined=="function");})(tychei$1);var seedrandom$1={exports:{}};(function(e){(function(t,n,r){var s=256,a=6,o=52,i="random",c=r.pow(s,a),u=r.pow(2,o),l=u*2,p=s-1,d;function h(e,t,o){var p=[];t=t==true?{entropy:true}:t||{};var d=y(g(t.entropy?[e,T(n)]:e==null?x():e,3),p);var h=new m(p);var b=function(){var e=h.g(a),t=c,n=0;while(e<u){e=(e+n)*s;t*=s;n=h.g(1);}while(e>=l){e/=2;t/=2;n>>>=1;}return (e+n)/t};b.int32=function(){return h.g(4)|0};b.quick=function(){return h.g(4)/4294967296};b.double=b;y(T(h.S),n);return (t.pass||o||function(e,t,n,s){if(s){if(s.S){f(s,h);}e.state=function(){return f(h,{})};}if(n){r[i]=e;return t}else return e})(b,d,"global"in t?t.global:this==r,t.state)}function m(e){var t,n=e.length,r=this,a=0,o=r.i=r.j=0,i=r.S=[];if(!n){e=[n++];}while(a<s){i[a]=a++;}for(a=0;a<s;a++){i[a]=i[o=p&o+e[a%n]+(t=i[a])];i[o]=t;}(r.g=function(e){var t,n=0,a=r.i,o=r.j,i=r.S;while(e--){t=i[a=p&a+1];n=n*s+i[p&(i[a]=i[o=p&o+t])+(i[o]=t)];}r.i=a;r.j=o;return n})(s);}function f(e,t){t.i=e.i;t.j=e.j;t.S=e.S.slice();return t}function g(e,t){var n=[],r=typeof e,s;if(t&&r=="object"){for(s in e){try{n.push(g(e[s],t-1));}catch(e){}}}return n.length?n:r=="string"?e:e+"\0"}function y(e,t){var n=e+"",r,s=0;while(s<n.length){t[p&s]=p&(r^=t[p&s]*19)+n.charCodeAt(s++);}return T(t)}function x(){try{var e;if(d&&(e=d.randomBytes)){e=e(s);}else {e=new Uint8Array(s);(t.crypto||t.msCrypto).getRandomValues(e);}return T(e)}catch(e){var r=t.navigator,a=r&&r.plugins;return [+new Date,t,a,t.screen,T(n)]}}function T(e){return String.fromCharCode.apply(0,e)}y(r.random(),n);if(e.exports){e.exports=h;try{d=require("crypto");}catch(e){}}else {r["seed"+i]=h;}})(typeof self!=="undefined"?self:commonjsGlobal,[],Math);})(seedrandom$1);var alea=alea$1.exports;var xor128=xor128$1.exports;var xorwow=xorwow$1.exports;var xorshift7=xorshift7$1.exports;var xor4096=xor4096$1.exports;var tychei=tychei$1.exports;var sr=seedrandom$1.exports;sr.alea=alea;sr.xor128=xor128;sr.xorwow=xorwow;sr.xorshift7=xorshift7;sr.xor4096=xor4096;sr.tychei=tychei;function range(e,t,n=1,r="float32"){if(n===0){throw new Error("Cannot have a step of zero")}const s={start:e,stop:t,step:n,dtype:r};return ENGINE.runKernel(Range,{},s)}
function relu_(e){const t=convertToTensor(e,"x","relu");const n={x:t};return ENGINE.runKernel(Relu,n)}const relu$1=op({relu_:relu_});
function reverse_(e,t){const n=convertToTensor(e,"x","reverse");const r={x:n};const s={dims:t};return ENGINE.runKernel(Reverse,r,s)}const reverse=op({reverse_:reverse_});
op({separableConv2d_:()=>{}});
function fft_(e){assert(e.dtype==="complex64",(()=>`The dtype for tf.spectral.fft() must be complex64 `+`but got ${e.dtype}.`));const t={input:e};return ENGINE.runKernel(FFT,t)}const fft=op({fft_:fft_});
function squaredDifference_(e,t){let n=convertToTensor(e,"a","squaredDifference");let r=convertToTensor(t,"b","squaredDifference");[n,r]=makeTypesMatch(n,r);assertAndGetBroadcastShape(n.shape,r.shape);const s={a:n,b:r};const a={};return ENGINE.runKernel(SquaredDifference,s,a)}const squaredDifference=op({squaredDifference_:squaredDifference_});
function squeeze_(e,t){const n=convertToTensor(e,"x","squeeze","string_or_numeric");return reshape$1(n,squeezeShape(n.shape,t).newShape)}const squeeze=op({squeeze_:squeeze_});
function stack_(e,t=0){const n=convertToTensorArray(e,"tensors","stack","string_or_numeric");assert(n.length>=1,(()=>"Pass at least one tensor to tf.stack"));if(n.length>0){assert(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));}const r=n;const s={axis:t};return ENGINE.runKernel(Pack,r,s)}const stack=op({stack_:stack_});
function tensor1d(e,t){assertNonNull(e);const n=inferShape(e,t);if(n.length!==1){throw new Error("tensor1d() requires values to be a flat/TypedArray")}const r=null;return makeTensor(e,r,n,t)}
function tensor2d(e,t,n){assertNonNull(e);if(t!=null&&t.length!==2){throw new Error("tensor2d() requires shape to have two numbers")}const r=inferShape(e,n);if(r.length!==2&&r.length!==1){throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray")}if(r.length===1&&t==null){throw new Error("tensor2d() requires shape to be provided when `values` "+"are a flat/TypedArray")}return makeTensor(e,t,r,n)}
function unstack_(e,t=0){const n=convertToTensor(e,"x","unstack","string_or_numeric");assert(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n};const s={axis:t};return ENGINE.runKernel(Unpack,r,s)}const unstack=op({unstack_:unstack_});
function conv2DBackpropFilter_(e,t,n,r,s,a="NHWC",o){let i=e;if(e.rank===3){i=reshape$1(e,[1,e.shape[0],e.shape[1],e.shape[2]]);}let c=t;if(c.rank===3){c=reshape$1(t,[1,t.shape[0],t.shape[1],t.shape[2]]);}assert(i.rank===4,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape `+`${i.shape}.`));assert(c.rank===4,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape `+`${c.shape}.`));assert(n.length===4,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got `+`${n}.`));const u=a==="NHWC"?i.shape[3]:i.shape[1];const l=a==="NHWC"?c.shape[3]:c.shape[1];assert(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must `+`match input depth in filter (${n[2]}.`));assert(l===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${l}) must `+`match output depth for filter (${n[3]}).`));checkPadOnDimRoundingMode("conv2dDerFilter",s,o);const p={x:i,dy:c};const d={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,filterShape:n};return ENGINE.runKernel(Conv2DBackpropFilter,p,d)}op({conv2DBackpropFilter_:conv2DBackpropFilter_});
function getFusedDyActivation(e,t,n){if(n==null||n==="linear"){return e}if(n==="relu"){return mul(e,step(t))}throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function getFusedBiasGradient(e,t){let n=t;const r=getReductionAxes(e.shape,t.shape);if(r.length>0){n=sum$1(n,r);}return reshape$1(n,e.shape)}const shouldFuse=(e,t)=>{const n=e>0;return !n||t==="linear"};
function depthwiseConv2dNativeBackpropFilter_(e,t,n,r,s,a=[1,1],o){let i=e;if(e.rank===3){i=reshape$1(e,[1,e.shape[0],e.shape[1],e.shape[2]]);}let c=t;if(c.rank===3){c=reshape$1(t,[1,t.shape[0],t.shape[1],t.shape[2]]);}const u={x:i,dy:c};const l={strides:r,pad:s,dimRoundingMode:o,dilations:a,filterShape:n};return ENGINE.runKernel(DepthwiseConv2dNativeBackpropFilter,u,l)}op({depthwiseConv2dNativeBackpropFilter_:depthwiseConv2dNativeBackpropFilter_});
function depthwiseConv2dNativeBackpropInput_(e,t,n,r,s,a=[1,1],o){let i=t;let c=false;if(t.rank===3){c=true;i=reshape$1(t,[1,t.shape[0],t.shape[1],t.shape[2]]);}const u={dy:i,filter:n};const l={strides:r,pad:s,dimRoundingMode:o,dilations:a,inputShape:e};const p=ENGINE.runKernel(DepthwiseConv2dNativeBackpropInput,u,l);if(c){return reshape$1(p,[p.shape[1],p.shape[2],p.shape[3]])}return p}op({depthwiseConv2dNativeBackpropInput_:depthwiseConv2dNativeBackpropInput_});
function fusedMatMul_({a:e,b:t,transposeA:n=false,transposeB:r=false,bias:s,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if(shouldFuse(ENGINE.state.gradientDepth,a)===false){let c=matMul$1(e,t,n,r);if(s!=null){c=add(c,s);}return applyActivation(c,a,o,i)}let c=convertToTensor(e,"a","fused matMul");let u=convertToTensor(t,"b","fused matMul");[c,u]=makeTypesMatch(c,u);const l=n?c.shape[c.rank-2]:c.shape[c.rank-1];const p=r?u.shape[u.rank-1]:u.shape[u.rank-2];const d=n?c.shape[c.rank-1]:c.shape[c.rank-2];const h=r?u.shape[u.rank-2]:u.shape[u.rank-1];const m=c.shape.slice(0,-2);const f=u.shape.slice(0,-2);const g=sizeFromShape(m);const y=sizeFromShape(f);assert(l===p,(()=>`Error in fused matMul: inner shapes (${l}) and (`+`${p}) of Tensors with shapes ${c.shape} and `+`${u.shape} and transposeA=${n}`+` and transposeB=${r} must match.`));const x=assertAndGetBroadcastShape(c.shape.slice(0,-2),u.shape.slice(0,-2));const T=x.concat([d,h]);const b=n?reshape$1(c,[g,l,d]):reshape$1(c,[g,d,l]);const E=r?reshape$1(u,[y,h,p]):reshape$1(u,[y,p,h]);let S;if(s!=null){S=convertToTensor(s,"bias","fused matMul");[S]=makeTypesMatch(S,c);assertAndGetBroadcastShape(T,S.shape);}let v;if(o!=null){v=convertToTensor(o,"prelu weights","fused matMul");}const N=(e,t)=>{const[o,i,c,u]=t;const l=getFusedDyActivation(reshape$1(e,c.shape),c,a);let p;let d;if(!n&&!r){p=matMul$1(l,i,false,true);d=matMul$1(o,l,true,false);}else if(!n&&r){p=matMul$1(l,i,false,false);d=matMul$1(l,o,true,false);}else if(n&&!r){p=matMul$1(i,l,false,true);d=matMul$1(o,l,false,false);}else {p=matMul$1(i,l,true,true);d=matMul$1(l,o,true,true);}if(s!=null){const e=getFusedBiasGradient(u,l);return [p,d,e]}else {return [p,d]}};const I={a:b,b:E,bias:S,preluActivationWeights:v};const _={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:i};if(s==null){const e=customGrad(((e,t,n)=>{const r=ENGINE.runKernel(_FusedMatMul,I,_);n([e,t,r]);return {value:reshape$1(r,T),gradFunc:N}}));return e(b,E)}else {const e=customGrad(((e,t,n,r)=>{const s=ENGINE.runKernel(_FusedMatMul,I,_);r([e,t,s,n]);return {value:reshape$1(s,T),gradFunc:N}}));return e(b,E,S)}}const matMul=op({fusedMatMul_:fusedMatMul_});
var fused_ops=Object.freeze({__proto__:null,conv2d_:()=>{},depthwiseConv2d_:()=>{},matMul:matMul});
function frame_(e,t,n,r=false,s=0){let a=0;const o=[];while(a+t<=e.size){o.push(slice$1(e,a,t));a+=n;}if(r){while(a<e.size){const r=a+t-e.size;const i=concat$1([slice$1(e,a,t-r),fill$1([r],s)]);o.push(i);a+=n;}}if(o.length===0){return tensor2d([],[0,t])}return reshape$1(concat$1(o),[o.length,t])}const frame=op({frame_:frame_});
var Reduction;(function(e){e[e["NONE"]=0]="NONE";e[e["MEAN"]=1]="MEAN";e[e["SUM"]=2]="SUM";e[e["SUM_BY_NONZERO_WEIGHTS"]=3]="SUM_BY_NONZERO_WEIGHTS";})(Reduction||(Reduction={}));op({computeWeightedLoss_:()=>{}});
op({cosineDistance_:()=>{}});op({hingeLoss_:()=>{}});
op({sigmoidCrossEntropy_:()=>{}});
op({softmaxCrossEntropy_:()=>{}});
const spectral$1={fft:fft,ifft_:()=>{},rfft_:()=>{},irfft_:()=>{}};const signal={hammingWindow_:()=>{},hannWindow_:()=>{},frame:frame,stft_:()=>{}};const image$1={flipLeftRight_:()=>{},grayscaleToRGB_:()=>{},resizeNearestNeighbor_:()=>{},resizeBilinear_:()=>{},rotateWithOffset_:()=>{},cropAndResize_:()=>{},nonMaxSuppression_:()=>{},nonMaxSuppressionAsync_:()=>{},nonMaxSuppressionWithScore_:()=>{},nonMaxSuppressionWithScoreAsync_:()=>{},nonMaxSuppressionPadded_:()=>{},nonMaxSuppressionPaddedAsync_:()=>{},threshold_:()=>{},transform_:()=>{}};const linalg={bandPart_:()=>{},gramSchmidt_:()=>{},qr_:()=>{}};const losses={absoluteDifference_:()=>{},computeWeightedLoss_:()=>{},cosineDistance_:()=>{},hingeLoss_:()=>{},huberLoss_:()=>{},logLoss_:()=>{},meanSquaredError_:()=>{},sigmoidCrossEntropy_:()=>{},softmaxCrossEntropy_:()=>{}};const sparse$1={sparseFillEmptyRows_:()=>{},sparseReshape_:()=>{},sparseSegmentMean_:()=>{},sparseSegmentSum_:()=>{}};const string$1={stringNGrams_:()=>{},stringSplit_:()=>{},stringToHashBucketFast_:()=>{}};
class Optimizer extends Serializable{minimize(e,t=false,n){const{value:r,grads:s}=this.computeGradients(e,n);if(n!=null){const e=n.map((e=>({name:e.name,tensor:s[e.name]})));this.applyGradients(e);}else {this.applyGradients(s);}dispose(s);if(t){return r}else {r.dispose();return null}}get iterations(){if(this.iterations_==null){this.iterations_=0;}return this.iterations_}incrementIterations(){this.iterations_=this.iterations+1;}computeGradients(e,t){return variableGrads(e,t)}dispose(){if(this.iterations_!=null){dispose(this.iterations_);}}async saveIterations(){if(this.iterations_==null){this.iterations_=0;}return {name:"iter",tensor:scalar(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class `+`${this.getClassName()}`)}async extractIterations(e){this.iterations_=(await e[0].tensor.data())[0];return e.slice(1)}}Object.defineProperty(Optimizer,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});
class AdadeltaOptimizer extends Optimizer{constructor(e,t,n=null){super();this.learningRate=e;this.rho=t;this.epsilon=n;this.accumulatedGrads=[];this.accumulatedUpdates=[];if(n==null){this.epsilon=ENGINE.backend.epsilon();}}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=ENGINE.registeredVariables[t];const s=false;if(this.accumulatedGrads[n]==null){this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:tidy((()=>zerosLike(r).variable(s)))};}if(this.accumulatedUpdates[n]==null){this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:tidy((()=>zerosLike(r).variable(s)))};}const a=Array.isArray(e)?e[n].tensor:e[t];if(a==null){return}const o=this.accumulatedGrads[n].variable;const i=this.accumulatedUpdates[n].variable;tidy((()=>{const e=add(mul(o,this.rho),mul(square(a),1-this.rho));const t=mul(div(sqrt(add(i,this.epsilon)),sqrt(add(o,this.epsilon))),a);const n=add(mul(i,this.rho),mul(square(t),1-this.rho));o.assign(e);i.assign(n);const s=add(mul(t,-this.learningRate),r);r.assign(s);}));}));this.incrementIterations();}dispose(){if(this.accumulatedUpdates!=null){dispose(this.accumulatedGrads.map((e=>e.variable)));dispose(this.accumulatedUpdates.map((e=>e.variable)));}}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return [await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2;const n=false;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})));this.accumulatedUpdates=e.slice(t,t*2).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})));}getConfig(){return {learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t["learningRate"],t["rho"],t["epsilon"])}}AdadeltaOptimizer.className="Adadelta";registerClass(AdadeltaOptimizer);
class AdagradOptimizer extends Optimizer{constructor(e,t=.1){super();this.learningRate=e;this.initialAccumulatorValue=t;this.accumulatedGrads=[];}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=ENGINE.registeredVariables[t];if(this.accumulatedGrads[n]==null){const e=false;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:tidy((()=>fill$1(r.shape,this.initialAccumulatorValue).variable(e)))};}const s=Array.isArray(e)?e[n].tensor:e[t];if(s==null){return}const a=this.accumulatedGrads[n].variable;tidy((()=>{const e=add(a,square(s));a.assign(e);const t=add(mul(div(s,sqrt(add(e,ENGINE.backend.epsilon()))),-this.learningRate),r);r.assign(t);}));}));this.incrementIterations();}dispose(){if(this.accumulatedGrads!=null){dispose(this.accumulatedGrads.map((e=>e.variable)));}}async getWeights(){return [await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=false;this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(t)})));}getConfig(){return {learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t["learningRate"],t["initialAccumulatorValue"])}}AdagradOptimizer.className="Adagrad";registerClass(AdagradOptimizer);
class AdamOptimizer extends Optimizer{constructor(e,t,n,r=null){super();this.learningRate=e;this.beta1=t;this.beta2=n;this.epsilon=r;this.accumulatedFirstMoment=[];this.accumulatedSecondMoment=[];tidy((()=>{this.accBeta1=scalar(t).variable();this.accBeta2=scalar(n).variable();}));if(r==null){this.epsilon=ENGINE.backend.epsilon();}}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);tidy((()=>{const n=sub(1,this.accBeta1);const r=sub(1,this.accBeta2);t.forEach(((t,s)=>{const a=ENGINE.registeredVariables[t];const o=false;if(this.accumulatedFirstMoment[s]==null){this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:tidy((()=>zerosLike(a).variable(o)))};}if(this.accumulatedSecondMoment[s]==null){this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:tidy((()=>zerosLike(a).variable(o)))};}const i=Array.isArray(e)?e[s].tensor:e[t];if(i==null){return}const c=this.accumulatedFirstMoment[s].variable;const u=this.accumulatedSecondMoment[s].variable;const l=add(mul(c,this.beta1),mul(i,1-this.beta1));const p=add(mul(u,this.beta2),mul(square(i),1-this.beta2));const d=div(l,n);const h=div(p,r);c.assign(l);u.assign(p);const m=add(mul(div(d,add(sqrt(h),this.epsilon)),-this.learningRate),a);a.assign(m);}));this.accBeta1.assign(mul(this.accBeta1,this.beta1));this.accBeta2.assign(mul(this.accBeta2,this.beta2));}));this.incrementIterations();}dispose(){this.accBeta1.dispose();this.accBeta2.dispose();if(this.accumulatedFirstMoment!=null){dispose(this.accumulatedFirstMoment.map((e=>e.variable)));}if(this.accumulatedSecondMoment!=null){dispose(this.accumulatedSecondMoment.map((e=>e.variable)));}}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return [await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);tidy((()=>{this.accBeta1.assign(pow$1(this.beta1,this.iterations_+1));this.accBeta2.assign(pow$1(this.beta2,this.iterations_+1));}));const t=e.length/2;const n=false;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})));this.accumulatedSecondMoment=e.slice(t,t*2).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})));}getConfig(){return {learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t["learningRate"],t["beta1"],t["beta2"],t["epsilon"])}}AdamOptimizer.className="Adam";registerClass(AdamOptimizer);
class AdamaxOptimizer extends Optimizer{constructor(e,t,n,r=null,s=0){super();this.learningRate=e;this.beta1=t;this.beta2=n;this.epsilon=r;this.decay=s;this.accumulatedFirstMoment=[];this.accumulatedWeightedInfNorm=[];tidy((()=>{this.iteration=scalar(0).variable();this.accBeta1=scalar(t).variable();}));if(r==null){this.epsilon=ENGINE.backend.epsilon();}}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);tidy((()=>{const n=sub(1,this.accBeta1);const r=div(-this.learningRate,add(mul(this.iteration,this.decay),1));t.forEach(((t,s)=>{const a=ENGINE.registeredVariables[t];const o=false;if(this.accumulatedFirstMoment[s]==null){this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:zerosLike(a).variable(o)};}if(this.accumulatedWeightedInfNorm[s]==null){this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:zerosLike(a).variable(o)};}const i=Array.isArray(e)?e[s].tensor:e[t];if(i==null){return}const c=this.accumulatedFirstMoment[s].variable;const u=this.accumulatedWeightedInfNorm[s].variable;const l=add(mul(c,this.beta1),mul(i,1-this.beta1));const p=mul(u,this.beta2);const d=abs(i);const h=maximum(p,d);c.assign(l);u.assign(h);const m=add(mul(div(r,n),div(l,add(h,this.epsilon))),a);a.assign(m);}));this.iteration.assign(add(this.iteration,1));this.accBeta1.assign(mul(this.accBeta1,this.beta1));}));this.incrementIterations();}dispose(){this.accBeta1.dispose();this.iteration.dispose();if(this.accumulatedFirstMoment!=null){dispose(this.accumulatedFirstMoment.map((e=>e.variable)));}if(this.accumulatedWeightedInfNorm!=null){dispose(this.accumulatedWeightedInfNorm.map((e=>e.variable)));}}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return {learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t["learningRate"],t["beta1"],t["beta2"],t["epsilon"],t["decay"])}}AdamaxOptimizer.className="Adamax";registerClass(AdamaxOptimizer);
class SGDOptimizer extends Optimizer{constructor(e){super();this.learningRate=e;this.setLearningRate(e);}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(r==null){return}const s=ENGINE.registeredVariables[t];tidy((()=>{const e=add(mul(this.c,r),s);s.assign(e);}));}));this.incrementIterations();}setLearningRate(e){this.learningRate=e;if(this.c!=null){this.c.dispose();}this.c=keep(scalar(-e));}dispose(){this.c.dispose();}async getWeights(){return [await this.saveIterations()]}async setWeights(e){e=await this.extractIterations(e);if(e.length!==0){throw new Error("SGD optimizer does not have settable weights.")}}getConfig(){return {learningRate:this.learningRate}}static fromConfig(e,t){return new e(t["learningRate"])}}SGDOptimizer.className="SGD";registerClass(SGDOptimizer);
class MomentumOptimizer extends SGDOptimizer{constructor(e,t,n=false){super(e);this.learningRate=e;this.momentum=t;this.useNesterov=n;this.accumulations=[];this.m=scalar(this.momentum);}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=ENGINE.registeredVariables[t];if(this.accumulations[n]==null){const e=false;this.accumulations[n]={originalName:`${t}/momentum`,variable:tidy((()=>zerosLike(r).variable(e)))};}const s=this.accumulations[n].variable;const a=Array.isArray(e)?e[n].tensor:e[t];if(a==null){return}tidy((()=>{let e;const t=add(mul(this.m,s),a);if(this.useNesterov){e=add(mul(this.c,add(a,mul(t,this.m))),r);}else {e=add(mul(this.c,t),r);}s.assign(t);r.assign(e);}));}));this.incrementIterations();}dispose(){this.m.dispose();if(this.accumulations!=null){dispose(this.accumulations.map((e=>e.variable)));}}setMomentum(e){this.momentum=e;}async getWeights(){return [await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=false;this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(t)})));}getConfig(){return {learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t["learningRate"],t["momentum"],t["useNesterov"])}}MomentumOptimizer.className="Momentum";registerClass(MomentumOptimizer);
class RMSPropOptimizer extends Optimizer{constructor(e,t=.9,n=0,r=null,s=false){super();this.learningRate=e;this.decay=t;this.momentum=n;this.epsilon=r;this.accumulatedMeanSquares=[];this.accumulatedMoments=[];this.accumulatedMeanGrads=[];this.centered=s;if(r==null){this.epsilon=ENGINE.backend.epsilon();}if(e==null){throw new Error(`learningRate for RMSPropOptimizer must be defined.`)}}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=ENGINE.registeredVariables[t];const s=false;if(this.accumulatedMeanSquares[n]==null){this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:tidy((()=>zerosLike(r).variable(s)))};}if(this.accumulatedMoments[n]==null){this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:tidy((()=>zerosLike(r).variable(s)))};}if(this.accumulatedMeanGrads[n]==null&&this.centered){this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:tidy((()=>zerosLike(r).variable(s)))};}const a=Array.isArray(e)?e[n].tensor:e[t];if(a==null){return}const o=this.accumulatedMeanSquares[n].variable;const i=this.accumulatedMoments[n].variable;tidy((()=>{const e=add(mul(o,this.decay),mul(square(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable;const s=add(mul(t,this.decay),mul(a,1-this.decay));const c=div(mul(a,this.learningRate),sqrt(sub(e,add(square(s),this.epsilon))));const u=add(mul(i,this.momentum),c);o.assign(e);t.assign(s);i.assign(u);const l=sub(r,u);r.assign(l);}else {const e=add(mul(o,this.decay),mul(square(a),1-this.decay));const t=add(mul(i,this.momentum),div(mul(a,this.learningRate),sqrt(add(e,this.epsilon))));o.assign(e);i.assign(t);const n=sub(r,t);r.assign(n);}}));}));this.incrementIterations();}dispose(){if(this.accumulatedMeanSquares!=null){dispose(this.accumulatedMeanSquares.map((e=>e.variable)));}if(this.accumulatedMeanGrads!=null&&this.centered){dispose(this.accumulatedMeanGrads.map((e=>e.variable)));}if(this.accumulatedMoments!=null){dispose(this.accumulatedMoments.map((e=>e.variable)));}}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];if(this.centered){e.push(...this.accumulatedMeanGrads);}return [await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2;const n=false;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})));this.accumulatedMoments=e.slice(t,t*2).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})));if(this.centered){this.accumulatedMeanGrads=e.slice(t*2,t*3).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})));}}getConfig(){return {learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t["learningRate"],t["decay"],t["momentum"],t["epsilon"],t["centered"])}}RMSPropOptimizer.className="RMSProp";registerClass(RMSPropOptimizer);
(()=>{if(typeof requestAnimationFrame!=="undefined"){return requestAnimationFrame}else if(typeof setImmediate!=="undefined"){return setImmediate}return e=>e()})();
function assertParamsConsistent(e,t){const n=e[0].length;e.forEach(((e,t)=>{assert(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same `+`as the rank of the rest (${n})`));}));assert(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,s)=>{for(let a=0;a<n;a++){assert(a===t||e[a]===r[a],(()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) `+`does not match the shape of the rest (${r}) `+`along the non-concatenated axis ${s}.`));}}));}function computeOutShape$1(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++){n[t]+=e[r][t];}return n}
const PARALLELIZE_THRESHOLD=30;function computeOptimalWindowSize(e){if(e<=PARALLELIZE_THRESHOLD){return e}return nearestDivisor(e,Math.floor(Math.sqrt(e)))}
const SELU_SCALEALPHA=1.7580993408473768;const SELU_SCALE=1.0507009873554805;
const ERF_P=.3275911;const ERF_A1=.254829592;const ERF_A2=-.284496736;const ERF_A3=1.421413741;const ERF_A4=-1.453152027;const ERF_A5=1.061405429;
function collectGatherOpShapeInfo(e,t,n,r){const s=t.shape.length;const a=e.shape.length;if(r!==0){if(r<-s||r>s){throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`)}}if(r<0){r+=s;}if(r>a){throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`)}if(n<r){throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`)}for(let n=0;n<r;++n){if(e.shape[n]!==t.shape[n]){throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`)}}const o=e.shape[n];const i=[];let c=1;let u=1;let l=1;for(let t=0;t<r;++t){i.push(e.shape[t]);c*=e.shape[t];}for(let t=r;t<n;t++){i.push(e.shape[t]);u*=e.shape[t];}for(let e=r;e<s;e++){i.push(t.shape[e]);}for(let t=n+1;t<a;t++){i.push(e.shape[t]);l*=e.shape[t];}return {batchSize:c,sliceSize:l,outerSize:u,dimSize:o,outputShape:i}}var segment_util=Object.freeze({__proto__:null,segOpComputeOptimalWindowSize:()=>{},computeOutShape$2:()=>{},collectGatherOpShapeInfo:collectGatherOpShapeInfo});
var backend_util=Object.freeze({__proto__:null,slice_util:slice_util,segment_util:segment_util,fromUint8ToStringArray:()=>{},fromStringArrayToUint8:()=>{},upcastType:upcastType,axesAreInnerMostDims:axesAreInnerMostDims,combineLocations:()=>{},computeOutAndReduceShapes:computeOutAndReduceShapes,expandShapeToKeepDim:expandShapeToKeepDim,assertAxesAreInnerMostDims:assertAxesAreInnerMostDims,getAxesPermutation:getAxesPermutation,getUndoAxesPermutation:()=>{},getInnerMostAxes:getInnerMostAxes,getBroadcastDims:getBroadcastDims$1,getReductionAxes:getReductionAxes,assertAndGetBroadcastShape:assertAndGetBroadcastShape,assertParamsConsistent:assertParamsConsistent,computeOutShape$2:()=>{},computeDilation2DInfo:()=>{},computePool2DInfo:computePool2DInfo,computePool3DInfo:()=>{},computeConv2DInfo:computeConv2DInfo,computeConv3DInfo:()=>{},computeDefaultPad:()=>{},tupleValuesAreOne:()=>{},eitherStridesOrDilationsAreOne:()=>{},convertConv2DDataFormat:convertConv2DDataFormat,checkPadOnDimRoundingMode:()=>{},getFusedDyActivation:getFusedDyActivation,getFusedBiasGradient:getFusedBiasGradient,applyActivation:()=>{},shouldFuse:shouldFuse,PARALLELIZE_THRESHOLD:PARALLELIZE_THRESHOLD,computeOptimalWindowSize:computeOptimalWindowSize,getImageCenter:()=>{},getReshaped:()=>{},getPermuted:()=>{},getReshapedPermuted:()=>{},getSliceBeginCoords:()=>{},getSliceSize:()=>{},prepareAndValidate:()=>{},validateUpdateShape:()=>{},validateInput:validateInput$1,calculateShapes:()=>{},SELU_SCALEALPHA:SELU_SCALEALPHA,SELU_SCALE:SELU_SCALE,ERF_P:ERF_P,ERF_A1:ERF_A1,ERF_A2:ERF_A2,ERF_A3:ERF_A3,ERF_A4:ERF_A4,ERF_A5:ERF_A5,warn:warn,log:log$1,mergeRealAndImagArrays:()=>{},splitRealAndImagArrays:()=>{},complexWithEvenIndex:()=>{},complexWithOddIndex:()=>{},getComplexWithIndex:()=>{},assignToTypedArray:()=>{},exponents:()=>{},exponent:()=>{},decodeEinsumEquation:()=>{},getEinsumPermutation:()=>{},checkEinsumDimSizes:()=>{},getEinsumComputePath:()=>{},isIdentityPermutation:()=>{},prepareSplitSize:()=>{},getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>{},getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>{},getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>{},getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>{},getSparseReshapeNegativeOutputDimErrorMessage:()=>{},getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>{},getSparseReshapeInputOutputMultipleErrorMessage:()=>{},getSparseReshapeInputOutputMismatchErrorMessage:()=>{},getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>{},getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>{},getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>{},getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>{}});
const ENV$1=env();ENV$1.registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>false),(e=>{if(e){console.warn("Keep intermediate tensors is ON. This will print the values of all "+"intermediate tensors during model inference. Not all models "+"support this mode. For details, check e2e/benchmarks/ "+"model_config.js. This significantly impacts performance.");}}));
var DataType;(function(e){e[e["DT_INVALID"]=0]="DT_INVALID";e[e["DT_FLOAT"]=1]="DT_FLOAT";e[e["DT_DOUBLE"]=2]="DT_DOUBLE";e[e["DT_INT32"]=3]="DT_INT32";e[e["DT_UINT8"]=4]="DT_UINT8";e[e["DT_INT16"]=5]="DT_INT16";e[e["DT_INT8"]=6]="DT_INT8";e[e["DT_STRING"]=7]="DT_STRING";e[e["DT_COMPLEX64"]=8]="DT_COMPLEX64";e[e["DT_INT64"]=9]="DT_INT64";e[e["DT_BOOL"]=10]="DT_BOOL";e[e["DT_QINT8"]=11]="DT_QINT8";e[e["DT_QUINT8"]=12]="DT_QUINT8";e[e["DT_QINT32"]=13]="DT_QINT32";e[e["DT_BFLOAT16"]=14]="DT_BFLOAT16";e[e["DT_QINT16"]=15]="DT_QINT16";e[e["DT_QUINT16"]=16]="DT_QUINT16";e[e["DT_UINT16"]=17]="DT_UINT16";e[e["DT_COMPLEX128"]=18]="DT_COMPLEX128";e[e["DT_HALF"]=19]="DT_HALF";e[e["DT_RESOURCE"]=20]="DT_RESOURCE";e[e["DT_VARIANT"]=21]="DT_VARIANT";e[e["DT_UINT32"]=22]="DT_UINT32";e[e["DT_UINT64"]=23]="DT_UINT64";e[e["DT_FLOAT_REF"]=101]="DT_FLOAT_REF";e[e["DT_DOUBLE_REF"]=102]="DT_DOUBLE_REF";e[e["DT_INT32_REF"]=103]="DT_INT32_REF";e[e["DT_UINT8_REF"]=104]="DT_UINT8_REF";e[e["DT_INT16_REF"]=105]="DT_INT16_REF";e[e["DT_INT8_REF"]=106]="DT_INT8_REF";e[e["DT_STRING_REF"]=107]="DT_STRING_REF";e[e["DT_COMPLEX64_REF"]=108]="DT_COMPLEX64_REF";e[e["DT_INT64_REF"]=109]="DT_INT64_REF";e[e["DT_BOOL_REF"]=110]="DT_BOOL_REF";e[e["DT_QINT8_REF"]=111]="DT_QINT8_REF";e[e["DT_QUINT8_REF"]=112]="DT_QUINT8_REF";e[e["DT_QINT32_REF"]=113]="DT_QINT32_REF";e[e["DT_BFLOAT16_REF"]=114]="DT_BFLOAT16_REF";e[e["DT_QINT16_REF"]=115]="DT_QINT16_REF";e[e["DT_QUINT16_REF"]=116]="DT_QUINT16_REF";e[e["DT_UINT16_REF"]=117]="DT_UINT16_REF";e[e["DT_COMPLEX128_REF"]=118]="DT_COMPLEX128_REF";e[e["DT_HALF_REF"]=119]="DT_HALF_REF";e[e["DT_RESOURCE_REF"]=120]="DT_RESOURCE_REF";e[e["DT_VARIANT_REF"]=121]="DT_VARIANT_REF";e[e["DT_UINT32_REF"]=122]="DT_UINT32_REF";e[e["DT_UINT64_REF"]=123]="DT_UINT64_REF";})(DataType||(DataType={}));var SaverDef;(function(e){(function(e){e[e["LEGACY"]=0]="LEGACY";e[e["V1"]=1]="V1";e[e["V2"]=2]="V2";})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}));})(SaverDef||(SaverDef={}));
const CUSTOM_OPS={};function getRegisteredOp(e){return CUSTOM_OPS[e]}
function getParamValue(e,t,n,r,s){const a=t.inputParams[e];if(a&&a.inputIndexStart!==undefined){const e=a.inputIndexStart;const o=a.inputIndexEnd===0?undefined:a.inputIndexEnd===undefined?e+1:a.inputIndexEnd;if(a.type==="tensor"){return getTensor(t.inputNames[a.inputIndexStart],n,r,s)}if(a.type==="tensors"){const a=t.inputNames.slice(e,o);return a.map((e=>getTensor(e,n,r,s)))}const i=getTensor(t.inputNames.slice(e)[0],n,r,s);const c=i.dataSync();return a.type==="number"?c[0]:toNestedArray(i.shape,c)}const o=t.attrParams[e];return o&&o.value}function getTensor(e,t,n,r){const[s,a]=parseNodeName(e);if(r!=null){const e=r.getHashTableHandleByName(s);if(e!=null){return e}}const o=n.currentContextIds.find((e=>!!t[getNodeNameWithContextId(s,e)]));return o!==undefined?t[getNodeNameWithContextId(s,o)][a]:undefined}function getTensorsForCurrentContenxt(e,t,n){return t[getNodeNameWithContextId(e,n.currentContextId)]}function getNodeNameAndIndex(e,t){const[n,r,s]=parseNodeName(e);return [getNodeNameWithContextId(n,t&&t.currentContextId),r,s]}function getNodeNameWithContextId(e,t){return !!t?`${e}-${t}`:e}function parseNodeName(e){const t=e.split(":");if(t.length===1){return [e,0,undefined]}const n=t[0];const r=t.length===3?t[1]:undefined;const s=Number(t[t.length-1]);return [n,s,r]}function getPadding(e,t,n){let r=getParamValue("pad",e,t,n);if(r==="explicit"){r=getParamValue("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++){s[e][0]=r[e*2];s[e][1]=r[e*2+1];}return s}return r}function cloneTensor(e){return e.kept?e:clone(e)}
const json$i=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]}];var arithmetic=Object.freeze({__proto__:null,json:json$i});
const json$h=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:true}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:true}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:true},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]}];var basicMath=Object.freeze({__proto__:null,json:json$h});
const json$g=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:true}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var control=Object.freeze({__proto__:null,json:json$g});
const json$f=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:true},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:true},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:true}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var convolution=Object.freeze({__proto__:null,json:json$f});
const json$e=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:true},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:true},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:true}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:true},{tfName:"T",name:"T",type:"number",notSupported:true}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:true},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:true}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var creation=Object.freeze({__proto__:null,json:json$e});
const json$d=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:true},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]}];var dynamic=Object.freeze({__proto__:null,json:json$d});
const json$c=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var evaluation=Object.freeze({__proto__:null,json:json$c});
const json$b=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:true},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var graph=Object.freeze({__proto__:null,json:json$b});
const json$a=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:true},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:true}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:true},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:true}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:true},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:true}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:true},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:true}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var hashTable=Object.freeze({__proto__:null,json:json$a});
const json$9=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var image=Object.freeze({__proto__:null,json:json$9});
const json$8=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]}];var logical=Object.freeze({__proto__:null,json:json$8});
const json$7=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:false},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:false},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:false},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:false},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:false},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:false},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:false},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:false},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var matrices=Object.freeze({__proto__:null,json:json$7});
const json$6=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:false}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:true,notSupported:true}]}];var normalization=Object.freeze({__proto__:null,json:json$6});
const json$5=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var reduction=Object.freeze({__proto__:null,json:json$5});
const json$4=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:true}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:true}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:false,notSupported:true}]}];var sliceJoin=Object.freeze({__proto__:null,json:json$4});
const json$3=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var sparse=Object.freeze({__proto__:null,json:json$3});
const json$2=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:true}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:true}]}];var spectral=Object.freeze({__proto__:null,json:json$2});
const json$1=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var string=Object.freeze({__proto__:null,json:json$1});
const json=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:true},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var transformation=Object.freeze({__proto__:null,json:json});
class OperationMapper{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[arithmetic,basicMath,control,convolution,creation,dynamic,evaluation,graph,hashTable,image,logical,matrices,normalization,reduction,sliceJoin,sparse,spectral,string,transformation];const t=[].concat(...e.map((e=>e.json)));this.opMappers=t.reduce(((e,t)=>{e[t.tfOpName]=t;return e}),{});}transformGraph(e,t={}){const n=e.node;const r=[];const s=[];const a=[];const o=n.reduce(((e,t)=>{e[t.name]=this.mapNode(t);if(t.op.startsWith("Placeholder")){r.push(e[t.name]);}else if(t.op==="Const"){s.push(e[t.name]);}else if(t.input==null||t.input.length===0){a.push(e[t.name]);}return e}),{});let i=[];const c=[];let u={};let l={};if(t!=null){u=this.mapSignatureEntries(t.inputs);l=this.mapSignatureEntries(t.outputs);}const p=Object.keys(o);p.forEach((e=>{const t=o[e];t.inputNames.forEach(((e,n)=>{const[r,,s]=getNodeNameAndIndex(e);const a=o[r];if(a.outputs!=null){const e=a.outputs.indexOf(s);if(e!==-1){const s=`${r}:${e}`;t.inputNames[n]=s;}}t.inputs.push(a);a.children.push(t);}));}));if(Object.keys(l).length===0){p.forEach((e=>{const t=o[e];if(t.children.length===0){c.push(t);}}));}else {Object.keys(l).forEach((e=>{const[t]=getNodeNameAndIndex(e);const n=o[t];if(n!=null){n.signatureKey=l[e];c.push(n);}}));}if(Object.keys(u).length>0){Object.keys(u).forEach((e=>{const[t]=getNodeNameAndIndex(e);const n=o[t];if(n){n.signatureKey=u[e];i.push(n);}}));}else {i=r;}let d={};if(e.library!=null&&e.library.function!=null){d=e.library.function.reduce(((e,t)=>{e[t.signature.name]=this.mapFunction(t);return e}),{});}const h={nodes:o,inputs:i,outputs:c,weights:s,placeholders:r,signature:t,functions:d};if(a.length>0){h.initNodes=a;}return h}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>{t[e[n].name]=n;return t}),{})}mapNode(e){const t=getRegisteredOp(e.op)||this.opMappers[e.op]||{};if(e.attr==null){e.attr={};}const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};if(t.inputs!=null){n.inputParams=t.inputs.reduce(((e,t)=>{e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end};return e}),{});}if(t.attrs!=null){n.attrParams=t.attrs.reduce(((t,n)=>{const r=n.type;let s=undefined;switch(n.type){case"string":s=getStringParam(e.attr,n.tfName,n.defaultValue);if(s===undefined&&!!n.tfDeprecatedName){s=getStringParam(e.attr,n.tfDeprecatedName,n.defaultValue);}break;case"string[]":s=getStringArrayParam(e.attr,n.tfName,n.defaultValue);if(s===undefined&&!!n.tfDeprecatedName){s=getStringArrayParam(e.attr,n.tfDeprecatedName,n.defaultValue);}break;case"number":s=getNumberParam(e.attr,n.tfName,n.defaultValue||0);if(s===undefined&&!!n.tfDeprecatedName){s=getNumberParam(e.attr,n.tfDeprecatedName,n.defaultValue);}break;case"number[]":s=getNumericArrayParam(e.attr,n.tfName,n.defaultValue);if(s===undefined&&!!n.tfDeprecatedName){s=getNumericArrayParam(e.attr,n.tfDeprecatedName,n.defaultValue);}break;case"bool":s=getBoolParam(e.attr,n.tfName,n.defaultValue);if(s===undefined&&!!n.tfDeprecatedName){s=getBoolParam(e.attr,n.tfDeprecatedName,n.defaultValue);}break;case"bool[]":s=getBoolArrayParam(e.attr,n.tfName,n.defaultValue);if(s===undefined&&!!n.tfDeprecatedName){s=getBoolArrayParam(e.attr,n.tfDeprecatedName,n.defaultValue);}break;case"shape":s=getTensorShapeParam(e.attr,n.tfName,n.defaultValue);if(s===undefined&&!!n.tfDeprecatedName){s=getTensorShapeParam(e.attr,n.tfDeprecatedName,n.defaultValue);}break;case"shape[]":s=getTensorShapeArrayParam(e.attr,n.tfName,n.defaultValue);if(s===undefined&&!!n.tfDeprecatedName){s=getTensorShapeArrayParam(e.attr,n.tfDeprecatedName,n.defaultValue);}break;case"dtype":s=getDtypeParam(e.attr,n.tfName,n.defaultValue);if(s===undefined&&!!n.tfDeprecatedName){s=getDtypeParam(e.attr,n.tfDeprecatedName,n.defaultValue);}break;case"dtype[]":s=getDtypeArrayParam(e.attr,n.tfName,n.defaultValue);if(s===undefined&&!!n.tfDeprecatedName){s=getDtypeArrayParam(e.attr,n.tfDeprecatedName,n.defaultValue);}break;case"func":s=getFuncParam(e.attr,n.tfName,n.defaultValue);if(s===undefined&&!!n.tfDeprecatedName){s=getFuncParam(e.attr,n.tfDeprecatedName,n.defaultValue);}break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}t[n.name]={value:s,type:r};return t}),{});}return n}mapFunction(e){const t=e.nodeDef;const n=[];const r=[];let s={};if(t!=null){s=t.reduce(((e,t)=>{e[t.name]=this.mapNode(t);if(t.op==="Const"){r.push(e[t.name]);}return e}),{});}const a=[];const o=[];e.signature.inputArg.forEach((e=>{const[t]=getNodeNameAndIndex(e.name);const n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:parseDtypeParam(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name;a.push(n);s[t]=n;}));const i=Object.keys(s);i.forEach((e=>{const t=s[e];t.inputNames.forEach(((e,n)=>{const[r,,a]=getNodeNameAndIndex(e);const o=s[r];if(o.outputs!=null){const e=o.outputs.indexOf(a);if(e!==-1){const s=`${r}:${e}`;t.inputNames[n]=s;}}t.inputs.push(o);o.children.push(t);}));}));const c=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=getNodeNameAndIndex(c[e.name]);const r=s[t];if(r!=null){r.defaultOutput=n;o.push(r);}}));const u=this.mapArgsToSignature(e);return {nodes:s,inputs:a,outputs:o,weights:r,placeholders:n,signature:u}}mapArgsToSignature(e){return {methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>{e[t.name]=this.mapArgToTensorInfo(t);return e}),{}),outputs:e.signature.outputArg.reduce(((t,n)=>{t[n.name]=this.mapArgToTensorInfo(n,e.ret);return t}),{})}}mapArgToTensorInfo(e,t){let n=e.name;if(t!=null){n=t[n];}return {name:n,dtype:e.type}}}function decodeBase64(e){const t=env().global;if(typeof t.atob!=="undefined"){return t.atob(e)}else if(typeof Buffer!=="undefined"){return new Buffer(e,"base64").toString()}else {throw new Error("Unable to decode base64 in this environment. "+"Missing built-in atob() or Buffer()")}}function parseStringParam(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):decodeBase64(e);return t?n:n.toLowerCase()}function getStringParam(e,t,n,r=false){const s=e[t];if(s!=null){return parseStringParam(s.s,r)}return n}function getBoolParam(e,t,n){const r=e[t];return r?r.b:n}function getNumberParam(e,t,n){const r=e[t]||{};const s=r["i"]!=null?r["i"]:r["f"]!=null?r["f"]:n;return typeof s==="number"?s:parseInt(s,10)}function parseDtypeParam(e){if(typeof e==="string"){e=DataType[e];}switch(e){case DataType.DT_FLOAT:case DataType.DT_HALF:return "float32";case DataType.DT_INT32:case DataType.DT_INT64:case DataType.DT_INT8:case DataType.DT_UINT8:return "int32";case DataType.DT_BOOL:return "bool";case DataType.DT_DOUBLE:return "float32";case DataType.DT_STRING:return "string";default:return null}}function getDtypeParam(e,t,n){const r=e[t];if(r&&r.type){return parseDtypeParam(r.type)}return n}function parseTensorShapeParam(e){if(e.unknownRank){return undefined}if(e.dim!=null){return e.dim.map((e=>typeof e.size==="number"?e.size:parseInt(e.size,10)))}return []}function getTensorShapeParam(e,t,n){const r=e[t];if(r&&r.shape){return parseTensorShapeParam(r.shape)}return n}function getStringArrayParam(e,t,n,r=false){const s=e[t];if(s&&s.list&&s.list.s){return s.list.s.map((e=>parseStringParam(e,r)))}return n}
class NodeValueImpl{constructor(e,t,n){this.node=e;this.tensorMap=t;this.context=n;this.inputs=[];this.attrs={};this.inputs=e.inputNames.map((e=>this.getInput(e)));if(e.rawAttrs!=null){this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>{e[t]=this.getAttr(t);return e}),{});}}getInput(e){return getTensor(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(n.tensor!=null){return getTensor(e,this.tensorMap,this.context)}if(n.i!=null||n.f!=null){return getNumberParam(this.node.rawAttrs,e,t)}if(n.s!=null){return getStringParam(this.node.rawAttrs,e,t)}if(n.b!=null){return getBoolParam(this.node.rawAttrs,e,t)}if(n.shape!=null){return getTensorShapeParam(this.node.rawAttrs,e,t)}if(n.type!=null){return getDtypeParam(this.node.rawAttrs,e,t)}if(n.list!=null){if(n.list.i!=null||n.list.f!=null){return getNumericArrayParam(this.node.rawAttrs,e,t)}if(n.list.s!=null){return getStringArrayParam(this.node.rawAttrs,e,t)}if(n.list.shape!=null){return getTensorShapeArrayParam(this.node.rawAttrs,e,t)}if(n.list.b!=null){return getBoolArrayParam(this.node.rawAttrs,e,t)}if(n.list.type!=null){return getDtypeArrayParam(this.node.rawAttrs,e,t)}}return t}}
var tfOps=Object.freeze({__proto__:null,abs:abs,acos_:()=>{},acosh_:()=>{},add:add,addN_:()=>{},all_:()=>{},any_:()=>{},argMax_:()=>{},argMin_:()=>{},asin_:()=>{},asinh_:()=>{},atan_:()=>{},atan_:()=>{},atanh_:()=>{},avgPool_:()=>{},avgPool3d_:()=>{},basicLSTMCell_:()=>{},batchToSpaceND_:()=>{},batchNorm_:()=>{},batchNorm2d_:()=>{},batchNorm3d_:()=>{},batchNorm4d_:()=>{},bincount:bincount,broadcastArgs_:()=>{},broadcastTo:broadcastTo,buffer:buffer,cast:cast$1,ceil_:()=>{},clipByValue_:()=>{},clone:clone,complex:complex$1,concat:concat$1,concat1d_:()=>{},concat2d_:()=>{},concat3d_:()=>{},concat4d_:()=>{},conv1d_:()=>{},conv2d_:()=>{},conv2dTranspose_:()=>{},conv3d_:()=>{},conv3dTranspose_:()=>{},cos_:()=>{},cosh_:()=>{},cumprod_:()=>{},cumsum_:()=>{},denseBincount_:()=>{},depthToSpace_:()=>{},depthwiseConv2d_:()=>{},diag_:()=>{},dilation2d_:()=>{},div:div,divNoNan_:()=>{},dot:dot,einsum_:()=>{},elu_:()=>{},equal:equal,erf_:()=>{},euclideanNorm_:()=>{},exp:exp,expandDims:expandDims$1,expm1_:()=>{},eye_:()=>{},fill$1:()=>{},floor_:()=>{},floorDiv_:()=>{},gather:gather,greater:greater,greaterEqual_:()=>{},imag_:()=>{},isFinite_:()=>{},isInf_:()=>{},isNaN_:()=>{},leakyRelu_:()=>{},less_:()=>{},lessEqual_:()=>{},linspace:()=>{},localResponseNormalization_:()=>{},log:log,log1p:log1p,logSigmoid_:()=>{},logSoftmax_:()=>{},logSumExp:logSumExp,logicalAnd:logicalAnd,logicalNot_:()=>{},logicalOr_:()=>{},logicalXor_:()=>{},lowerBound:()=>{},matMul:matMul$1,max:max,maxPool_:()=>{},maxPool3d_:()=>{},maxPoolWithArgmax_:()=>{},maximum:maximum,mean:mean,meshgrid:()=>{},min_:()=>{},minimum:minimum,mirrorPad_:()=>{},mod_:()=>{},moments_:()=>{},mul:mul,multiRNNCell_:()=>{},multinomial_:()=>{},neg:neg,notEqual:notEqual$1,oneHot:oneHot,ones:ones,onesLike_:()=>{},outerProduct_:()=>{},pad:pad,pad1d_:()=>{},pad2d_:()=>{},pad3d_:()=>{},pad4d_:()=>{},pool_:()=>{},pow_:()=>{},prelu_:()=>{},print:print,prod:prod$1,rand_:()=>{},randomGamma_:()=>{},randomNormal_:()=>{},randomStandardNormal_:()=>{},randomUniform_:()=>{},range:range,real:real$1,reciprocal_:()=>{},relu:relu$1,relu6_:()=>{},reshape:reshape$1,reverse:reverse,reverse1d_:()=>{},reverse2d_:()=>{},reverse3d_:()=>{},reverse4d_:()=>{},round$1:()=>{},rsqrt_:()=>{},scalar:scalar,selu_:()=>{},separableConv2d_:()=>{},setdiff1dAsync_:()=>{},sigmoid:sigmoid$1,sign_:()=>{},sin_:()=>{},sinh_:()=>{},slice:slice$1,slice1d_:()=>{},slice2d_:()=>{},slice3d_:()=>{},slice4d_:()=>{},softmax_:()=>{},softplus_:()=>{},spaceToBatchND_:()=>{},fft:fft,ifft_:()=>{},irfft_:()=>{},rfft_:()=>{},split_:()=>{},sqrt_:()=>{},square:square,squaredDifference:squaredDifference,squeeze:squeeze,stack:stack,step_:()=>{},stridedSlice_:()=>{},sub:sub,sum:sum$1,tan_:()=>{},tanh_:()=>{},tensor:tensor,tensor1d:tensor1d,tensor2d:tensor2d,tensor3d:()=>{},tensor4d:()=>{},tensor5d:()=>{},tensor6d:()=>{},tile_:()=>{},topk_:()=>{},truncatedNormal_:()=>{},unique_:()=>{},unsortedSegmentSum_:()=>{},unstack:unstack,upperBound:()=>{},variable:()=>{},where:where,whereAsync_:()=>{},zeros:zeros$1,zerosLike:zerosLike,op:op,OP_SCOPE_SUFFIX:OP_SCOPE_SUFFIX,booleanMaskAsync_:()=>{},transpose_:()=>{},norm:norm,movingAverage_:()=>{},scatterND_:()=>{},searchSorted_:()=>{},sparseToDense_:()=>{},gatherND_:()=>{},dropout_:()=>{},enclosingPowerOfTwo:()=>{},cosineWindow:()=>{},inTopKAsync_:()=>{},image:image$1,linalg:linalg,losses:losses,spectral:spectral$1,fused:fused_ops,signal:signal,sparse:sparse$1,string:string$1});
const executeOp$j=(e,t,n,r=tfOps)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":{return [r.add(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"AddN":{return [r.addN(getParamValue("tensors",e,t,n))]}case"FloorMod":case"Mod":return [r.mod(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"Mul":return [r.mul(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"RealDiv":case"Div":{return [r.div(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"DivNoNan":{return [r.divNoNan(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"FloorDiv":{return [r.floorDiv(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"Sub":{return [r.sub(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"Minimum":{return [r.minimum(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"Maximum":{return [r.maximum(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"Pow":{return [r.pow(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"SquaredDifference":{return [r.squaredDifference(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$i=(e,t,n,r=tfOps)=>{switch(e.op){case"Abs":case"ComplexAbs":return [r.abs(getParamValue("x",e,t,n))];case"Acos":return [r.acos(getParamValue("x",e,t,n))];case"Acosh":return [r.acosh(getParamValue("x",e,t,n))];case"Asin":return [r.asin(getParamValue("x",e,t,n))];case"Asinh":return [r.asinh(getParamValue("x",e,t,n))];case"Atan":return [r.atan(getParamValue("x",e,t,n))];case"Atan2":return [r.atan2(getParamValue("x",e,t,n),getParamValue("y",e,t,n))];case"Atanh":return [r.atanh(getParamValue("x",e,t,n))];case"Ceil":return [r.ceil(getParamValue("x",e,t,n))];case"Complex":return [r.complex(getParamValue("real",e,t,n),getParamValue("imag",e,t,n))];case"Cos":return [r.cos(getParamValue("x",e,t,n))];case"Cosh":return [r.cosh(getParamValue("x",e,t,n))];case"Elu":return [r.elu(getParamValue("x",e,t,n))];case"Erf":return [r.erf(getParamValue("x",e,t,n))];case"Exp":return [r.exp(getParamValue("x",e,t,n))];case"Expm1":{return [r.expm1(getParamValue("x",e,t,n))]}case"Floor":return [r.floor(getParamValue("x",e,t,n))];case"Log":return [r.log(getParamValue("x",e,t,n))];case"Log1p":{return [r.log1p(getParamValue("x",e,t,n))]}case"Imag":return [r.imag(getParamValue("x",e,t,n))];case"Neg":return [r.neg(getParamValue("x",e,t,n))];case"Reciprocal":{return [r.reciprocal(getParamValue("x",e,t,n))]}case"Real":return [r.real(getParamValue("x",e,t,n))];case"Relu":return [r.relu(getParamValue("x",e,t,n))];case"Round":{return [r.round(getParamValue("x",e,t,n))]}case"Selu":return [r.selu(getParamValue("x",e,t,n))];case"Sigmoid":return [r.sigmoid(getParamValue("x",e,t,n))];case"Sin":return [r.sin(getParamValue("x",e,t,n))];case"Sign":{return [r.sign(getParamValue("x",e,t,n))]}case"Sinh":{return [r.sinh(getParamValue("x",e,t,n))]}case"Softplus":{return [r.softplus(getParamValue("x",e,t,n))]}case"Sqrt":{return [r.sqrt(getParamValue("x",e,t,n))]}case"Square":{return [r.square(getParamValue("x",e,t,n))]}case"Tanh":{return [r.tanh(getParamValue("x",e,t,n))]}case"Tan":return [r.tan(getParamValue("x",e,t,n))];case"ClipByValue":return [r.clipByValue(getParamValue("x",e,t,n),getParamValue("clipValueMin",e,t,n),getParamValue("clipValueMax",e,t,n))];case"Relu6":return [r.relu6(getParamValue("x",e,t,n))];case"Rsqrt":return [r.rsqrt(getTensor(e.inputNames[0],t,n))];case"Prod":return [r.prod(getParamValue("x",e,t,n),getParamValue("axes",e,t,n))];case"LeakyRelu":return [r.leakyRelu(getParamValue("x",e,t,n),getParamValue("alpha",e,t,n))];case"Prelu":return [r.prelu(getParamValue("x",e,t,n),getParamValue("alpha",e,t,n))];case"IsNan":return [r.isNaN(getTensor(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};
function inferElementShape(e,t,n){let r=mergeElementShape(e,n);const s=!fullDefinedShape(r);if(s&&t.length===0){throw new Error(`Tried to calculate elements of an empty list`+` with non-fully-defined elementShape: ${r}`)}if(s){t.forEach((e=>{r=mergeElementShape(e.shape,r);}));}if(!fullDefinedShape(r)){throw new Error(`Non-fully-defined elementShape: ${r}`)}return r}function mergeElementShape(e,t){if(typeof e==="number"){return t}if(typeof t==="number"){return e}if(e.length!==t.length){throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`)}const n=[];for(let r=0;r<e.length;++r){const s=e[r];const a=t[r];if(s>=0&&a>=0&&s!==a){throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`)}n[r]=s>=0?s:a;}return n}
class TensorArray{constructor(e,t,n,r,s,a,o){this.name=e;this.dtype=t;this.maxSize=n;this.elementShape=r;this.identicalElementShapes=s;this.dynamicSize=a;this.clearAfterRead=o;this.tensors=[];this.closed_=false;this.idTensor=scalar(0);keep(this.idTensor);}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{if(e==null||!e.has(t.tensor.id)){t.tensor.dispose();}}));this.tensors=[];this.closed_=true;this.idTensor.dispose();}size(){return this.tensors.length}read(e){if(this.closed_){throw new Error(`TensorArray ${this.name} has already been closed.`)}if(e<0||e>=this.size()){throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`)}const t=this.tensors[e];if(t.cleared){throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read `+`(perhaps try setting clear_after_read = false?).`)}if(this.clearAfterRead){t.cleared=true;}t.read=true;return t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_){throw new Error(`TensorArray ${this.name} has already been closed.`)}if(e<0||!this.dynamicSize&&e>=this.maxSize){throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`)}const n=this.tensors[e]||{};if(t.dtype!==this.dtype){throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`)}if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)){this.elementShape=t.shape;}assertShapesMatchAllowUndefinedSize(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`);if(n.read){throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`)}if(n.written){throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`)}n.tensor=t;keep(t);n.written=true;this.tensors[e]=n;}writeMany(e,t){if(e.length!==t.length){throw new Error(`TensorArray ${this.name}: could not write multiple tensors,`+`because the index size: ${e.length} is not the same as tensors size: ${t.length}.`)}e.forEach(((e,n)=>this.write(e,t[n])));}gather(e,t){if(!!t&&t!==this.dtype){throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`)}if(!e){e=[];for(let t=0;t<this.size();t++){e.push(t);}}else {e=e.slice(0,this.size());}if(e.length===0){return tensor([],[0].concat(this.elementShape))}const n=this.readMany(e);assertShapesMatchAllowUndefinedSize(this.elementShape,n[0].shape,"TensorArray shape mismatch: ");return stack(n,0)}concat(e){if(!!e&&e!==this.dtype){throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`)}if(this.size()===0){return tensor([],[0].concat(this.elementShape))}const t=[];for(let e=0;e<this.size();e++){t.push(e);}const n=this.readMany(t);assertShapesMatchAllowUndefinedSize(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`);return concat$1(n,0)}scatter(e,t){if(t.dtype!==this.dtype){throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`)}if(e.length!==t.shape[0]){throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`)}const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize){throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`)}this.writeMany(e,unstack(t,0));}split(e,t){if(t.dtype!==this.dtype){throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`)}let n=0;const r=e.map((e=>{n+=e;return n}));if(n!==t.shape[0]){throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`)}if(!this.dynamicSize&&e.length!==this.maxSize){throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), `+"and the TensorArray is not marked as dynamically resizeable")}const s=n===0?0:t.size/n;const a=[];tidy((()=>{t=reshape$1(t,[1,n,s]);for(let n=0;n<e.length;++n){const o=n===0?0:r[n-1];const i=[0,o,0];const c=[1,e[n],s];a[n]=reshape$1(slice$1(t,i,c),this.elementShape);}return a}));const o=[];for(let t=0;t<e.length;t++){o[t]=t;}this.writeMany(o,a);}}
class TensorList{constructor(e,t,n,r=-1){this.tensors=e;this.elementShape=t;this.elementDtype=n;if(e!=null){e.forEach((e=>{if(n!==e.dtype){throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`)}assertShapesMatchAllowUndefinedSize(t,e.shape,"TensorList shape mismatch: ");keep(e);}));}this.idTensor=scalar(0);this.maxNumElements=r;keep(this.idTensor);}get id(){return this.idTensor.id}copy(){return new TensorList([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{if(e==null||!e.has(t.id)){t.dispose();}}));this.tensors.length=0;this.idTensor.dispose();}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype){throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`)}if(n!==-1&&this.tensors.length!==n){throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`)}assertShapesMatchAllowUndefinedSize(e,this.elementShape,"TensorList shape mismatch: ");const r=inferElementShape(this.elementShape,this.tensors,e);return tidy((()=>{const e=this.tensors.map((e=>reshape$1(e,r)));return stack(e,0)}))}popBack(e,t){if(t!==this.elementDtype){throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`)}if(this.size()===0){throw new Error("Trying to pop from an empty list.")}const n=inferElementShape(this.elementShape,this.tensors,e);const r=this.tensors.pop();assertShapesMatchAllowUndefinedSize(r.shape,e,"TensorList shape mismatch: ");return reshape$1(r,n)}pushBack(e){if(e.dtype!==this.elementDtype){throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`)}assertShapesMatchAllowUndefinedSize(e.shape,this.elementShape,"TensorList shape mismatch: ");if(this.maxNumElements===this.size()){throw new Error(`Trying to push element into a full list.`)}keep(e);this.tensors.push(e);}resize(e){if(e<0){throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`)}if(this.maxNumElements!==-1&&e>this.maxNumElements){throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`)}const t=new TensorList([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n){t.tensors[n]=this.tensors[n];}return t}getItem(e,t,n){if(n!==this.elementDtype){throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`)}if(e<0||e>this.tensors.length){throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`)}if(this.tensors[e]==null){throw new Error(`element at index ${e} is null.`)}assertShapesMatchAllowUndefinedSize(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=inferElementShape(this.elementShape,this.tensors,t);return reshape$1(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype){throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`)}if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements){throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`)}assertShapesMatchAllowUndefinedSize(this.elementShape,t.shape,"TensorList shape mismatch: ");keep(t);this.tensors[e]=t;}gather(e,t,n){if(t!==this.elementDtype){throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`)}assertShapesMatchAllowUndefinedSize(this.elementShape,n,"TensorList shape mismatch: ");e=e.slice(0,this.size());const r=inferElementShape(this.elementShape,this.tensors,n);if(e.length===0){return tensor([],[0].concat(r))}return tidy((()=>{const t=e.map((e=>reshape$1(this.tensors[e],r)));return stack(t,0)}))}concat(e,t){if(!!e&&e!==this.elementDtype){throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`)}assertShapesMatchAllowUndefinedSize(this.elementShape,t,"TensorList shape mismatch: ");const n=inferElementShape(this.elementShape,this.tensors,t);if(this.size()===0){return tensor([],[0].concat(n))}return tidy((()=>{const e=this.tensors.map((e=>reshape$1(e,n)));return concat$1(e,0)}))}}function fromTensor(e,t,n){const r=e.dtype;if(e.shape.length<1){throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`)}if(e.dtype!==n){throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`)}const s=e.shape.slice(1);assertShapesMatchAllowUndefinedSize(s,t,"TensorList shape mismatch: ");const a=unstack(e);return new TensorList(a,t,r)}function reserve(e,t,n,r){return new TensorList([],e,t,r)}function scatter(e,t,n,r){if(t.length!==e.shape[0]){throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`)}const s=Math.max(...t);if(r!=null&&r!==-1&&s>=r){throw new Error(`Max index must be < array size (${s}  vs. ${r})`)}const a=new TensorList([],n,e.dtype,r);const o=unstack(e,0);t.forEach(((e,t)=>{a.setItem(e,o[t]);}));return a}
const executeOp$h=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=getParamValue("thenBranch",e,t,n);const s=getParamValue("elseBranch",e,t,n);const a=getParamValue("cond",e,t,n);const o=getParamValue("args",e,t,n);const i=await a.data();if(i[0]){return n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}else {return n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}}case"While":case"StatelessWhile":{const r=getParamValue("body",e,t,n);const s=getParamValue("cond",e,t,n);const a=getParamValue("args",e,t,n);const o=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap);const i=a.map((e=>e.id));let c=await o[0].data();o.forEach((e=>{if(!e.kept&&i.indexOf(e.id)===-1){e.dispose();}}));let u=a;while(c[0]){const e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const t=u.map((e=>e.id));e.forEach((e=>{if(!e.kept&&i.indexOf(e.id)===-1&&t.indexOf(e.id)===-1){e.dispose();}}));const a=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);c=await a[0].data();a.forEach((e=>{if(!e.kept&&i.indexOf(e.id)===-1&&t.indexOf(e.id)===-1){e.dispose();}}));}return u}case"LoopCond":{const r=getParamValue("pred",e,t,n);return [cloneTensor(r)]}case"Switch":{const r=getParamValue("pred",e,t,n);let s=getParamValue("data",e,t,n);if(!s.kept){s=cloneTensor(s);}return (await r.data())[0]?[undefined,s]:[s,undefined]}case"Merge":{const r=e.inputNames.find((e=>getTensor(e,t,n)!==undefined));if(r){const e=getTensor(r,t,n);return [cloneTensor(e)]}return undefined}case"Enter":{const r=getParamValue("frameName",e,t,n);const s=getParamValue("tensor",e,t,n);n.enterFrame(r);return [cloneTensor(s)]}case"Exit":{const r=getParamValue("tensor",e,t,n);n.exitFrame();return [cloneTensor(r)]}case"NextIteration":{const r=getParamValue("tensor",e,t,n);n.nextIteration();return [cloneTensor(r)]}case"TensorArrayV3":{const r=getParamValue("size",e,t,n);const s=getParamValue("dtype",e,t,n);const a=getParamValue("elementShape",e,t,n);const o=getParamValue("dynamicSize",e,t,n);const i=getParamValue("clearAfterRead",e,t,n);const c=getParamValue("identicalElementShapes",e,t,n);const u=getParamValue("name",e,t,n);const l=new TensorArray(u,s,r,a,c,o,i);n.addTensorArray(l);return [l.idTensor,scalar(1)]}case"TensorArrayWriteV3":{const r=getParamValue("tensorArrayId",e,t,n);const s=getParamValue("index",e,t,n);const a=getParamValue("tensor",e,t,n);const o=n.getTensorArray(r.id);o.write(s,a);return [o.idTensor]}case"TensorArrayReadV3":{const r=getParamValue("tensorArrayId",e,t,n);const s=getParamValue("index",e,t,n);const a=n.getTensorArray(r.id);return [a.read(s)]}case"TensorArrayGatherV3":{const r=getParamValue("tensorArrayId",e,t,n);const s=getParamValue("indices",e,t,n);const a=getParamValue("dtype",e,t,n);const o=n.getTensorArray(r.id);return [o.gather(s,a)]}case"TensorArrayScatterV3":{const r=getParamValue("tensorArrayId",e,t,n);const s=getParamValue("indices",e,t,n);const a=getParamValue("tensor",e,t,n);const o=n.getTensorArray(r.id);o.scatter(s,a);return [o.idTensor]}case"TensorArrayConcatV3":{const r=getParamValue("tensorArrayId",e,t,n);const s=n.getTensorArray(r.id);const a=getParamValue("dtype",e,t,n);return [s.concat(a)]}case"TensorArraySplitV3":{const r=getParamValue("tensorArrayId",e,t,n);const s=getParamValue("tensor",e,t,n);const a=getParamValue("lengths",e,t,n);const o=n.getTensorArray(r.id);o.split(a,s);return [o.idTensor]}case"TensorArraySizeV3":{const r=getParamValue("tensorArrayId",e,t,n);const s=n.getTensorArray(r.id);return [scalar(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=getParamValue("tensorArrayId",e,t,n);const s=n.getTensorArray(r.id);s.clearAndClose();return [s.idTensor]}case"TensorListSetItem":{const r=getParamValue("tensorListId",e,t,n);const s=getParamValue("index",e,t,n);const a=getParamValue("tensor",e,t,n);const o=n.getTensorList(r.id);o.setItem(s,a);return [o.idTensor]}case"TensorListGetItem":{const r=getParamValue("tensorListId",e,t,n);const s=getParamValue("index",e,t,n);const a=getParamValue("elementShape",e,t,n);const o=getParamValue("elementDType",e,t,n);const i=n.getTensorList(r.id);return [i.getItem(s,a,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=getParamValue("indices",e,t,n);const s=getParamValue("tensor",e,t,n);const a=getParamValue("elementShape",e,t,n);const o=getParamValue("numElements",e,t,n);const i=scatter(s,r,a,o);n.addTensorList(i);return [i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=getParamValue("elementShape",e,t,n);const s=getParamValue("elementDType",e,t,n);let a;if(e.op==="TensorListReserve"){a="numElements";}else {a="maxNumElements";}const o=getParamValue(a,e,t,n);const i=e.op==="TensorListReserve"?-1:o;const c=reserve(r,s,o,i);n.addTensorList(c);return [c.idTensor]}case"TensorListGather":{const r=getParamValue("tensorListId",e,t,n);const s=getParamValue("indices",e,t,n);const a=getParamValue("elementShape",e,t,n);const o=getParamValue("elementDType",e,t,n);const i=n.getTensorList(r.id);return [i.gather(s,o,a)]}case"TensorListStack":{const r=getParamValue("tensorListId",e,t,n);const s=getParamValue("elementShape",e,t,n);const a=getParamValue("elementDType",e,t,n);const o=getParamValue("numElements",e,t,n);const i=n.getTensorList(r.id);return [i.stack(s,a,o)]}case"TensorListFromTensor":{const r=getParamValue("tensor",e,t,n);const s=getParamValue("elementShape",e,t,n);const a=getParamValue("elementDType",e,t,n);const o=fromTensor(r,s,a);n.addTensorList(o);return [o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=getParamValue("tensorListId",e,t,n);const s=n.getTensorList(r.id);const a=getParamValue("dtype",e,t,n);const o=getParamValue("elementShape",e,t,n);return [s.concat(a,o)]}case"TensorListPushBack":{const r=getParamValue("tensorListId",e,t,n);const s=getParamValue("tensor",e,t,n);const a=n.getTensorList(r.id);a.pushBack(s);return [a.idTensor]}case"TensorListPopBack":{const r=getParamValue("tensorListId",e,t,n);const s=getParamValue("elementShape",e,t,n);const a=getParamValue("elementDType",e,t,n);const o=n.getTensorList(r.id);return [o.popBack(s,a)]}case"TensorListSplit":{const r=getParamValue("tensor",e,t,n);const s=getParamValue("elementShape",e,t,n);const a=getParamValue("lengths",e,t,n);const o=split$1(r,a,s);n.addTensorList(o);return [o.idTensor]}case"TensorListLength":{const r=getParamValue("tensorListId",e,t,n);const s=n.getTensorList(r.id);return [scalar(s.size(),"int32")]}case"TensorListResize":{const r=getParamValue("tensorListId",e,t,n);const s=getParamValue("size",e,t,n);const a=n.getTensorList(r.id);const o=a.resize(s);n.addTensorList(o);return [o.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$g=(e,t,n,r=tfOps)=>{switch(e.op){case"Conv1D":{const s=getParamValue("stride",e,t,n);const a=getParamValue("pad",e,t,n);const o=getParamValue("dataFormat",e,t,n).toUpperCase();const i=getParamValue("dilation",e,t,n);return [r.conv1d(getParamValue("x",e,t,n),getParamValue("filter",e,t,n),s,a,o,i)]}case"Conv2D":{const s=getParamValue("strides",e,t,n);const a=getPadding(e,t,n);const o=getParamValue("dataFormat",e,t,n).toUpperCase();const i=getParamValue("dilations",e,t,n);return [r.conv2d(getParamValue("x",e,t,n),getParamValue("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:o,dilations:i,biasArg:c,preluArg:u,activationFunc:l,leakyreluAlpha:p}=fusedConvAndDepthWiseParams(e,t,n);return [r.fused.conv2d({x:getParamValue("x",e,t,n),filter:getParamValue("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:c,activation:l,preluActivationWeights:u,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:o,dilations:i,biasArg:c,preluArg:u,activationFunc:l,leakyreluAlpha:p}=fusedConvAndDepthWiseParams(e,t,n);return [r.fused.depthwiseConv2d({x:getParamValue("x",e,t,n),filter:getParamValue("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:c,activation:l,preluActivationWeights:u,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=getParamValue("outputShape",e,t,n);const a=getParamValue("strides",e,t,n);const o=getPadding(e,t,n);return [r.conv2dTranspose(getParamValue("x",e,t,n),getParamValue("filter",e,t,n),s,[a[1],a[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=getParamValue("strides",e,t,n);const a=getPadding(e,t,n);const o=getParamValue("dilations",e,t,n);const i=getParamValue("dataFormat",e,t,n).toUpperCase();return [r.depthwiseConv2d(getParamValue("input",e,t,n),getParamValue("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"Conv3D":{const s=getParamValue("strides",e,t,n);const a=getParamValue("pad",e,t,n);const o=getParamValue("dataFormat",e,t,n).toUpperCase();const i=getParamValue("dilations",e,t,n);return [r.conv3d(getParamValue("x",e,t,n),getParamValue("filter",e,t,n),[s[1],s[2],s[3]],a,o,[i[1],i[2],i[3]])]}case"AvgPool":{const s=getParamValue("strides",e,t,n);const a=getParamValue("pad",e,t,n);const o=getParamValue("kernelSize",e,t,n);return [r.avgPool(getParamValue("x",e,t,n),[o[1],o[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=getParamValue("strides",e,t,n);const a=getParamValue("pad",e,t,n);const o=getParamValue("kernelSize",e,t,n);return [r.maxPool(getParamValue("x",e,t,n),[o[1],o[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=getParamValue("strides",e,t,n);const a=getParamValue("pad",e,t,n);const o=getParamValue("kernelSize",e,t,n);const i=getParamValue("includeBatchInIndex",e,t,n);const{result:c,indexes:u}=r.maxPoolWithArgmax(getParamValue("x",e,t,n),[o[1],o[2]],[s[1],s[2]],a,i);return [c,u]}case"AvgPool3D":{const s=getParamValue("strides",e,t,n);const a=getParamValue("pad",e,t,n);const o=getParamValue("kernelSize",e,t,n);return [r.avgPool3d(getParamValue("x",e,t,n),[o[1],o[2],o[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=getParamValue("strides",e,t,n);const a=getParamValue("pad",e,t,n);const o=getParamValue("kernelSize",e,t,n);return [r.maxPool3d(getParamValue("x",e,t,n),[o[1],o[2],o[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=getParamValue("strides",e,t,n);const a=getParamValue("pad",e,t,n);const o=getParamValue("dilations",e,t,n);const i=s[1];const c=s[2];const u=o[1];const l=o[2];return [r.dilation2d(getParamValue("x",e,t,n),getParamValue("filter",e,t,n),[i,c],a,[u,l],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$f=(e,t,n,r=tfOps)=>{switch(e.op){case"Fill":{const s=getParamValue("shape",e,t,n);const a=getParamValue("dtype",e,t,n);const o=getParamValue("value",e,t,n);return [r.fill(s,o,a)]}case"LinSpace":{const s=getParamValue("start",e,t,n);const a=getParamValue("stop",e,t,n);const o=getParamValue("num",e,t,n);return [r.linspace(s,a,o)]}case"Multinomial":{const s=getParamValue("logits",e,t,n);const a=getParamValue("numSamples",e,t,n);const o=getParamValue("seed",e,t,n);return [r.multinomial(s,a,o)]}case"OneHot":{const s=getParamValue("indices",e,t,n);const a=getParamValue("depth",e,t,n);const o=getParamValue("onValue",e,t,n);const i=getParamValue("offValue",e,t,n);return [r.oneHot(s,a,o,i)]}case"Ones":{return [r.ones(getParamValue("shape",e,t,n),getParamValue("dtype",e,t,n))]}case"OnesLike":{return [r.onesLike(getParamValue("x",e,t,n))]}case"RandomStandardNormal":{return [r.randomStandardNormal(getParamValue("shape",e,t,n),getParamValue("dtype",e,t,n),getParamValue("seed",e,t,n))]}case"RandomUniform":{return [r.randomUniform(getParamValue("shape",e,t,n),getParamValue("minval",e,t,n),getParamValue("maxval",e,t,n),getParamValue("dtype",e,t,n))]}case"Range":{const s=getParamValue("start",e,t,n);const a=getParamValue("stop",e,t,n);const o=getParamValue("step",e,t,n);return [r.range(s,a,o,getParamValue("dtype",e,t,n))]}case"TruncatedNormal":{const s=getParamValue("shape",e,t,n);const a=getParamValue("mean",e,t,n);const o=getParamValue("stdDev",e,t,n);const i=getParamValue("seed",e,t,n);return [r.truncatedNormal(s,a,o,getParamValue("dtype",e,t,n),i)]}case"Zeros":{return [r.zeros(getParamValue("shape",e,t,n),getParamValue("dtype",e,t,n))]}case"ZerosLike":{return [r.zerosLike(getParamValue("x",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$e=async(e,t,n,r,s=tfOps)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:a,maxOutputSize:o,iouThreshold:i,scoreThreshold:c,softNmsSigma:u}=nmsParams(e,t,n);const l=await s.image.nonMaxSuppressionWithScoreAsync(r,a,o,i,c,u);return [l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:a,maxOutputSize:o,iouThreshold:i,scoreThreshold:c}=nmsParams(e,t,n);const u=getParamValue("padToMaxOutputSize",e,t,n);const l=await s.image.nonMaxSuppressionPaddedAsync(r,a,o,i,c,u);return [l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:a,maxOutputSize:o,iouThreshold:i,scoreThreshold:c}=nmsParams(e,t,n);return [await s.image.nonMaxSuppressionAsync(r,a,o,i,c)]}case"Where":{const r=s.cast(getParamValue("condition",e,t,n),"bool");const a=[await s.whereAsync(r)];r.dispose();return a}case"ListDiff":{return s.setdiff1dAsync(getParamValue("x",e,t,n),getParamValue("y",e,t,n))}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$d=(e,t,n,r=tfOps)=>{switch(e.op){case"LowerBound":{const s=getParamValue("sortedSequence",e,t,n);const a=getParamValue("values",e,t,n);return [r.lowerBound(s,a)]}case"TopKV2":{const s=getParamValue("x",e,t,n);const a=getParamValue("k",e,t,n);const o=getParamValue("sorted",e,t,n);const i=r.topk(s,a,o);return [i.values,i.indices]}case"UpperBound":{const s=getParamValue("sortedSequence",e,t,n);const a=getParamValue("values",e,t,n);return [r.upperBound(s,a)]}case"Unique":{const s=getParamValue("x",e,t,n);const a=r.unique(s);return [a.values,a.indices]}case"UniqueV2":{const s=getParamValue("x",e,t,n);const a=getParamValue("axis",e,t,n);const o=r.unique(s,a);return [o.values,o.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$c=(e,t,n,r=tfOps)=>{switch(e.op){case"Const":{return t[e.name]}case"PlaceholderWithDefault":const s=getParamValue("default",e,t,n);return [getTensor(e.name,t,n)||s];case"Placeholder":return [getTensor(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const r=getParamValue("x",e,t,n);return [cloneTensor(r)]}case"IdentityN":return getParamValue("x",e,t,n).map((e=>cloneTensor(e)));case"Snapshot":const a=getParamValue("x",e,t,n);return [cloneTensor(a)];case"Shape":return [r.tensor1d(getParamValue("x",e,t,n).shape,"int32")];case"ShapeN":return getParamValue("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return [r.scalar(getParamValue("x",e,t,n).size,"int32")];case"Rank":return [r.scalar(getParamValue("x",e,t,n).rank,"int32")];case"NoOp":return [r.scalar(1)];case"Print":const o=getParamValue("x",e,t,n);const i=getParamValue("data",e,t,n);const c=getParamValue("message",e,t,n);const u=getParamValue("summarize",e,t,n);console.warn("The graph has a tf.print() operation,"+"usually used for debugging, which slows down performance.");console.log(c);for(let e=0;e<i.length;e++){console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,u));}return [o];default:throw TypeError(`Node type ${e.op} is not implemented`)}};
class HashTable{constructor(e,t){this.keyDType=e;this.valueDType=t;this.handle=scalar(0);this.tensorMap=new Map;keep(this.handle);}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose()));this.tensorMap.clear();this.handle.dispose();}size(){return this.tensorMap.size}tensorSize(){return scalar(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();this.tensorMap.forEach((e=>e.dispose()));this.tensorMap.clear();return tidy((()=>{const e=unstack(t);const r=n.length;const s=e.length;assert(r===s,(()=>`The number of elements doesn't match, keys has `+`${r} elements, the values has ${s} `+`elements.`));for(let t=0;t<r;t++){const r=n[t];const s=e[t];keep(s);this.tensorMap.set(r,s);}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return tidy((()=>{const e=[];for(let r=0;r<n.length;r++){const s=n[r];const a=this.findWithDefault(s,t);e.push(a);}return stack(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return n!=null?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType){throw new Error(`Expect key dtype ${this.keyDType}, but got `+`${e.dtype}`)}if(t.dtype!==this.valueDType){throw new Error(`Expect value dtype ${this.valueDType}, but got `+`${t.dtype}`)}}}
const executeOp$b=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=getParamValue("keyDType",e,t,n);const a=getParamValue("valueDType",e,t,n);const o=new HashTable(s,a);r.addHashTable(e.name,o);return [o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=getParamValue("tableHandle",e,t,n,r);const a=getParamValue("keys",e,t,n);const o=getParamValue("values",e,t,n);const i=r.getHashTableById(s.id);return [await i.import(a,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=getParamValue("tableHandle",e,t,n,r);const a=getParamValue("keys",e,t,n);const o=getParamValue("defaultValue",e,t,n);const i=r.getHashTableById(s.id);return [await i.find(a,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=getParamValue("tableHandle",e,t,n,r);const a=r.getHashTableById(s.id);return [a.tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$a=(e,t,n,r=tfOps)=>{switch(e.op){case"ResizeBilinear":{const s=getParamValue("images",e,t,n);const a=getParamValue("size",e,t,n);const o=getParamValue("alignCorners",e,t,n);const i=getParamValue("halfPixelCenters",e,t,n);return [r.image.resizeBilinear(s,[a[0],a[1]],o,i)]}case"ResizeNearestNeighbor":{const s=getParamValue("images",e,t,n);const a=getParamValue("size",e,t,n);const o=getParamValue("alignCorners",e,t,n);const i=getParamValue("halfPixelCenters",e,t,n);return [r.image.resizeNearestNeighbor(s,[a[0],a[1]],o,i)]}case"CropAndResize":{const s=getParamValue("image",e,t,n);const a=getParamValue("boxes",e,t,n);const o=getParamValue("boxInd",e,t,n);const i=getParamValue("cropSize",e,t,n);const c=getParamValue("method",e,t,n);const u=getParamValue("extrapolationValue",e,t,n);return [r.image.cropAndResize(s,a,o,i,c,u)]}case"ImageProjectiveTransformV3":{const s=getParamValue("images",e,t,n);const a=getParamValue("transforms",e,t,n);const o=getParamValue("outputShape",e,t,n);const i=getParamValue("fillValue",e,t,n);const c=getParamValue("interpolation",e,t,n);const u=getParamValue("fillMode",e,t,n);return [r.image.transform(s,a,c.toLowerCase(),u.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$9=(e,t,n,r=tfOps)=>{switch(e.op){case"Equal":{return [r.equal(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"NotEqual":{return [r.notEqual(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"Greater":{return [r.greater(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"GreaterEqual":{return [r.greaterEqual(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"Less":{return [r.less(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"LessEqual":{return [r.lessEqual(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"LogicalAnd":{return [r.logicalAnd(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"LogicalNot":{return [r.logicalNot(getParamValue("a",e,t,n))]}case"LogicalOr":{return [r.logicalOr(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"Select":case"SelectV2":{return [r.where(getParamValue("condition",e,t,n),getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$8=(e,t,n,r=tfOps)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return [r.matMul(getParamValue("a",e,t,n),getParamValue("b",e,t,n),getParamValue("transposeA",e,t,n),getParamValue("transposeB",e,t,n))];case"Einsum":return [r.einsum(getParamValue("equation",e,t,n),...getParamValue("tensors",e,t,n))];case"Transpose":return [r.transpose(getParamValue("x",e,t,n),getParamValue("perm",e,t,n))];case"_FusedMatMul":const[s,a]=getParamValue("fusedOps",e,t,n);const o=s==="biasadd";const i=a==="prelu";const c=getParamValue("numArgs",e,t,n);const u=getParamValue("leakyreluAlpha",e,t,n);if(o){if(i&&c!==2){throw new Error("Fused MatMul with BiasAdd and Prelu must have two "+"extra arguments: bias and alpha.")}if(!i&&c!==1){throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}}const[l,p]=getParamValue("args",e,t,n);return [r.fused.matMul({a:getParamValue("a",e,t,n),b:getParamValue("b",e,t,n),transposeA:getParamValue("transposeA",e,t,n),transposeB:getParamValue("transposeB",e,t,n),bias:l,activation:a,preluActivationWeights:p,leakyreluAlpha:u})];default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$7=(e,t,n,r=tfOps)=>{switch(e.op){case"EuclideanNorm":return [r.euclideanNorm(getParamValue("x",e,t,n),getParamValue("axis",e,t,n),getParamValue("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":{return [r.batchNorm(getParamValue("x",e,t,n),getParamValue("mean",e,t,n),getParamValue("variance",e,t,n),getParamValue("offset",e,t,n),getParamValue("scale",e,t,n),getParamValue("epsilon",e,t,n))]}case"FusedBatchNormV3":{return [r.batchNorm(getParamValue("x",e,t,n),getParamValue("mean",e,t,n),getParamValue("variance",e,t,n),getParamValue("offset",e,t,n),getParamValue("scale",e,t,n),getParamValue("epsilon",e,t,n))]}case"LRN":{return [r.localResponseNormalization(getParamValue("x",e,t,n),getParamValue("radius",e,t,n),getParamValue("bias",e,t,n),getParamValue("alpha",e,t,n),getParamValue("beta",e,t,n))]}case"Softmax":{return [r.softmax(getParamValue("x",e,t,n))]}case"LogSoftmax":{return [r.logSoftmax(getParamValue("x",e,t,n))]}case"SparseToDense":{return [r.sparseToDense(getParamValue("sparseIndices",e,t,n),getParamValue("outputShape",e,t,n),getParamValue("sparseValues",e,t,n),getParamValue("defaultValue",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$6=(e,t,n,r=tfOps)=>{switch(e.op){case"Max":{const s=getParamValue("axis",e,t,n);const a=getParamValue("keepDims",e,t,n);return [r.max(getParamValue("x",e,t,n),s,a)]}case"Mean":{const s=getParamValue("axis",e,t,n);const a=getParamValue("keepDims",e,t,n);return [r.mean(getParamValue("x",e,t,n),s,a)]}case"Min":{const s=getParamValue("axis",e,t,n);const a=getParamValue("keepDims",e,t,n);return [r.min(getParamValue("x",e,t,n),s,a)]}case"Sum":{const s=getParamValue("axis",e,t,n);const a=getParamValue("keepDims",e,t,n);return [r.sum(getParamValue("x",e,t,n),s,a)]}case"All":{const s=getParamValue("axis",e,t,n);const a=getParamValue("keepDims",e,t,n);return [r.all(getParamValue("x",e,t,n),s,a)]}case"Any":{const s=getParamValue("axis",e,t,n);const a=getParamValue("keepDims",e,t,n);return [r.any(getParamValue("x",e,t,n),s,a)]}case"ArgMax":{const s=getParamValue("axis",e,t,n);return [r.argMax(getParamValue("x",e,t,n),s)]}case"ArgMin":{const s=getParamValue("axis",e,t,n);return [r.argMin(getParamValue("x",e,t,n),s)]}case"Prod":{const s=getParamValue("axis",e,t,n);const a=getParamValue("keepDims",e,t,n);return [r.prod(getParamValue("x",e,t,n),s,a)]}case"Cumprod":{const s=getParamValue("axis",e,t,n);const a=getParamValue("exclusive",e,t,n);const o=getParamValue("reverse",e,t,n);return [r.cumprod(getParamValue("x",e,t,n),s,a,o)]}case"Cumsum":{const s=getParamValue("axis",e,t,n);const a=getParamValue("exclusive",e,t,n);const o=getParamValue("reverse",e,t,n);return [r.cumsum(getParamValue("x",e,t,n),s,a,o)]}case"Bincount":const s=getParamValue("x",e,t,n);const a=getParamValue("weights",e,t,n);const o=getParamValue("size",e,t,n);return [r.bincount(s,a,o)];case"DenseBincount":{const s=getParamValue("x",e,t,n);const a=getParamValue("weights",e,t,n);const o=getParamValue("size",e,t,n);const i=getParamValue("binaryOutput",e,t,n);return [r.denseBincount(s,a,o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$5=(e,t,n,r=tfOps)=>{switch(e.op){case"ConcatV2":case"Concat":{const s=getParamValue("n",e,t,n);const a=getParamValue("axis",e,t,n);let o=getParamValue("tensors",e,t,n);o=o.slice(0,s);return [r.concat(o,a)]}case"Gather":{const s=getParamValue("x",e,t,n);const a=getParamValue("indices",e,t,n);return [r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=getParamValue("axis",e,t,n);const a=getParamValue("batchDims",e,t,n);const o=getParamValue("x",e,t,n);const i=getParamValue("indices",e,t,n);return [r.gather(o,r.cast(i,"int32"),s,a)]}case"Reverse":{const s=getParamValue("dims",e,t,n);const a=[];for(let e=0;e<s.length;e++){if(s[e]){a.push(e);}}const o=getParamValue("x",e,t,n);return [r.reverse(o,a)]}case"ReverseV2":{const s=getParamValue("axis",e,t,n);const a=getParamValue("x",e,t,n);return [r.reverse(a,s)]}case"Slice":{const s=getParamValue("begin",e,t,n);const a=getParamValue("size",e,t,n);return [r.slice(getParamValue("x",e,t,n),s,a)]}case"StridedSlice":{const s=getParamValue("begin",e,t,n);const a=getParamValue("end",e,t,n);const o=getParamValue("strides",e,t,n);const i=getParamValue("beginMask",e,t,n);const c=getParamValue("endMask",e,t,n);const u=getParamValue("ellipsisMask",e,t,n);const l=getParamValue("newAxisMask",e,t,n);const p=getParamValue("shrinkAxisMask",e,t,n);const d=getParamValue("x",e,t,n);return [r.stridedSlice(d,s,a,o,i,c,u,l,p)]}case"Pack":{return tidy((()=>{const s=getParamValue("axis",e,t,n);const a=getParamValue("tensors",e,t,n);const o=a[0].shape;const i=r.squeeze(a[0]).shape;const c=a.map((e=>{const t=arraysEqual(e.shape,o);if(!t&&!arraysEqual(r.squeeze(e).shape,i)){throw new Error("the input tensors shape does not match")}return t?e:r.reshape(e,o)}));return [r.stack(c,s)]}))}case"Unpack":{const s=getParamValue("axis",e,t,n);const a=getParamValue("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{const s=getParamValue("reps",e,t,n);return [r.tile(getParamValue("x",e,t,n),s)]}case"Split":case"SplitV":{const s=getParamValue("axis",e,t,n);const a=getParamValue("numOrSizeSplits",e,t,n);const o=getParamValue("x",e,t,n);return r.split(o,a,s)}case"ScatterNd":{const s=getParamValue("indices",e,t,n);const a=getParamValue("values",e,t,n);const o=getParamValue("shape",e,t,n);return [r.scatterND(s,a,o)]}case"GatherNd":{const s=getParamValue("x",e,t,n);const a=getParamValue("indices",e,t,n);return [r.gatherND(s,a)]}case"SparseToDense":{const s=getParamValue("sparseIndices",e,t,n);const a=getParamValue("outputShape",e,t,n);const o=getParamValue("sparseValues",e,t,n);const i=getParamValue("defaultValue",e,t,n);return [r.sparseToDense(s,o,a,o.dtype===i.dtype?i:r.cast(i,o.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$4=(e,t,n,r=tfOps)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:o,reverseIndexMap:i}=r.sparse.sparseFillEmptyRows(getParamValue("indices",e,t,n),getParamValue("values",e,t,n),getParamValue("denseShape",e,t,n),getParamValue("defaultValue",e,t,n));return [s,a,o,i]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(getParamValue("inputIndices",e,t,n),getParamValue("inputShape",e,t,n),getParamValue("newShape",e,t,n));return [s,a]}case"SparseSegmentMean":{const s=r.sparse.sparseSegmentMean(getParamValue("data",e,t,n),getParamValue("indices",e,t,n),getParamValue("segmentIds",e,t,n));return [s]}case"SparseSegmentSum":{const s=r.sparse.sparseSegmentSum(getParamValue("data",e,t,n),getParamValue("indices",e,t,n),getParamValue("segmentIds",e,t,n));return [s]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$3=(e,t,n,r=tfOps)=>{switch(e.op){case"FFT":{return [r.fft(getParamValue("x",e,t,n))]}case"IFFT":{return [r.ifft(getParamValue("x",e,t,n))]}case"RFFT":{return [r.rfft(getParamValue("x",e,t,n))]}case"IRFFT":{return [r.irfft(getParamValue("x",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$2=(e,t,n,r=tfOps)=>{switch(e.op){case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(getParamValue("data",e,t,n),getParamValue("dataSplits",e,t,n),getParamValue("separator",e,t,n),getParamValue("nGramWidths",e,t,n),getParamValue("leftPad",e,t,n),getParamValue("rightPad",e,t,n),getParamValue("padWidth",e,t,n),getParamValue("preserveShortSequences",e,t,n));return [s,a]}case"StringSplit":{const{indices:s,values:a,shape:o}=r.string.stringSplit(getParamValue("input",e,t,n),getParamValue("delimiter",e,t,n),getParamValue("skipEmpty",e,t,n));return [s,a,o]}case"StringToHashBucketFast":{const s=r.string.stringToHashBucketFast(getParamValue("input",e,t,n),getParamValue("numBuckets",e,t,n));return [s]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
const executeOp$1=(e,t,n,r=tfOps)=>{switch(e.op){case"Cast":{return [r.cast(getParamValue("x",e,t,n),getParamValue("dtype",e,t,n))]}case"ExpandDims":{const s=getParamValue("axis",e,t,n);return [r.expandDims(getParamValue("x",e,t,n),s)]}case"Squeeze":{const s=getParamValue("axis",e,t,n);return [r.squeeze(getParamValue("x",e,t,n),s)]}case"Reshape":{return [r.reshape(getParamValue("x",e,t,n),getParamValue("shape",e,t,n))]}case"MirrorPad":{return [r.mirrorPad(getParamValue("x",e,t,n),getParamValue("padding",e,t,n),getParamValue("mode",e,t,n))]}case"PadV2":case"Pad":{return [r.pad(getParamValue("x",e,t,n),getParamValue("padding",e,t,n),getParamValue("constantValue",e,t,n))]}case"SpaceToBatchND":{const s=getParamValue("blockShape",e,t,n);const a=getParamValue("paddings",e,t,n);return [r.spaceToBatchND(getParamValue("x",e,t,n),s,a)]}case"BatchToSpaceND":{const s=getParamValue("blockShape",e,t,n);const a=getParamValue("crops",e,t,n);return [r.batchToSpaceND(getParamValue("x",e,t,n),s,a)]}case"DepthToSpace":{const s=getParamValue("blockSize",e,t,n);const a=getParamValue("dataFormat",e,t,n).toUpperCase();return [r.depthToSpace(getParamValue("x",e,t,n),s,a)]}case"BroadcastTo":{return [r.broadcastTo(getParamValue("x",e,t,n),getParamValue("shape",e,t,n))]}case"BroadcastArgs":{return [r.broadcastArgs(getParamValue("s0",e,t,n),getParamValue("s1",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
function executeOp(e,t,n,r,s=tidy){const a=((e,t,n)=>{switch(e.category){case"arithmetic":return s((()=>executeOp$j(e,t,n)));case"basic_math":return s((()=>executeOp$i(e,t,n)));case"control":return executeOp$h(e,t,n);case"convolution":return s((()=>executeOp$g(e,t,n)));case"creation":return s((()=>executeOp$f(e,t,n)));case"dynamic":return executeOp$e(e,t,n);case"evaluation":return s((()=>executeOp$d(e,t,n)));case"image":return s((()=>executeOp$a(e,t,n)));case"graph":return s((()=>executeOp$c(e,t,n)));case"logical":return s((()=>executeOp$9(e,t,n)));case"matrices":return s((()=>executeOp$8(e,t,n)));case"normalization":return s((()=>executeOp$7(e,t,n)));case"reduction":return s((()=>executeOp$6(e,t,n)));case"slice_join":return s((()=>executeOp$5(e,t,n)));case"sparse":return s((()=>executeOp$4(e,t,n)));case"spectral":return s((()=>executeOp$3(e,t,n)));case"string":return s((()=>executeOp$2(e,t,n)));case"transformation":return s((()=>executeOp$1(e,t,n)));case"hash_table":return executeOp$b(e,t,n,r);case"custom":const a=getRegisteredOp(e.op);if(a&&a.customExecutor){return a.customExecutor(new NodeValueImpl(e,t,n))}else {throw TypeError(`Custom op ${e.op} is not registered.`)}default:throw TypeError(`Unknown op '${e.op}'. File an issue at `+`https://github.com/tensorflow/tfjs/issues so we can add it`+`, or register a custom execution with tf.registerOp()`)}})(e,t,n);if(isPromise(a)){return a.then((e=>[].concat(e)))}return [].concat(a)}class ExecutionContext{constructor(e={},t={},n={},r={}){this.weightMap=e;this.tensorArrayMap=t;this.tensorListMap=n;this.functionMap=r;this.rootContext={id:0,frameName:"",iterationId:0};this.contexts=[this.rootContext];this.lastId=0;this.generateCurrentContextIds();}newFrame(e,t){return {id:e,frameName:t,iterationId:0}}set currentContext(e){if(this.contexts!==e){this.contexts=e;this.generateCurrentContextIds();}}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n));}e.push("");this._currentContextIds=e;}contextIdforContexts(e){return e?e.map((e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){if(this.contexts){this.lastId++;this.contexts=this.contexts.slice();this.contexts.push(this.newFrame(this.lastId,e));this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));}}exitFrame(){if(this.contexts&&this.contexts.length>1){this.contexts=this.contexts.slice();this.contexts.splice(-1);this.currentContextIds.shift();}else {throw new Error("Cannot exit frame, the context is empty")}}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice();this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1;e.id=this.lastId;this.contexts.splice(-1,1,e);this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts));}else {throw new Error("Cannot increase frame iteration, the context is empty")}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e;}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e;}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap){this.tensorArrayMap[t].clearAndClose(e);}for(const t in this.tensorListMap){this.tensorListMap[t].clearAndClose(e);}}}
function getExecutionSubgraph(e,t,n,r){const s=new Set;const a=[];let o=null;let i=null;const c=new Set;const u=Object.keys(e).map((e=>parseNodeName(e)[0]));let l=[];if(r!=null){l=r.map((e=>parseNodeName(e.name)[0]));}const p=[...t];while(p.length>0){const e=p.pop();if(isControlFlow(e)||isDynamicShape(e)||isHashTable(e)){if(o==null){o=e;i=o.children.map((e=>e.name)).filter((e=>s.has(e)));}}s.add(e.name);if(n[e.name]!=null){continue}if(u.indexOf(e.name)!==-1){continue}if(l.indexOf(e.name)!==-1){continue}if(e.inputs.length===0){a.push(e.name);continue}e.inputs.forEach((e=>{if(c.has(e.name)){return}c.add(e.name);p.push(e);}));}return {inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:o,syncInputs:i}}function getNodesInTopologicalOrder(e,t,n){const{usedNodes:r,inputs:s}=n;const a=[];const o=Object.keys(s).map((e=>parseNodeName(e)[0])).map((t=>e.nodes[t]));const i=e.initNodes;o.forEach((e=>{if(r.has(e.name)){a.push(e);}}));e.weights.forEach((e=>{if(r.has(e.name)){a.push(e);}}));if(i!=null){i.forEach((e=>{if(r.has(e.name)){a.push(e);}}));}const c=new Set;const u=[];while(a.length>0){const e=a.pop();c.add(e.name);if(!t[e.name]){u.push(e);}e.children.forEach((e=>{if(!c.has(e.name)&&r.has(e.name)&&e.inputs.every((e=>c.has(e.name)))){a.push(e);}}));}return u}const CONTROL_FLOW_OPS=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"];const DYNAMIC_SHAPE_OPS=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"];const HASH_TABLE_OPS=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function isControlFlow(e){return CONTROL_FLOW_OPS.indexOf(e.op)>=0}function isDynamicShape(e){return DYNAMIC_SHAPE_OPS.indexOf(e.op)>=0}function isHashTable(e){return HASH_TABLE_OPS.indexOf(e.op)>=0}
class GraphExecutor{constructor(e,t){this.graph=e;this.parent=t;this.compiledMap=new Map;this._weightMap={};this.SEPERATOR=",";this._functions={};this._functionExecutorMap={};this.intermediateTensors={};this.keepTensorForDebug=false;this._outputs=e.outputs;this._inputs=e.inputs;this._initNodes=e.initNodes;this._signature=e.signature;this._functions=e.functions;if(e.functions!=null){Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new GraphExecutor(e.functions[t],this);}));}}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t);this._weightMap=e;}set resourceManager(e){this._resourceManager=e;}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams["shape"]?e.attrParams["shape"].value:undefined,dtype:e.attrParams["dtype"]?e.attrParams["dtype"].value:undefined})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams["shape"]?e.attrParams["shape"].value:undefined,dtype:e.attrParams["dtype"]?e.attrParams["dtype"].value:undefined})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>{e[t]=this._functions[t].signature;return e}),{})}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort();const r=t.map((e=>e.name)).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){const n=getExecutionSubgraph(e,t,this.weightMap,this._initNodes);const{missingInputs:r,dynamicNode:s,syncInputs:a}=n;if(s!=null){throw new Error(`This execution contains the node '${s.name}', which has `+`the dynamic op '${s.op}'. Please use `+`model.executeAsync() instead. Alternatively, to avoid the `+`dynamic ops, specify the inputs [${a}]`)}if(r.length>0){const n=t.map((e=>e.name));const s=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs `+`[${s}]. Missing the following inputs: [${r}]`)}return getNodesInTopologicalOrder(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e);this.checkInputShapeAndType(e);t=this.mapOutputs(t);this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[parseNodeName(e)[0]]));const s=t.map((e=>parseNodeName(e)[0]));let a=s.map((e=>this.graph.nodes[e]));this.resetIntermediateTensors();if(a.length===0){a=this._outputs;}const o=this.getCompilationKey(r,a);let i=this.compiledMap.get(o);if(i==null){i=this.compile(e,a);this.compiledMap.set(o,i);}const c={};const u={};return tidy((()=>{const n=new ExecutionContext(this.weightMap,c,u,this.functionExecutorMap);const r=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,s]=parseNodeName(t);const a=[];a[s]=e[t];r[n]=a;}));const a=this.getFrozenTensorIds(r);const o={};for(let e=0;e<i.length;e++){const t=i[e];if(!r[t.name]){const e=executeOp(t,r,n,this._resourceManager);if(isPromise(e)){throw new Error(`The execution of the op '${t.op}' returned a promise. `+`Please use model.executeAsync() instead.`)}r[t.name]=e;this.checkTensorForDisposal(t.name,t,r,n,a,s,o);}}if(this.parent==null){n.dispose(a);}return t.map((e=>getTensor(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,a,o){if(t.category==="control"||a.indexOf(e)!==-1){return}n[e].forEach((e=>{if(e!=null){o[e.id]=(o[e.id]||0)+t.children.length;}}));t.inputs.forEach((e=>{if(e.category!=="control"){const a=getTensorsForCurrentContenxt(e.name,n,r);if(a!=null){a.forEach((e=>{if(e&&!e.kept&&!s.has(e.id)){const n=o[e.id];if(n===1){if(!this.keepTensorForDebug){e.dispose();}else {const[n,s]=getNodeNameAndIndex(t.name,r);if(this.intermediateTensors[n]){this.intermediateTensors[n][s]=e;}else {this.intermediateTensors[n]=[];this.intermediateTensors[n][s]=e;}}delete o[e.id];}else if(n!=null){o[e.id]--;}}}));}}}));}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){if(!this.intermediateTensors){return}Object.keys(this.intermediateTensors).forEach((e=>this.intermediateTensors[e].forEach((e=>e.dispose()))));this.disposeTensorsMap();}disposeTensorsMap(){if(!this.tensorsMap){return}Object.keys(this.tensorsMap).forEach((e=>{const t=this.tensorsMap[e];t.forEach((e=>{if(e&&!e.kept&&!e.isDisposed&&!this.keepIds.has(e.id)){e.dispose();}}));}));}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors){this.intermediateTensors[e].forEach((e=>e.dispose()));delete this.intermediateTensors[e];}}async _executeAsync(e,t,n=false,r={},s={}){if(!n){e=this.mapInputs(e);this.checkInputs(e);this.checkInputShapeAndType(e);t=this.mapOutputs(t);this.checkOutputs(t);}try{this.keepTensorForDebug=env().getBool("KEEP_INTERMEDIATE_TENSORS");}catch(e){console.warn(e.message);}this.resetIntermediateTensors();const a=new ExecutionContext(this.weightMap,r,s,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,a,t,n);const o=t.map((e=>getTensor(e,this.tensorsMap,a)));const i=o.map((e=>e.id));const c=Object.keys(e).map((t=>e[t].id));this.keepIds=new Set([...i,...c,...this.weightIds]);if(!this.keepTensorForDebug){this.disposeTensorsMap();}if(this.parent==null){a.dispose(this.keepIds);}return o}async executeFunctionAsync(e,t,n){const r=e.reduce(((e,t,n)=>{e[this.inputs[n].name]=t;return e}),{});return this._executeAsync(r,this.outputNodes,true,t,n)}async executeWithControlFlow(e,t,n,r){const s=Object.keys(e);const a=s.map((e=>this.graph.nodes[parseNodeName(e)[0]]));const o=n.map((e=>parseNodeName(e)[0]));let i=o.map((e=>this.graph.nodes[e]));if(i.length===0){i=this._outputs;}const{usedNodes:c,missingInputs:u,dynamicNode:l,syncInputs:p}=getExecutionSubgraph(e,i,this.weightMap,this._initNodes);const d=[...a,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext})));const h=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=parseNodeName(t);const s=[];s[r]=e[t];h[n]=s;}));const m={};const f=this.getFrozenTensorIds(h);const g={};while(d.length>0){const e=this.processStack(a,d,t,h,g,f,o,m,c);await Promise.all(e);}if(l==null&&!r){console.warn(`This model execution did not contain any nodes with control flow `+`or dynamic output shapes. You can use model.execute() instead.`);}const y=i.filter((e=>!isControlFlow(e)&&!getTensor(e.name,h,t))).map((e=>e.name));if(y.length>0){let e="";if(l!=null){e=`Alternatively, to avoid the dynamic ops, use model.execute() `+`and specify the inputs [${p}]`;}throw new Error(`Cannot compute the outputs [${y}] from the provided `+`inputs [${s}]. Consider providing the following inputs: `+`[${u}]. ${e}`)}return h}processStack(e,t,n,r,s,a,o,i,c){const u=[];while(t.length>0){const e=t.pop();n.currentContext=e.contexts;let l="";if(e.node.op==="Enter"&&getParamValue("isConstant",e.node,r,n)){[l]=getNodeNameAndIndex(e.node.name,n);}if(r[e.node.name]==null){const p=executeOp(e.node,r,n,this._resourceManager);if(!l){[l]=getNodeNameAndIndex(e.node.name,n);}const d=n.currentContext;if(isPromise(p)){u.push(p.then((u=>{r[l]=u;n.currentContext=d;this.checkTensorForDisposal(l,e.node,r,n,a,o,i);this.processChildNodes(e.node,t,n,r,s,c);return u})));}else {r[l]=p;this.checkTensorForDisposal(l,e.node,r,n,a,o,i);this.processChildNodes(e.node,t,n,r,s,c);}}else {this.processChildNodes(e.node,t,n,r,s,c);}}return u}processChildNodes(e,t,n,r,s,a){e.children.forEach((e=>{const[o]=getNodeNameAndIndex(e.name,n);if(s[o]||!a.has(e.name)){return}if(e.op==="Merge"){if(e.inputNames.some((e=>!!getTensor(e,r,n)))){s[o]=true;t.push({contexts:n.currentContext,node:e});}}else if(e.inputNames.every((e=>!!getTensor(e,r,n)))){s[o]=true;t.push({contexts:n.currentContext,node:e});}}));}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))));}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t];const[r]=parseNodeName(t);const s=this.graph.nodes[r];if(s.attrParams["shape"]&&s.attrParams["shape"].value){const e=s.attrParams["shape"].value;const t=e.length===n.shape.length&&n.shape.every(((t,n)=>e[n]===-1||e[n]===t));assert(t,(()=>`The shape of dict['${s.name}'] provided in `+`model.execute(dict) must be [${e}], but was `+`[${n.shape}]`));}if(s.attrParams["dtype"]&&s.attrParams["dtype"].value){assert(n.dtype===s.attrParams["dtype"].value,(()=>`The dtype of dict['${s.name}'] provided in `+`model.execute(dict) must be `+`${s.attrParams["dtype"].value}, but was ${n.dtype}`));}}));}mapInputs(e){const t={};for(const n in e){if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[n]!=null){const r=this._signature.inputs[n];t[r.name]=e[n];}else {t[n]=e[n];}}return t}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=parseNodeName(e);return this.graph.nodes[t]==null}));if(t.length>0){throw new Error(`The dict provided in model.execute(dict) has `+`keys: [${t}] that are not part of graph`)}}mapOutputs(e){return e.map((e=>{if(this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[e]!=null){const t=this._signature.outputs[e];return t.name}return e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=parseNodeName(e);if(!this.graph.nodes[t]){throw new Error(`The output '${e}' is not found in the graph`)}}));}}class ResourceManager{constructor(e={},t={}){this.hashTableNameToHandle=e;this.hashTableMap=t;}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle;this.hashTableMap[t.id]=t;}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap){this.hashTableMap[e].clearAndClose();delete this.hashTableMap[e];}for(const e in this.hashTableNameToHandle){this.hashTableNameToHandle[e].dispose();delete this.hashTableNameToHandle[e];}}}
class GraphModel{constructor(e,t={},n=io){this.modelUrl=e;this.loadOptions=t;this.version="n/a";this.io=n;if(t==null){this.loadOptions={};}this.resourceManager=new ResourceManager;}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(e.load!=null){this.handler=e;}else if(this.loadOptions.requestInit!=null){this.handler=this.io.browserHTTPRequest(e,this.loadOptions);}else {const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0){t.push(this.io.browserHTTPRequest(e,this.loadOptions));}else if(t.length>1){throw new Error(`Found more than one (${t.length}) load handlers for `+`URL '${[e]}'`)}this.handler=t[0];}}load(){this.findIOHandler();if(this.handler.load==null){throw new Error("Cannot proceed with model loading because the IOHandler provided "+"does not have the `load` method implemented.")}const e=this.handler.load();if(isPromise(e)){return e.then((e=>this.loadSync(e)))}return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const e=this.artifacts.userDefinedMetadata;if(e.signature!=null){n=e.signature;}if(e.structuredOutputKeys!=null){this.structuredOutputKeys=e.structuredOutputKeys;}}this.signature=n;this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);this.executor=new GraphExecutor(OperationMapper.Instance.transformGraph(t,this.signature));this.executor.weightMap=this.convertTensorMapToTensorsMap(r);this.executor.resourceManager=this.resourceManager;if(e.modelInitializer!=null&&e.modelInitializer.node!=null){const t=OperationMapper.Instance.transformGraph(e.modelInitializer);this.initializer=new GraphExecutor(t);this.initializer.weightMap=this.executor.weightMap;this.initializer.resourceManager=this.resourceManager;this.initializer.executeAsync({},[]);}return true}async save(e,t){if(typeof e==="string"){const t=this.io.getSaveHandlers(e);if(t.length===0){throw new Error(`Cannot find any save handlers for URL '${e}'`)}else if(t.length>1){throw new Error(`Found more than one (${t.length}) save handlers for `+`URL '${e}'`)}e=t[0];}if(e.save==null){throw new Error("GraphModel.save() cannot proceed because the IOHandler "+"provided does not have the `save` attribute defined.")}return e.save(this.artifacts)}predict(e,t){const n=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){const e=n instanceof Tensor?[n]:n;const t={};e.forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e));return t}return n}normalizeInputs(e){if(!(e instanceof Tensor)&&!Array.isArray(e)){return e}e=Array.isArray(e)?e:[e];if(e.length!==this.inputNodes.length){throw new Error("Input tensor count mismatch,"+`the graph model has ${this.inputNodes.length} placeholders, `+`while there are ${e.length} input tensors.`)}return this.inputNodes.reduce(((t,n,r)=>{t[n]=e[r];return t}),{})}normalizeOutputs(e){e=e||this.outputNodes;return !Array.isArray(e)?[e]:e}execute(e,t){e=this.normalizeInputs(e);t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e);t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors();}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>{t[n]=[e[n]];return t}),{})}dispose(){this.executor.dispose();if(this.initializer){this.initializer.dispose();}this.resourceManager.dispose();}}async function loadGraphModel(e,t={},n=io){if(e==null){throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url "+"or an IOHandler that loads the model")}if(t==null){t={};}if(t.fromTFHub&&typeof e==="string"){e=getTFHubUrl(e);}const r=new GraphModel(e,t,n);await r.load();return r}
getGlobalTensorClass().prototype.pad=function(e,t){this.throwIfDisposed();return pad(this,e,t)};
getGlobalTensorClass().prototype.where=function(e,t){this.throwIfDisposed();return where(e,this,t)};
getGlobalTensorClass().prototype.mul=function(e){this.throwIfDisposed();return mul(this,e)};
getGlobalTensorClass().prototype.dot=function(e){this.throwIfDisposed();return dot(this,e)};
getGlobalTensorClass().prototype.add=function(e){this.throwIfDisposed();return add(this,e)};
const contexts={};const WEBGL_ATTRIBUTES={alpha:false,antialias:false,premultipliedAlpha:false,preserveDrawingBuffer:false,depth:false,stencil:false,failIfMajorPerformanceCaveat:true};function setWebGLContext(e,t){contexts[e]=t;}function getWebGLContext(e,t){if(!(e in contexts)||t!=null){const n=getWebGLRenderingContext(e,t);if(n!==null){contexts[e]=n;}else {console.log("Could not get context for WebGL version",e);return null}}const n=contexts[e];if(n==null||n.isContextLost()){delete contexts[e];return getWebGLContext(e)}n.disable(n.DEPTH_TEST);n.disable(n.STENCIL_TEST);n.disable(n.BLEND);n.disable(n.DITHER);n.disable(n.POLYGON_OFFSET_FILL);n.disable(n.SAMPLE_COVERAGE);n.enable(n.SCISSOR_TEST);n.enable(n.CULL_FACE);n.cullFace(n.BACK);return contexts[e]}function createCanvas(e){if(typeof OffscreenCanvas!=="undefined"&&e===2){return new OffscreenCanvas(300,150)}else if(typeof document!=="undefined"){return document.createElement("canvas")}else {throw new Error("Cannot create a canvas in this context")}}function getWebGLRenderingContext(e,t){if(e!==1&&e!==2){throw new Error("Cannot get WebGL rendering context, WebGL is disabled.")}const n=t==null?createCanvas(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault();delete contexts[e];}),false);if(e===1){return n.getContext("webgl",WEBGL_ATTRIBUTES)||n.getContext("experimental-webgl",WEBGL_ATTRIBUTES)}return n.getContext("webgl2",WEBGL_ATTRIBUTES)}
var PackingScheme;(function(e){e[e["DENSE"]=0]="DENSE";e[e["SHARED_BATCH"]=1]="SHARED_BATCH";})(PackingScheme||(PackingScheme={}));var TextureUsage;(function(e){e[e["RENDER"]=0]="RENDER";e[e["UPLOAD"]=1]="UPLOAD";e[e["PIXELS"]=2]="PIXELS";e[e["DOWNLOAD"]=3]="DOWNLOAD";})(TextureUsage||(TextureUsage={}));var PhysicalTextureType;(function(e){e[e["UNPACKED_FLOAT16"]=0]="UNPACKED_FLOAT16";e[e["UNPACKED_FLOAT32"]=1]="UNPACKED_FLOAT32";e[e["PACKED_4X1_UNSIGNED_BYTE"]=2]="PACKED_4X1_UNSIGNED_BYTE";e[e["PACKED_2X2_FLOAT32"]=3]="PACKED_2X2_FLOAT32";e[e["PACKED_2X2_FLOAT16"]=4]="PACKED_2X2_FLOAT16";})(PhysicalTextureType||(PhysicalTextureType={}));function getUnpackedMatrixTextureShapeWidthHeight(e,t){return [t,e]}function getDenseTexShape(e){const t=sizeFromShape(e);const n=Math.ceil(t/4);return sizeToSquarishShape(n)}function getPackedMatrixTextureShapeWidthHeight(e,t){return [Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function getTextureConfig(e,t){const n=e;let r;let s;let a;let o;let i;let c;let u;let l;let p;let d;if(env().getNumber("WEBGL_VERSION")===2){r=n.R32F;s=n.R16F;a=n.RGBA16F;o=n.RGBA32F;i=n.RED;u=4;l=1;p=n.HALF_FLOAT;d=n.FLOAT;c=n.RGBA8;}else {r=e.RGBA;s=e.RGBA;a=e.RGBA;o=n.RGBA;i=e.RGBA;u=4;l=4;p=t!=null?t.HALF_FLOAT_OES:null;d=e.FLOAT;c=e.RGBA;}return {internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:c,downloadUnpackNumChannels:u,defaultNumChannels:l,textureTypeHalfFloat:p,textureTypeFloat:d}}
function callAndCheck(e,t){const n=t();if(env().getBool("DEBUG")){checkWebGLError(e);}return n}function createVertexShader$1(e,t){const n=throwIfNull(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");callAndCheck(e,(()=>e.shaderSource(n,t)));callAndCheck(e,(()=>e.compileShader(n)));if(e.getShaderParameter(n,e.COMPILE_STATUS)===false){console.log(e.getShaderInfoLog(n));throw new Error("Failed to compile vertex shader.")}return n}function createFragmentShader(e,t){const n=throwIfNull(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");callAndCheck(e,(()=>e.shaderSource(n,t)));callAndCheck(e,(()=>e.compileShader(n)));if(env().get("ENGINE_COMPILE_ONLY")){return n}if(e.getShaderParameter(n,e.COMPILE_STATUS)===false){logShaderSourceAndInfoLog(t,e.getShaderInfoLog(n));throw new Error("Failed to compile fragment shader.")}return n}function createProgram(e){return throwIfNull(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function linkProgram(e,t){callAndCheck(e,(()=>e.linkProgram(t)));if(env().get("ENGINE_COMPILE_ONLY")){return}if(e.getProgramParameter(t,e.LINK_STATUS)===false){console.log(e.getProgramInfoLog(t));throw new Error("Failed to link vertex and fragment shaders.")}}function createStaticVertexBuffer(e,t){const n=throwIfNull(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");callAndCheck(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n)));callAndCheck(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)));return n}function createStaticIndexBuffer(e,t){const n=throwIfNull(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");callAndCheck(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)));callAndCheck(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)));return n}function createTexture(e){return throwIfNull(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function validateTextureSize(e,t){const n=env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n=`[${e}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const r=`[${e}x${t}]`;const s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function createFramebuffer(e){return throwIfNull(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function bindVertexBufferToProgramAttribute(e,t,n,r,s,a,o){const i=e.getAttribLocation(t,n);if(i===-1){return false}callAndCheck(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r)));callAndCheck(e,(()=>e.vertexAttribPointer(i,s,e.FLOAT,false,a,o)));callAndCheck(e,(()=>e.enableVertexAttribArray(i)));return true}function bindTextureUnit(e,t,n){validateTextureUnit(e,n);callAndCheck(e,(()=>e.activeTexture(e.TEXTURE0+n)));callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,t)));}function getProgramUniformLocation(e,t,n){return e.getUniformLocation(t,n)}function bindTextureToProgramUniformSampler(e,t,n,r){callAndCheck(e,(()=>bindTextureUnit(e,t,r)));callAndCheck(e,(()=>e.uniform1i(n,r)));}function bindColorTextureToFramebuffer(e,t,n){callAndCheck(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n)));callAndCheck(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)));}function throwIfNull(e,t,n){const r=callAndCheck(e,(()=>t()));if(r==null){throw new Error(n)}return r}function validateTextureUnit(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1;const r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){const e=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${e}.`)}}function getBatchDim(e,t=2){return sizeFromShape(e.slice(0,e.length-t))}function getRowsCols(e){if(e.length===0){throw Error("Cannot get rows and columns of an empty shape array.")}return [e.length>1?e[e.length-2]:1,e[e.length-1]]}function getShapeAs3D(e){let t=[1,1,1];const n=e.length===0||e.length===1&&e[0]===1;if(!n){t=[getBatchDim(e),...getRowsCols(e)];}return t}function getTextureShapeFromLogicalShape(e,t=false){let n=env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t){n=n*2;e=e.map(((t,n)=>n>=e.length-2?nearestLargerEven(e[n]):e[n]));if(e.length===1){e=[2,e[0]];}}if(e.length!==2){const t=squeezeShape(e);e=t.newShape;}let r=sizeFromShape(e);if(e.length<=1&&r<=n){return [1,r]}else if(e.length===2&&e[0]<=n&&e[1]<=n){return e}else if(e.length===3&&e[0]*e[1]<=n&&e[2]<=n){return [e[0]*e[1],e[2]]}else if(e.length===3&&e[0]<=n&&e[1]*e[2]<=n){return [e[0],e[1]*e[2]]}else if(e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n){return [e[0]*e[1]*e[2],e[3]]}else if(e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n){return [e[0],e[1]*e[2]*e[3]]}else {if(t){const t=getBatchDim(e);let n=2,s=2;if(e.length){[n,s]=getRowsCols(e);}r=t*(n/2)*(s/2);return sizeToSquarishShape(r).map((e=>e*2))}return sizeToSquarishShape(r)}}function isEven(e){return e%2===0}function isReshapeFree(e,t){e=e.slice(-2);t=t.slice(-2);if(arraysEqual(e,t)){return true}if(!e.length||!t.length){return true}if(e[0]===0||e[1]===0||t[0]===0||t[1]===0){return true}if(e.length!==t.length){const n=e.slice(-1)[0];const r=t.slice(-1)[0];if(n===r){return true}if(isEven(n)&&isEven(r)&&(e[0]===1||t[0]===1)){return true}}return e[1]===t[1]&&isEven(e[0])&&isEven(t[0])}let MAX_TEXTURE_SIZE;let MAX_TEXTURES_IN_SHADER;function getWebGLMaxTextureSize(e){if(MAX_TEXTURE_SIZE==null){const t=getWebGLContext(e);MAX_TEXTURE_SIZE=t.getParameter(t.MAX_TEXTURE_SIZE);}return MAX_TEXTURE_SIZE}function getMaxTexturesInShader(e){if(MAX_TEXTURES_IN_SHADER==null){const t=getWebGLContext(e);MAX_TEXTURES_IN_SHADER=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);}return Math.min(16,MAX_TEXTURES_IN_SHADER)}function hasExtension(e,t){const n=e.getExtension(t);return n!=null}function isWebGLVersionEnabled(e){try{const t=getWebGLContext(e);if(t!=null){return true}}catch(e){console.log("Error when getting WebGL context: ",e);return false}return false}function isCapableOfRenderingToFloatTexture(e){if(e===0){return false}const t=getWebGLContext(e);if(e===1){if(!hasExtension(t,"OES_texture_float")){return false}}else {if(!hasExtension(t,"EXT_color_buffer_float")){return false}}const n=createFloatTextureAndBindToFramebuffer(t);return n}function createFloatTextureAndBindToFramebuffer(e){const t=getTextureConfig(e);const n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);const r=1;const s=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,s,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a);e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;e.bindTexture(e.TEXTURE_2D,null);e.bindFramebuffer(e.FRAMEBUFFER,null);e.deleteTexture(n);e.deleteFramebuffer(a);return o}function isWebGLFenceEnabled(e){if(e!==2){return false}const t=getWebGLContext(e);const n=t.fenceSync!=null;return n}
const ENV=env();ENV.registerFlag("HAS_WEBGL",(()=>ENV.getNumber("WEBGL_VERSION")>0));ENV.registerFlag("WEBGL_VERSION",(()=>{if(isWebGLVersionEnabled(2)){return 2}else if(isWebGLVersionEnabled(1)){return 1}return 0}));ENV.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>false));ENV.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>ENV.get("WEBGL_VERSION")===2));ENV.registerFlag("WEBGL_CPU_FORWARD",(()=>true));ENV.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>false));ENV.registerFlag("WEBGL_PACK",(()=>ENV.getBool("HAS_WEBGL")));ENV.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_PACK_CLIP",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_PACK_REDUCE",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_LAZILY_UNPACK",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_CONV_IM2COL",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>getWebGLMaxTextureSize(ENV.getNumber("WEBGL_VERSION"))));ENV.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>getMaxTexturesInShader(ENV.getNumber("WEBGL_VERSION"))));ENV.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=ENV.getNumber("WEBGL_VERSION");if(e===0){return 0}return getWebGLDisjointQueryTimerVersion(e)}));ENV.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>ENV.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!isMobile()));ENV.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>isCapableOfRenderingToFloatTexture(ENV.getNumber("WEBGL_VERSION"))));ENV.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>ENV.getBool("WEBGL_FORCE_F16_TEXTURES")?false:ENV.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")));ENV.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>isDownloadFloatTextureEnabled(ENV.getNumber("WEBGL_VERSION"))));ENV.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>isWebGLFenceEnabled(ENV.getNumber("WEBGL_VERSION"))));ENV.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>{const e=ENV.getBool("WEBGL_RENDER_FLOAT32_ENABLED");return e?4:0}));ENV.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&e!==-1){throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never `+`delete) or at least 0, but got ${e}.`)}}));ENV.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>isMobile()?1:-1),(e=>{if(e<0&&e!==-1){throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never `+`manual flush) or at least 0, but got ${e}.`)}}));ENV.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128));ENV.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>false));ENV.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5));ENV.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128));
function getGlslDifferences(){let e;let t;let n;let r;let s;let a;let o;let i;let c;let u;if(env().getNumber("WEBGL_VERSION")===2){e="#version 300 es";t="in";n="out";r="in";s="texture";a="outputColor";o="out vec4 outputColor;";i=`\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    `;c=``;u=`\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;}else {e="";t="attribute";n="varying";r="varying";s="texture2D";a="gl_FragColor";o="";i=`\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    `;c=`\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    `;u=`\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;}return {version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:c,defineRound:u}}
function getLogicalCoordinatesFromFlatIndex(e,t,n="index"){const r=computeStrides(t);return r.map(((t,s)=>{const a=`int ${e[s]} = ${n} / ${t}`;const o=s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`;return `${a}; ${o};`})).join("")}function getOutputLogicalCoordinatesFromFlatIndexByUniform(e,t,n="index"){const r=computeStrides(t);return r.map(((t,s)=>{const a=`int ${e[s]} = ${n} / outShapeStrides[${s}]`;const o=s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return `${a}; ${o};`})).join("")}function symbolicallyComputeStrides(e,t){const n=e.length;const r=e.map((e=>`${t}[${e}]`));const s=new Array(n-1);s[n-2]=r[n-1];for(let e=n-3;e>=0;--e){s[e]=`(${s[e+1]} * ${r[e+1]})`;}return s}function getLogicalCoordinatesFromFlatIndexByUniform(e,t,n="index"){const r=e.map(((e,t)=>t));const s=symbolicallyComputeStrides(r,t);return s.map(((t,r)=>{const a=`int ${e[r]} = ${n} / ${s[r]}`;const o=r===s.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${s[r]}`:`index -= ${e[r]} * ${s[r]}`;return `${a}; ${o};`})).join("")}function getFlatIndexFrom3D(e){const t=computeStrides(e).map((e=>e.toString()));return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}function getFlatIndexFrom3DOutput(){return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n`}const ENCODE_FLOAT_SNIPPET=`\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`
;const{getBroadcastDims:getBroadcastDims}=backend_util;function makeShader(e,t,n){const r=[];e.forEach((e=>{const t=sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform){r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`);}else {r.push(`uniform sampler2D ${e.name};`);r.push(`uniform int offset${e.name};`);}if(n.enableShapeUniforms){const{uniformShape:t}=getUniformInfoFromShape(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`);break}r.push(`uniform ivec2 ${e.name}TexShape;`);}}));if(n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push(`uniform int outShape;`);break;case 2:r.push(`uniform ivec2 outShape;`);r.push(`uniform int outShapeStrides;`);break;case 3:r.push(`uniform ivec3 outShape;`);r.push(`uniform ivec2 outShapeStrides;`);break;case 4:r.push(`uniform ivec4 outShape;`);r.push(`uniform ivec3 outShapeStrides;`);break}r.push(`uniform ivec2 outTexShape;`);}if(n.customUniforms){n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`);}));}const s=r.join("\n");const a=e.map((e=>getInputSamplingSnippet(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n");const o=t.texShape;const i=getGlslDifferences();const c=getFloatTextureSampleSnippet(i);let u;let l;let p=getShaderPrefix(i);if(t.isPacked){u=getPackedOutputSamplingSnippet(t.logicalShape,o,n.enableShapeUniforms);l=getFloatTextureSetRGBASnippet(i);}else {u=getOutputSamplingSnippet(t.logicalShape,o,n.enableShapeUniforms);l=getFloatTextureSetRSnippet(i);}if(n.packedInputs){p+=SHADER_PACKED_PREFIX;}const d=[p,c,l,s,u,a,n.userCode].join("\n");return d}function getSamplerFromInInfo(e,t=false){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return getSamplerScalar(e,t);case 1:return getSampler1D(e,t);case 2:return getSampler2D(e,t);case 3:return getSampler3D(e,t);case 4:return getSampler4D(e,t);case 5:return getSampler5D(e);case 6:return getSampler6D(e);default:throw new Error(`${n.length}-D input sampling`+` is not yet supported`)}}function getPackedSamplerFromInInfo(e,t){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return getPackedSamplerScalar(e);case 1:return getPackedSampler1D(e,t);case 2:return getPackedSampler2D(e,t);case 3:return getPackedSampler3D(e,t);default:return getPackedSamplerND(e,t)}}function getInputSamplingSnippet(e,t,n=false,r){let s="";if(n){s+=getPackedSamplerFromInInfo(e,r);}else {s+=getSamplerFromInInfo(e,r);}const a=e.shapeInfo.logicalShape;const o=t.logicalShape;if(a.length<=o.length){if(n){s+=getPackedSamplerAtOutputCoords(e,t);}else {s+=getSamplerAtOutputCoords(e,t);}}return s}function getPackedOutputSamplingSnippet(e,t,n){switch(e.length){case 0:return getOutputScalarCoords();case 1:return getOutputPacked1DCoords(e,t,n);case 2:return getOutputPacked2DCoords(e,t,n);case 3:return getOutputPacked3DCoords(e,t,n);default:return getOutputPackedNDCoords(e,t,n)}}function getOutputSamplingSnippet(e,t,n){switch(e.length){case 0:return getOutputScalarCoords();case 1:return getOutput1DCoords(e,t,n);case 2:return getOutput2DCoords(e,t,n);case 3:return getOutput3DCoords(e,t,n);case 4:return getOutput4DCoords(e,t,n);case 5:return getOutput5DCoords(e,t);case 6:return getOutput6DCoords(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function getFloatTextureSampleSnippet(e){return `\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}function getFloatTextureSetRSnippet(e){return `\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}function getFloatTextureSetRGBASnippet(e){return `\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}function getShaderPrefix(e){const t=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${SAMPLE_1D_SNIPPET}\n    ${SAMPLE_2D_SNIPPET}\n    ${SAMPLE_3D_SNIPPET}\n  `;return t}const SAMPLE_1D_SNIPPET=`\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;const SAMPLE_2D_SNIPPET=`\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;const SAMPLE_3D_SNIPPET=`\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;const SHADER_PACKED_PREFIX=`\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n`;function getOutputPacked3DCoords(e,t,n){if(n){return `\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];const s=Math.ceil(e[2]/2);const a=s*Math.ceil(e[1]/2);return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}function getOutputPackedNDCoords(e,t,n){if(n){return `\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  `}const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];const s=Math.ceil(e[e.length-1]/2);const a=s*Math.ceil(e[e.length-2]/2);let o=a;let i=``;let c="b, r, c";for(let t=2;t<e.length-1;t++){o*=e[e.length-t-1];i=`\n      int b${t} = index / ${o};\n      index -= b${t} * ${o};\n    `+i;c=`b${t}, `+c;}return `\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${e.length}(${c});\n    }\n  `}function getOutputPacked2DCoords(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(arraysEqual(e,t)){if(n){return `\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    `}return `\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `}const s=Math.ceil(e[1]/2);if(n){return `\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  `}return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}function getOutput2DCoords(e,t,n){if(arraysEqual(e,t)){if(n){return `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    `}return `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `}if(e[1]===1){if(n){return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `}return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `}if(e[0]===1){if(n){return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `}return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `}if(n){return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  `}return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}function getFlatOffsetUniformName(e){return `offset${e}`}function getPackedSampler1D(e,t){const n=e.name;const r="get"+n.charAt(0).toUpperCase()+n.slice(1);const s=e.shapeInfo.texShape;const a=getGlslDifferences();if(t){return `\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}const o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return `\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}function getSampler1D(e,t){const n=e.name;const r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform){return `\n      float ${r}(int index) {\n        ${getUniformSampler(e)}\n      }\n    `}const s=e.shapeInfo.texShape;const a=s[0];const o=s[1];if(o===1&&a===1){return `\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `}const i=getFlatOffsetUniformName(n);if(o===1){if(t){return `\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `}return `\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${a}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `}if(a===1){if(t){return `\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `}return `\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `}if(t){return `\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}return `\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${o}, index + ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}function getPackedSampler2D(e,t){const n=e.shapeInfo.logicalShape;const r=e.name;const s="get"+r.charAt(0).toUpperCase()+r.slice(1);const a=e.shapeInfo.texShape;const o=a[0];const i=a[1];const c=getGlslDifferences();if(a!=null&&arraysEqual(n,a)){if(t){return `\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${c.texture2D}(${r}, uv);\n      }\n    `}return `\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);\n\n        return ${c.texture2D}(${r}, uv);\n      }\n    `}if(t){return `\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${c.texture2D}(${r}, uv);\n    }\n  `}const u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];const l=Math.ceil(n[1]/2);return `\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${l}, ${u[0]}, ${u[1]}, row, col);\n      return ${c.texture2D}(${r}, uv);\n    }\n  `}function getSampler2D(e,t){const n=e.shapeInfo.logicalShape;const r=e.name;const s="get"+r.charAt(0).toUpperCase()+r.slice(1);const a=e.shapeInfo.texShape;if(a!=null&&arraysEqual(n,a)){if(t){return `\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `}const e=a[0];const n=a[1];return `\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:o,keptDims:i}=squeezeShape(n);const c=o;if(c.length<n.length){const n=squeezeInputInfo(e,c);const r=["row","col"];return `\n      ${getSamplerFromInInfo(n,t)}\n      float ${s}(int row, int col) {\n        return ${s}(${getSqueezedParams(r,i)});\n      }\n    `}if(e.shapeInfo.isUniform){return `\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${getUniformSampler(e)}\n      }\n    `}const u=a[0];const l=a[1];const p=getFlatOffsetUniformName(r);if(l===1){if(t){return `\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `}return `\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}if(u===1){if(t){return `\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `}return `\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `}if(t){return `\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${p};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `}return `\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${p};\n    vec2 uv = uvFromFlat(${u}, ${l}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}function getPackedSampler3D(e,t){const n=e.shapeInfo.logicalShape;const r=e.name;const s="get"+r.charAt(0).toUpperCase()+r.slice(1);const a=e.shapeInfo.texShape;const o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){const r=n.slice(1);const a=[1,2];const o=squeezeInputInfo(e,r);const i=["b","row","col"];return `\n        ${getPackedSamplerFromInInfo(o,t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${getSqueezedParams(i,a)});\n        }\n      `}const i=getGlslDifferences();if(t){return `\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${i.texture2D}(${r}, uv);\n    }\n  `}const c=o[0];const u=o[1];const l=Math.ceil(n[2]/2);const p=l*Math.ceil(n[1]/2);return `\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${c}, ${u}, ${p}, ${l}, b, row, col);\n      return ${i.texture2D}(${r}, uv);\n    }\n  `}function getSampler3D(e,t){const n=e.shapeInfo.logicalShape;const r=e.name;const s="get"+r.charAt(0).toUpperCase()+r.slice(1);const a=n[1]*n[2];const o=n[2];const{newShape:i,keptDims:c}=squeezeShape(n);const u=i;if(u.length<n.length){const n=squeezeInputInfo(e,u);const r=["row","col","depth"];return `\n        ${getSamplerFromInInfo(n,t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${getSqueezedParams(r,c)});\n        }\n      `}if(e.shapeInfo.isUniform){return `\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${a}, ${o}, 1)));\n        ${getUniformSampler(e)}\n      }\n    `}const l=e.shapeInfo.texShape;const p=l[0];const d=l[1];const h=e.shapeInfo.flatOffset;if(d===a&&h==null){if(t){return `\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `}return `\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${p}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `}if(d===o&&h==null){if(t){return `\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `}return `\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${p}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const m=getFlatOffsetUniformName(r);if(t){return `\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * ${a} + col * ${o} + depth + ${m};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `}return `\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a} + col * ${o} + depth + ${m};\n        vec2 uv = uvFromFlat(${p}, ${d}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}function getPackedSamplerND(e,t){const n=e.name;const r="get"+n.charAt(0).toUpperCase()+n.slice(1);const s=getGlslDifferences();if(t){return `\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);\n    }\n  `}const a=e.shapeInfo.logicalShape;const o=a.length;const i=e.shapeInfo.texShape;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];const u=c[0];const l=c[1];const p=Math.ceil(a[o-1]/2);let d=p*Math.ceil(a[o-2]/2);let h=`int b, int row, int col`;let m=`b * ${d} + (row / 2) * ${p} + (col / 2)`;for(let e=2;e<o-1;e++){h=`int b${e}, `+h;d*=a[o-e-1];m=`b${e} * ${d} + `+m;}return `\n    vec4 ${r}(${h}) {\n      int index = ${m};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${u});\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}function getPackedSamplerAtOutputCoords(e,t){const n=e.name;const r=n.charAt(0).toUpperCase()+n.slice(1);const s="get"+r+"AtOutCoords";const a=e.shapeInfo.logicalShape.length;const o=t.logicalShape.length;const i=getBroadcastDims(e.shapeInfo.logicalShape,t.logicalShape);const c=getCoordsDataType(o);const u=o-a;let l;const p=["x","y","z","w","u","v"];if(a===0){l="";}else if(o<2&&i.length>=1){l="coords = 0;";}else {l=i.map((e=>`coords.${p[e+u]} = 0;`)).join("\n");}let d="";if(o<2&&a>0){d="coords";}else {d=e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+u]}`)).join(", ");}let h=`return outputValue;`;const m=sizeFromShape(e.shapeInfo.logicalShape);const f=m===1;const g=sizeFromShape(t.logicalShape);const y=g===1;if(a===1&&!f&&!y){h=`\n      return vec4(outputValue.xy, outputValue.xy);\n    `;}else if(f&&!y){if(o===1){h=`\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      `;}else {h=`\n        return vec4(outputValue.x);\n      `;}}else if(i.length){const e=a-2;const t=a-1;if(i.indexOf(e)>-1&&i.indexOf(t)>-1){h=`return vec4(outputValue.x);`;}else if(i.indexOf(e)>-1){h=`return vec4(outputValue.x, outputValue.y, `+`outputValue.x, outputValue.y);`;}else if(i.indexOf(t)>-1){h=`return vec4(outputValue.xx, outputValue.zz);`;}}return `\n    vec4 ${s}() {\n      ${c} coords = getOutputCoords();\n      ${l}\n      vec4 outputValue = get${r}(${d});\n      ${h}\n    }\n  `}function getSamplerAtOutputCoords(e,t){const n=e.name;const r=n.charAt(0).toUpperCase()+n.slice(1);const s="get"+r+"AtOutCoords";const a=t.texShape;const o=e.shapeInfo.texShape;const i=e.shapeInfo.logicalShape.length;const c=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===c&&e.shapeInfo.flatOffset==null&&arraysEqual(o,a)){return `\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `}const u=getCoordsDataType(c);const l=getBroadcastDims(e.shapeInfo.logicalShape,t.logicalShape);const p=c-i;let d;const h=["x","y","z","w","u","v"];if(i===0){d="";}else if(c<2&&l.length>=1){d="coords = 0;";}else {d=l.map((e=>`coords.${h[e+p]} = 0;`)).join("\n");}let m="";if(c<2&&i>0){m="coords";}else {m=e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+p]}`)).join(", ");}return `\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${d}\n      return get${r}(${m});\n    }\n  `}function getCoordsDataType(e){if(e<=1){return "int"}else if(e===2){return "ivec2"}else if(e===3){return "ivec3"}else if(e===4){return "ivec4"}else if(e===5){return "ivec5"}else if(e===6){return "ivec6"}else {throw Error(`GPU for rank ${e} is not yet supported`)}}function getUniformInfoFromShape(e,t,n){const{newShape:r,keptDims:s}=squeezeShape(t);const a=t.length;const o=e&&a===3&&t[0]===1;const i=o?t.slice(1):r;const c=!e&&a>1&&!arraysEqual(t,n)&&r.length<a||o;const u=c?i:t;return {useSqueezeShape:c,uniformShape:u,keptDims:s}}function squeezeInputInfo(e,t){const n=JSON.parse(JSON.stringify(e));n.shapeInfo.logicalShape=t;return n}function getSqueezedParams(e,t){return t.map((t=>e[t])).join(", ")}
function compileProgram(e,t,n,r){const s=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:e.isUniform?false:e.texData.isPacked,flatOffset:null};if(e.texData!=null&&e.texData.slice!=null&&e.texData.slice.flatOffset>0){r.flatOffset=e.texData.slice.flatOffset;}return {name:t.variableNames[n],shapeInfo:r}}));const a=s.map((e=>e.shapeInfo));const o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:false,isPacked:r.texData.isPacked,flatOffset:null};const i=makeShader(s,o,t);const c=createFragmentShader(e.gl,i);const u=e.createProgram(c);if(!env().get("ENGINE_COMPILE_ONLY")){return Object.assign({program:t,fragmentShader:c,source:i,webGLProgram:u,inShapeInfos:a,outShapeInfo:o},getUniformLocations(e,t,u))}else {return {program:t,fragmentShader:c,source:i,webGLProgram:u,inShapeInfos:a,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}}}function getUniformLocations(e,t,n){const r={};const s={};const a={};const o=[];let i;let c;let u;let l=null;let p=null;p=e.getUniformLocation(n,"NAN",false);if(env().getNumber("WEBGL_VERSION")===1){l=e.getUniformLocation(n,"INFINITY",false);}const d=false;for(let o=0;o<t.variableNames.length;o++){const i=t.variableNames[o];r[i]=e.getUniformLocation(n,i,d);r[`offset${i}`]=e.getUniformLocation(n,`offset${i}`,d);if(t.enableShapeUniforms){s[`${i}Shape`]=e.getUniformLocation(n,`${i}Shape`,d);a[`${i}TexShape`]=e.getUniformLocation(n,`${i}TexShape`,d);}}if(t.enableShapeUniforms){i=e.getUniformLocation(n,"outShape",d);u=e.getUniformLocation(n,"outShapeStrides",d);c=e.getUniformLocation(n,"outTexShape",d);}if(t.customUniforms){t.customUniforms.forEach(((t,r)=>{o[r]=e.getUniformLocation(n,t.name,d);}));}return {uniformLocations:r,customUniformLocations:o,infLoc:l,nanLoc:p,inShapesLocations:s,inTexShapesLocations:a,outShapeLocation:i,outShapeStridesLocation:u,outTexShapeLocation:c}}function validateBinaryAndProgram(e,t){if(e.length!==t.length){throw Error(`Binary was compiled with ${e.length} inputs, but `+`was executed with ${t.length} inputs`)}e.forEach(((e,n)=>{const r=e.logicalShape;const s=t[n];const a=s.shape;if(!arraysEqual(r,a)){throw Error(`Binary was compiled with different shapes than `+`the current args. Shapes ${r} and ${a} must match`)}if(e.isUniform&&s.isUniform){return}const o=e.texShape;const i=s.isUniform?null:s.texData.texShape;if(!arraysEqual(o,i)){throw Error(`Binary was compiled with different texture shapes than the`+` current args. Shape ${o} and ${i} must match`)}}));}function runProgram(e,t,n,r,s){if(!t.program.enableShapeUniforms){validateBinaryAndProgram(t.inShapeInfos,n);validateBinaryAndProgram([t.outShapeInfo],[r]);}const a=r.texData.texture;const o=r.texData.texShape;if(r.texData.isPacked){e.setOutputPackedMatrixTexture(a.texture,o[0],o[1]);}else {e.setOutputMatrixTexture(a.texture,o[0],o[1]);}e.setProgram(t.webGLProgram);if(env().getNumber("WEBGL_VERSION")===1){if(t.infLoc!==null){e.gl.uniform1f(t.infLoc,Infinity);}}if(t.nanLoc!==null){e.gl.uniform1f(t.nanLoc,NaN);}n.forEach(((n,r)=>{const s=t.program.variableNames[r];const a=t.uniformLocations[s];const o=t.uniformLocations[`offset${s}`];const i=t.inShapesLocations[`${s}Shape`];const c=t.inTexShapesLocations[`${s}TexShape`];if(i){const{uniformShape:r}=getUniformInfoFromShape(t.program.packedInputs,n.shape,n.texData.texShape);switch(r.length){case 1:e.gl.uniform1iv(i,new Int32Array(r));break;case 2:e.gl.uniform2iv(i,new Int32Array(r));break;case 3:e.gl.uniform3iv(i,new Int32Array(r));break;case 4:e.gl.uniform4iv(i,new Int32Array(r));break}}if(c){e.gl.uniform2i(c,n.texData.texShape[0],n.texData.texShape[1]);}if(a==null){return}if(n.isUniform){if(sizeFromShape(n.shape)<2){e.gl.uniform1f(a,n.uniformValues[0]);}else {let t=n.uniformValues;if(!(t instanceof Float32Array)){t=new Float32Array(t);}e.gl.uniform1fv(a,t);}return}if(n.texData.slice!=null&&o!=null){e.gl.uniform1i(o,n.texData.slice.flatOffset);}e.setInputMatrixTexture(n.texData.texture.texture,a,r);}));const i=t.outShapeLocation;if(i){switch(r.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(r.shape));break}}if(t.outShapeStridesLocation){const n=computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n));break}}if(t.outTexShapeLocation){e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]);}if(t.program.customUniforms&&s){t.program.customUniforms.forEach(((n,r)=>{const a=t.customUniformLocations[r];const o=s[r];if(n.type==="float"){e.gl.uniform1fv(a,o);}else if(n.type==="vec2"){e.gl.uniform2fv(a,o);}else if(n.type==="vec3"){e.gl.uniform3fv(a,o);}else if(n.type==="vec4"){e.gl.uniform4fv(a,o);}else if(n.type==="int"){e.gl.uniform1iv(a,o);}else if(n.type==="ivec2"){e.gl.uniform2iv(a,o);}else if(n.type==="ivec3"){e.gl.uniform3iv(a,o);}else if(n.type==="ivec4"){e.gl.uniform4iv(a,o);}else {throw Error(`uniform type ${n.type} is not supported yet.`)}}));}e.executeProgram();}function makeShaderKey(e,t,n){let r="";t.concat(n).forEach((t=>{const s=t.texData!=null&&t.texData.slice!=null&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const a=t.texData.texShape;const{useSqueezeShape:o,uniformShape:i,keptDims:c}=getUniformInfoFromShape(e.packedInputs,t.shape,a);let u="",l="",p="";if(i.length===1&&e.packedInputs){const e=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];u=`${e[0]>1}_${e[1]>1}`;}else if(i.length===2&&!e.packedInputs){l=`${i[0]>1}_${i[1]>1}`;}else if(i.length>2&&!e.packedInputs){const e=computeStrides(i);p=`${e[0]===a[1]}_${e[e.length-1]===a[1]}`;}const d=t.shape.length;const h=i.length===2&&arraysEqual(t.shape,a);const m=sizeFromShape(t.shape)===1;const f=getBroadcastDims$1(t.shape,n.shape);const g=!e.packedInputs&&d===n.shape.length&&arraysEqual(a,n.texData.texShape);const y=e.packedInputs||i.length>2?"":`${a[0]>1}_${a[1]>1}`;r+=`${d}_${g}_${o?c:""}_${i.length}_${m}_${f}_${h}_${u}_${l}_${p}_${y}_${s}`;}else {const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${s}`;}}));const s=e.userCode;let a=e.constructor.name;a+="_"+r+"_"+s+`${env().getNumber("WEBGL_VERSION")}`;return a}function useShapeUniforms(e){return env().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}
class DecodeMatrixProgram{constructor(e){this.variableNames=["A"];this.packedInputs=false;this.packedOutput=true;this.outPackingScheme=PackingScheme.DENSE;this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=getGlslDifferences();this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],e):getLogicalCoordinatesFromFlatIndex(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `;}}
class DecodeMatrixPackedProgram{constructor(e){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.outPackingScheme=PackingScheme.DENSE;this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=getGlslDifferences();this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],e):getLogicalCoordinatesFromFlatIndex(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `;}}
class EncodeFloatProgram{constructor(e){this.variableNames=["A"];this.outTexUsage=TextureUsage.DOWNLOAD;const t=getGlslDifferences();this.outputShape=e;this.userCode=`\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `;}}
class EncodeFloatPackedProgram{constructor(e){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=false;this.outTexUsage=TextureUsage.DOWNLOAD;const t=getGlslDifferences();this.outputShape=e;this.userCode=`\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `;}}
class EncodeMatrixProgram{constructor(e,t=false){this.variableNames=["A"];this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=getGlslDifferences();this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);let r=`result`;if(t){r=`floor(result * 255. + 0.5)`;}this.userCode=`\n      ${this.enableShapeUniforms?getFlatIndexFrom3DOutput():getFlatIndexFrom3D(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${r}, 0., 0., 0.);\n      }\n    `;}}
class EncodeMatrixPackedProgram{constructor(e,t=false){this.variableNames=["A"];this.packedInputs=false;this.packedOutput=true;this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=getGlslDifferences();this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);let r="";let s="result";if(t){s="floor(result * 255. + 0.5)";}for(let t=0;t<=1;t++){for(let s=0;s<=1;s++){const a=t*2+s;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${s} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${s};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `;}}this.userCode=`\n        ${this.enableShapeUniforms?getFlatIndexFrom3DOutput():getFlatIndexFrom3D(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${s};\n        }\n    `;}}
function createVertexShader(e){const t=getGlslDifferences();const n=`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return createVertexShader$1(e,n)}function createVertexBuffer(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return createStaticVertexBuffer(e,t)}function createIndexBuffer(e){const t=new Uint16Array([0,1,2,2,1,3]);return createStaticIndexBuffer(e,t)}function createAndConfigureTexture(e,t,n,r,s,a){validateTextureSize(t,n);const o=createTexture(e);const i=e.TEXTURE_2D;callAndCheck(e,(()=>e.bindTexture(i,o)));callAndCheck(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)));callAndCheck(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)));callAndCheck(e,(()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST)));callAndCheck(e,(()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST)));if(env().getNumber("WEBGL_VERSION")===1){callAndCheck(e,(()=>e.texImage2D(i,0,r,t,n,0,s,a,null)));}else {callAndCheck(e,(()=>e.texStorage2D(i,1,r,t,n)));}callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,null)));return {texture:o,texShape:[n,t]}}function getInternalFormatForFloat32MatrixTexture(e){return e.internalFormatFloat}function createFloat32MatrixTexture(e,t,n,r){const[s,a]=getUnpackedMatrixTextureShapeWidthHeight(t,n);return createAndConfigureTexture(e,s,a,getInternalFormatForFloat32MatrixTexture(r),r.textureFormatFloat,e.FLOAT)}function getInternalFormatForPackedMatrixTexture(e){return e.internalFormatPackedFloat}function createPackedMatrixTexture(e,t,n,r){const[s,a]=getPackedMatrixTextureShapeWidthHeight(t,n);return createAndConfigureTexture(e,s,a,getInternalFormatForPackedMatrixTexture(r),e.RGBA,e.FLOAT)}function bindVertexProgramAttributeStreams(e,t,n){const r=0;const s=3*4;const a=3*4+2*4;callAndCheck(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n)));const o=bindVertexBufferToProgramAttribute(e,t,"clipSpacePos",n,3,a,r);return o&&bindVertexBufferToProgramAttribute(e,t,"uv",n,2,a,s)}function uploadDenseMatrixToTexture(e,t,n,r,s,a){callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,t)));let o,i,c;if(s instanceof Uint8Array){o=new Uint8Array(n*r*4);i=e.UNSIGNED_BYTE;c=e.RGBA;}else {o=new Float32Array(n*r*4);i=e.FLOAT;c=a.internalFormatPackedFloat;}o.set(s);if(env().getNumber("WEBGL_VERSION")===2){callAndCheck(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,i,o)));}else {callAndCheck(e,(()=>e.texImage2D(e.TEXTURE_2D,0,c,n,r,0,e.RGBA,i,o)));}callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,null)));}function createBufferFromOutputTexture(e,t,n,r){const s=e.createBuffer();callAndCheck(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s)));const a=4;const o=4;const i=a*o*t*n;callAndCheck(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ)));callAndCheck(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)));callAndCheck(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)));return s}function downloadFloat32MatrixFromBuffer(e,t,n){const r=e;const s=new Float32Array(n);r.bindBuffer(r.PIXEL_PACK_BUFFER,t);r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s);r.bindBuffer(r.PIXEL_PACK_BUFFER,null);return s}
class GPGPUContext{constructor(e){this.outputTexture=null;this.program=null;this.disposed=false;this.vertexAttrsAreBound=false;this.itemsToPoll=[];const t=env().getNumber("WEBGL_VERSION");if(e!=null){this.gl=e;setWebGLContext(t,e);}else {this.gl=getWebGLContext(t);}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile");if(env().getNumber("WEBGL_VERSION")===1){const e="OES_texture_float";const t="OES_texture_half_float";this.textureFloatExtension=getExtensionOrThrow(this.gl,e);if(hasExtension(this.gl,t)){this.textureHalfFloatExtension=getExtensionOrThrow(this.gl,t);}else if(env().get("WEBGL_FORCE_F16_TEXTURES")){throw new Error("GL context does not support half float textures, yet the "+"environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}this.colorBufferFloatExtension=this.gl.getExtension(n);if(hasExtension(this.gl,r)){this.colorBufferHalfFloatExtension=getExtensionOrThrow(this.gl,r);}else if(env().get("WEBGL_FORCE_F16_TEXTURES")){throw new Error("GL context does not support color renderable half floats, yet "+"the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}}else {n="EXT_color_buffer_float";if(hasExtension(this.gl,n)){this.colorBufferFloatExtension=this.gl.getExtension(n);}else if(hasExtension(this.gl,r)){this.colorBufferHalfFloatExtension=this.gl.getExtension(r);}else {throw new Error("GL context does not support color renderable floats")}}this.vertexBuffer=createVertexBuffer(this.gl);this.indexBuffer=createIndexBuffer(this.gl);this.framebuffer=createFramebuffer(this.gl);this.textureConfig=getTextureConfig(this.gl,this.textureHalfFloatExtension);}get debug(){return env().getBool("DEBUG")}dispose(){if(this.disposed){return}if(this.program!=null){console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram."+" This is probably a resource leak, delete the program with "+"GPGPUContext.deleteProgram before disposing.");}if(this.outputTexture!=null){console.warn("Disposing a GPGPUContext that still has a bound output matrix "+"texture.  This is probably a resource leak, delete the output "+"matrix texture with GPGPUContext.deleteMatrixTexture before "+"disposing.");}const e=this.gl;callAndCheck(e,(()=>e.finish()));callAndCheck(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null)));callAndCheck(e,(()=>e.deleteFramebuffer(this.framebuffer)));callAndCheck(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null)));callAndCheck(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)));callAndCheck(e,(()=>e.deleteBuffer(this.indexBuffer)));this.disposed=true;}createFloat32MatrixTexture(e,t){this.throwIfDisposed();return createFloat32MatrixTexture(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){this.throwIfDisposed();return createFloat16MatrixTexture(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){this.throwIfDisposed();return createUnsignedBytesMatrixTexture(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed();uploadPixelDataToTexture(this.gl,e,t);}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed();uploadDenseMatrixToTexture(this.gl,e,t,n,r,this.textureConfig);}createFloat16PackedMatrixTexture(e,t){this.throwIfDisposed();return createFloat16PackedMatrixTexture(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){this.throwIfDisposed();return createPackedMatrixTexture(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed();if(this.outputTexture===e){unbindColorTextureFromFramebuffer(this.gl,this.framebuffer);this.outputTexture=null;}callAndCheck(this.gl,(()=>this.gl.deleteTexture(e)));}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>downloadByteEncodedFloatMatrixFromOutputTexture(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return downloadPackedMatrixFromBuffer(this.gl,e,t,n,r,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return downloadFloat32MatrixFromBuffer(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=createBufferFromOutputTexture(this.gl,t,n,this.textureConfig);this.unbindTextureToFrameBuffer();return r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t;let n;if(env().getBool("WEBGL_FENCE_API_ENABLED")){const r=e;const s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush();n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED};t=s;}else if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0){t=this.beginQuery();this.endQuery();n=()=>this.isQueryAvailable(t,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));}else {n=()=>true;}return {query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>downloadMatrixFromPackedOutputTexture(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;if(this.vertexShader==null){this.vertexShader=createVertexShader(t);}const n=createProgram(t);callAndCheck(t,(()=>t.attachShader(n,this.vertexShader)));callAndCheck(t,(()=>t.attachShader(n,e)));linkProgram(t,n);if(this.debug){validateProgram(t,n);}if(!this.vertexAttrsAreBound){this.setProgram(n);this.vertexAttrsAreBound=bindVertexProgramAttributeStreams(t,this.program,this.vertexBuffer);}return n}deleteProgram(e){this.throwIfDisposed();if(e===this.program){this.program=null;}if(e!=null){callAndCheck(this.gl,(()=>this.gl.deleteProgram(e)));}}setProgram(e){this.throwIfDisposed();this.program=e;if(this.program!=null&&this.debug){validateProgram(this.gl,this.program);}callAndCheck(this.gl,(()=>this.gl.useProgram(e)));}getUniformLocation(e,t,n=true){this.throwIfDisposed();if(n){return getProgramUniformLocationOrThrow(this.gl,e,t)}else {return getProgramUniformLocation(this.gl,e,t)}}getAttributeLocation(e,t){this.throwIfDisposed();return callAndCheck(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){this.throwIfDisposed();return this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed();this.throwIfNoProgram();bindTextureToProgramUniformSampler(this.gl,e,t,n);}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t);}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=getPackedMatrixTextureShapeWidthHeight(t,n);this.setOutputMatrixTextureDriver(e,r,s);}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t);}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){if(this.program!=null){validateProgram(this.gl,this.program);}validateFramebuffer(this.gl);}executeProgram(){this.throwIfDisposed();this.throwIfNoProgram();const e=this.gl;if(this.debug){this.debugValidate();}callAndCheck(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)));}blockUntilAllProgramsCompleted(){this.throwIfDisposed();callAndCheck(this.gl,(()=>this.gl.finish()));}getQueryTimerExtension(){if(this.disjointQueryTimerExtension==null){this.disjointQueryTimerExtension=getExtensionOrThrow(this.gl,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query");}return this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const e=this.gl;const t=this.getQueryTimerExtensionWebGL2();const n=e.createQuery();e.beginQuery(t.TIME_ELAPSED_EXT,n);return n}const e=this.getQueryTimerExtensionWebGL1();const t=e.createQueryEXT();e.beginQueryEXT(e.TIME_ELAPSED_EXT,t);return t}endQuery(){if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const e=this.gl;const t=this.getQueryTimerExtensionWebGL2();e.endQuery(t.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT);}async waitForQueryAndGetTime(e){await repeatedTry((()=>this.disposed||this.isQueryAvailable(e,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))));return this.getQueryTime(e,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0){return null}if(t===2){const t=this.gl;const n=t.getQueryParameter(e,t.QUERY_RESULT);return n/1e6}else {const t=this.getQueryTimerExtensionWebGL1();const n=t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT);return n/1e6}}isQueryAvailable(e,t){if(t===0){return true}if(t===2){const t=this.gl;const n=this.getQueryTimerExtensionWebGL2();const r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);if(this.disjoint==null){this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT);}return r&&!this.disjoint}else {const t=this.getQueryTimerExtensionWebGL1();const n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);if(this.disjoint==null){this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT);}return n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()));}))}pollItems(){const e=linearSearchLastTrue(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e();}this.itemsToPoll=this.itemsToPoll.slice(e+1);}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t});if(this.itemsToPoll.length>1){return}repeatedTry((()=>{this.pollItems();return this.itemsToPoll.length===0}));}bindTextureToFrameBuffer(e){this.throwIfDisposed();bindColorTextureToFramebuffer(this.gl,e,this.framebuffer);if(this.debug){validateFramebuffer(this.gl);}}unbindTextureToFrameBuffer(){if(this.outputTexture!=null){bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer);if(this.debug){validateFramebuffer(this.gl);}}else {unbindColorTextureFromFramebuffer(this.gl,this.framebuffer);}}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();this.unbindTextureToFrameBuffer();return n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;bindColorTextureToFramebuffer(r,e,this.framebuffer);if(this.debug){validateFramebuffer(r);}this.outputTexture=e;callAndCheck(r,(()=>r.viewport(0,0,t,n)));callAndCheck(r,(()=>r.scissor(0,0,t,n)));}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed();callAndCheck(this.gl,(()=>this.gl.scissor(e,t,n,r)));}throwIfDisposed(){if(this.disposed){throw new Error("Attempted to use disposed GPGPUContext.")}}throwIfNoProgram(){if(this.program==null){throw new Error("No GPU program is currently set.")}}}function linearSearchLastTrue(e){let t=0;for(;t<e.length;++t){const n=e[t]();if(!n){break}}return t-1}
function createSimpleBinaryKernelImpl(e){return (t,n,r,s,a)=>{const o=assertAndGetBroadcastShape(t,n);const i=o.length;const c=computeStrides(o);const u=sizeFromShape(o);const l=getTypedArrayFromDType(a,u);const p=t.length;const d=n.length;const h=computeStrides(t);const m=computeStrides(n);const f=getBroadcastDims$1(t,o);const g=getBroadcastDims$1(n,o);if(f.length+g.length===0){for(let t=0;t<l.length;++t){l[t]=e(r[t%r.length],s[t%s.length]);}}else {for(let t=0;t<l.length;++t){const n=indexToLoc(t,i,c);const a=n.slice(-p);f.forEach((e=>a[e]=0));const o=locToIndex(a,p,h);const u=n.slice(-d);g.forEach((e=>u[e]=0));const y=locToIndex(u,d,m);l[t]=e(r[o],s[y]);}}return [l,o]}}
const addImpl=createSimpleBinaryKernelImpl(((e,t)=>e+t));
function bincountImpl(e,t,n,r,s){const a=sizeFromShape(r);const o=makeZerosTypedArray(s,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0){throw new Error("Input x must be non-negative!")}if(r>=s){continue}if(a>0){o[r]+=t[n];}else {o[r]+=1;}}return o}
function createSimpleUnaryImpl(e){return (t,n,r)=>{const s=getTypedArrayFromDType(n,t.length);for(let n=0;n<t.length;++n){s[n]=e(t[n],r);}return s}}
const ceilImpl=createSimpleUnaryImpl((e=>Math.ceil(e)));
function concatImpl$1(e,t,n,r){const s=getArrayFromDType(n,sizeFromShape(t));if(r&&n!=="string"){let t=0;e.forEach((e=>{const n=sizeFromShape(e.shape);s.set(e.vals,t);t+=n;}));}else {let r=0;e.forEach((e=>{const a=n==="string"?fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+r;for(let t=0;t<e.shape[1];++t){s[i+t]=a[o++];}}r+=e.shape[1];}));}return s}
const equalImpl=createSimpleBinaryKernelImpl(((e,t)=>e===t?1:0));
const expImpl=createSimpleUnaryImpl((e=>Math.exp(e)));
const expm1Impl=createSimpleUnaryImpl((e=>Math.expm1(e)));
const floorImpl=createSimpleUnaryImpl((e=>Math.floor(e)));
function gatherV2Impl(e,t,n){const r=buffer(n,e.dtype);for(let n=0;n<r.size;++n){const s=r.indexToLoc(n);const a=s.slice();const o=a[0];const i=a[2];const c=t.locToIndex([o,i]);a[2]=t.values[c];const u=e.locToIndex(a);if(0<=u&&u<e.values.length){r.values[n]=e.values[u];}}return r}
const greaterImpl=createSimpleBinaryKernelImpl(((e,t)=>e>t?1:0));
const greaterEqualImpl=createSimpleBinaryKernelImpl(((e,t)=>e>=t?1:0));
const lessImpl=createSimpleBinaryKernelImpl(((e,t)=>e<t?1:0));
const lessEqualImpl=createSimpleBinaryKernelImpl(((e,t)=>e<=t?1:0));
const logImpl=createSimpleUnaryImpl((e=>Math.log(e)));
function maxImpl(e,t,n,r){const s=getTypedArrayFromDType(r,sizeFromShape(n));for(let n=0;n<s.length;++n){const r=n*t;let a=e[r];for(let n=0;n<t;++n){const t=e[r+n];if(Number.isNaN(t)||t>a){a=t;}}s[n]=a;}return s}
const maximumImpl=createSimpleBinaryKernelImpl(((e,t)=>Math.max(e,t)));
const minimumImpl=createSimpleBinaryKernelImpl(((e,t)=>Math.min(e,t)));
const multiplyImpl=createSimpleBinaryKernelImpl(((e,t)=>e*t));
function negImpl(e,t,n){const r=createScalarValue(-1,n);return multiplyImpl([],t,r,e,n)}
const notEqualImpl=createSimpleBinaryKernelImpl(((e,t)=>e!==t?1:0));
function transposeImpl$1(e,t,n,r,s){const a=t.length;const o=sizeFromShape(t);const i=computeStrides(t);const c=computeStrides(s);const u=getTypedArrayFromDType(n,sizeFromShape(s));for(let t=0;t<o;++t){const n=indexToLoc(t,a,i);const s=new Array(n.length);for(let e=0;e<s.length;e++){s[e]=n[r[e]];}const o=locToIndex(s,a,c);u[o]=e[t];}return u}
function prodImpl(e,t,n,r){const[s,a]=computeOutAndReduceShapes(e,r);const o=upcastType(t,"int32");const i=makeZerosTypedArray(sizeFromShape(s),o);const c=sizeFromShape(a);for(let e=0;e<i.length;++e){const t=e*c;let r=1;for(let e=0;e<c;++e){r*=n[t+e];}i[e]=r;}return {outVals:i,outShape:s,outDtype:o}}
function rangeImpl(e,t,n,r){const s=e===t;const a=e<t&&n<0;const o=t<e&&n>1;if(s||a||o){return makeZerosTypedArray(0,r)}const i=Math.abs(Math.ceil((t-e)/n));const c=makeZerosTypedArray(i,r);if(t<e&&n===1){n=-1;}c[0]=e;for(let e=1;e<c.length;e++){c[e]=c[e-1]+n;}return c}
const rsqrtImpl=createSimpleUnaryImpl((e=>1/Math.sqrt(e)));
function scatterImpl(e,t,n,r,s,a,o,i,c,u){const l=[r/s,s];const p=e.values;const d=t.values;if(r===0){return buffer(n,t.dtype)}const h=buffer(l,t.dtype);if(typeof c==="string"){h.values.fill(c);}else if(typeof c==="number"){h.values.fill(c);}else if(typeof c==="boolean"){h.values.fill(+c);}for(let e=0;e<a;e++){const a=[];let c=0;for(let t=0;t<o;t++){const n=p[e*o+t];a.push(n);c+=n*i[t];}if(c<0||c>=r/s){throw new Error(`Invalid indices: ${a} does not index into ${n}`)}for(let n=0;n<s;n++){if(u){h.values[c*s+n]+=d[e*s+n];}else {h.values[c*s+n]=t.rank===0?d[0]:d[e*s+n];}}}return h}
const sigmoidImpl=createSimpleUnaryImpl((e=>1/(1+Math.exp(-e))));
function sliceImpl(e,t,n,r,s){const a=isSliceContinous(r,t,n);const o=sizeFromShape(n);const i=computeStrides(r);if(a){const n=computeFlatOffset(t,i);if(s==="string"){return e.slice(n,n+o)}return e.subarray(n,n+o)}const c=s==="string"?fromUint8ToStringArray(e):e;const u=buffer(r,s,c);const l=buffer(n,s);for(let e=0;e<l.size;++e){const n=l.indexToLoc(e);const r=n.map(((e,n)=>e+t[n]));l.set(u.get(...r),...n);}if(s==="string"){return fromStringArrayToUint8(l.values)}return l.values}
const sqrtImpl=createSimpleUnaryImpl((e=>Math.sqrt(e)));
const squaredDifferenceImpl=createSimpleBinaryKernelImpl(((e,t)=>{const n=e-t;return n*n}));
const subImpl=createSimpleBinaryKernelImpl(((e,t)=>e-t));
var shared=Object.freeze({__proto__:null,simpleAbsImpl:()=>{},addImpl:addImpl,bincountImpl:bincountImpl,bincountReduceImpl:()=>{},ceilImpl:ceilImpl,concatImpl:concatImpl$1,equalImpl:equalImpl,expImpl:expImpl,expm1Impl:expm1Impl,floorImpl:floorImpl,gatherNdImpl:()=>{},gatherV2Impl:gatherV2Impl,greaterImpl:greaterImpl,greaterEqualImpl:greaterEqualImpl,lessImpl:lessImpl,lessEqualImpl:lessEqualImpl,linSpaceImpl:()=>{},logImpl:logImpl,maxImpl:maxImpl,maximumImpl:maximumImpl,minimumImpl:minimumImpl,multiplyImpl:multiplyImpl,negImpl:negImpl,notEqualImpl:notEqualImpl,prodImpl:prodImpl,rangeImpl:rangeImpl,rsqrtImpl:rsqrtImpl,scatterImpl:scatterImpl,sigmoidImpl:sigmoidImpl,sliceImpl:sliceImpl,sparseFillEmptyRowsImpl:()=>{},sparseReshapeImpl:()=>{},sparseSegmentReductionImpl:()=>{},sqrtImpl:sqrtImpl,squaredDifferenceImpl:squaredDifferenceImpl,stridedSliceImpl:()=>{},stringNGramsImpl:()=>{},stringSplitImpl:()=>{},stringToHashBucketFastImpl:()=>{},subImpl:subImpl,tileImpl:()=>{},topKImpl:()=>{},transposeImpl:transposeImpl$1,uniqueImpl:()=>{}});
const{addImpl:addImplCPU,bincountImpl:bincountImplCPU,bincountReduceImpl:bincountReduceImplCPU,ceilImpl:ceilImplCPU,concatImpl:concatImplCPU,equalImpl:equalImplCPU,expImpl:expImplCPU,expm1Impl:expm1ImplCPU,floorImpl:floorImplCPU,gatherNdImpl:gatherNdImplCPU,gatherV2Impl:gatherV2ImplCPU,greaterImpl:greaterImplCPU,greaterEqualImpl:greaterEqualImplCPU,lessImpl:lessImplCPU,lessEqualImpl:lessEqualImplCPU,linSpaceImpl:linSpaceImplCPU,logImpl:logImplCPU,maxImpl:maxImplCPU,maximumImpl:maximumImplCPU,minimumImpl:minimumImplCPU,multiplyImpl:multiplyImplCPU,negImpl:negImplCPU,notEqualImpl:notEqualImplCPU,prodImpl:prodImplCPU,rangeImpl:rangeImplCPU,rsqrtImpl:rsqrtImplCPU,scatterImpl:scatterImplCPU,sigmoidImpl:sigmoidImplCPU,simpleAbsImpl:simpleAbsImplCPU,sliceImpl:sliceImplCPU,sparseFillEmptyRowsImpl:sparseFillEmptyRowsImplCPU,sparseReshapeImpl:sparseReshapeImplCPU,sparseSegmentReductionImpl:sparseSegmentReductionImplCPU,sqrtImpl:sqrtImplCPU,stridedSliceImpl:stridedSliceImplCPU,stringNGramsImpl:stringNGramsImplCPU,stringSplitImpl:stringSplitImplCPU,stringToHashBucketFastImpl:stringToHashBucketFastImplCPU,subImpl:subImplCPU,tileImpl:tileImplCPU,topKImpl:topKImplCPU,transposeImpl:transposeImplCPU,uniqueImpl:uniqueImplCPU}=shared;
function getVecChannels(e,t){return ["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function getChannels(e,t){if(t===1){return [e]}return getVecChannels(e,t)}function getSourceCoords$1(e,t){if(e===1){return "rc"}let n="";for(let r=0;r<e;r++){n+=t[r];if(r<e-1){n+=",";}}return n}
class PackProgram{constructor(e){this.variableNames=["A"];this.packedInputs=false;this.packedOutput=true;this.outputShape=e;this.rank=e.length;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);if(this.rank===0){this.userCode=`\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      `;}else {const e=getChannels("rc",this.rank);const t=getCoordsDataType(this.rank);const n=this.getOutOfBoundsCondition(e);const r=this.getSetup(e);const s=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `;}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++){for(let r=0;r<=1;r++){let s=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let t=2;t<this.rank;t++){s=`${e[e.length-1-t]},`+s;}t.push(s);}}return t}getOutOfBoundsCondition(e){if(this.rank===1){return `rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`}let t="";for(let n=this.rank-2;n<this.rank;n++){t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`;if(n<this.rank-1){t+="||";}}return t}getSetup(e){if(this.rank===1){return ""}const t=e.slice(-2);const n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1];const r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return `\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(this.rank===1){const e=this.enableShapeUniforms?"outShape":this.outputShape[0];return `getA(rc), (rc + 1 >= ${e} ? 0. : getA(rc + 1)), 0, 0`}return `getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}
class ReshapePackedProgram{constructor(e,t){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"inputShape",type:"ivec3"}];this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);let n=``;for(let e=0;e<4;e++){let t=`thisRC = rc;`;if(e%2===1){t+=`thisRC.z += 1;`;}if(e>1){t+=`thisRC.y += 1;`;}n+=`\n        ${t}\n        ${e>0?`if(thisRC.y < rows && thisRC.z < cols){`:""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `;}this.userCode=`\n      ${getReshapedInputCoords(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?getFlatIndexFrom3DOutput():getFlatIndexFrom3D(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `;}}function getReshapedInputCoords(e,t){const n=t?getLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],"inputShape"):getLogicalCoordinatesFromFlatIndex(["r","c","d"],e);return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}
class TextureManager{constructor(e){this.gpgpu=e;this.numUsedTextures=0;this.numFreeTextures=0;this._numBytesAllocated=0;this._numBytesFree=0;this.freeTextures={};this.logEnabled=false;this.usedTextures={};}acquireTexture(e,t,n){const r=getPhysicalFromLogicalTextureType(t,n);const s=getKeyFromTextureShape(e,r,n);if(!(s in this.freeTextures)){this.freeTextures[s]=[];}if(!(s in this.usedTextures)){this.usedTextures[s]=[];}const a=computeBytes(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--;this.numUsedTextures++;this._numBytesFree-=a;this.log();const e=this.freeTextures[s].shift();this.usedTextures[s].push(e);return e}let o;if(r===PhysicalTextureType.PACKED_2X2_FLOAT32){o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]);}else if(r===PhysicalTextureType.PACKED_2X2_FLOAT16){o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]);}else if(r===PhysicalTextureType.UNPACKED_FLOAT32){o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]);}else if(r===PhysicalTextureType.UNPACKED_FLOAT16){o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]);}else if(r===PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE){o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1]);}this.usedTextures[s].push(o);this.numUsedTextures++;this._numBytesAllocated+=a;this.log();return o}releaseTexture(e,t,n,r){if(this.freeTextures==null){return}const s=getPhysicalFromLogicalTextureType(n,r);const a=getKeyFromTextureShape(t,s,r);if(!(a in this.freeTextures)){this.freeTextures[a]=[];}const o=computeBytes(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);const i=env().get("WEBGL_DELETE_TEXTURE_THRESHOLD");if(i!==-1&&this._numBytesAllocated>i){this.gpgpu.deleteMatrixTexture(e.texture);this._numBytesAllocated-=o;}else {this.freeTextures[a].push(e);this.numFreeTextures++;this._numBytesFree+=o;}this.numUsedTextures--;const c=this.usedTextures[a];const u=c.indexOf(e);if(u<0){throw new Error("Cannot release a texture that was never provided by this "+"texture manager")}c.splice(u,1);this.log();}log(){if(!this.logEnabled){return}const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`);console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`);}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures==null){return}for(const e in this.freeTextures){this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture);}));}for(const e in this.usedTextures){this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture);}));}this.freeTextures=null;this.usedTextures=null;this.numUsedTextures=0;this.numFreeTextures=0;this._numBytesAllocated=0;this._numBytesFree=0;}}function numBytesForInternalFormat(e,t){const n=e;if(t===n.R32F){return 4}else if(t===n.R16F){return 2}else if(t===n.RGBA32F){return 16}else if(t===e.RGBA){return 16}else if(t===n.RGBA16F){return 8}else if(t===n.RGBA8){return 4}throw new Error(`Unknown internal format ${t}`)}function computeBytes(e,t,n,r,s){const a=internalFormatForPhysicalTexType(t,r);let o;if(s){const[t,n]=getPackedMatrixTextureShapeWidthHeight(e[0],e[1]);o=t*n;}else {const[t,n]=getUnpackedMatrixTextureShapeWidthHeight(e[0],e[1]);o=t*n;}const i=numBytesForInternalFormat(n,a);return o*i}function internalFormatForPhysicalTexType(e,t){switch(e){case PhysicalTextureType.PACKED_2X2_FLOAT32:return getInternalFormatForPackedMatrixTexture(t);case PhysicalTextureType.PACKED_2X2_FLOAT16:return getInternalFormatForFloat16PackedMatrixTexture(t);case PhysicalTextureType.UNPACKED_FLOAT32:return getInternalFormatForFloat32MatrixTexture(t);case PhysicalTextureType.UNPACKED_FLOAT16:return getInternalFormatForFloat16MatrixTexture(t);case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:return getInternalFormatForUnsignedBytesMatrixTexture(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function getPhysicalTextureForRendering(e){if(env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")){if(e){return PhysicalTextureType.PACKED_2X2_FLOAT32}return PhysicalTextureType.UNPACKED_FLOAT32}if(e){return PhysicalTextureType.PACKED_2X2_FLOAT16}return PhysicalTextureType.UNPACKED_FLOAT16}function getPhysicalFromLogicalTextureType(e,t){if(e===TextureUsage.UPLOAD){return PhysicalTextureType.PACKED_2X2_FLOAT32}else if(e===TextureUsage.RENDER||e==null){return getPhysicalTextureForRendering(t)}else if(e===TextureUsage.DOWNLOAD||e===TextureUsage.PIXELS){return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE}throw new Error(`Unknown logical texture type ${e}`)}function getKeyFromTextureShape(e,t,n){return `${e[0]}_${e[1]}_${t}_${n}`}
class UnaryOpProgram{constructor(e,t){this.variableNames=["A"];this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;}}const CHECK_NAN_SNIPPET$1=`if (isnan(x)) return x;`;const LINEAR$1=`return x;`;const ABS=`return abs(x);`;const ELU$1=`return (x >= 0.0) ? x : (exp(x) - 1.0);`;const RELU$2=CHECK_NAN_SNIPPET$1+`\n  return (x < 0.0) ? 0.0 : x;\n`;const RELU6$1=CHECK_NAN_SNIPPET$1+`\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;const CLONE="return x;";const SIGMOID$2=`return 1.0 / (1.0 + exp(-1.0 * x));`
;const LINEAR=`return x;`;const ELU=`\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;const RELU$1=`\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const RELU6=`\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const SIGMOID$1=`return 1.0 / (1.0 + exp(-1.0 * x));`;class UnaryOpPackedProgram{constructor(e,t){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;}}
class UnpackProgram{constructor(e){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=false;this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);const t=e.length;const n=getChannels("rc",t);const r=getCoordsDataType(t);const s=getSourceCoords$1(t,n);const a=n.slice(-2);const o=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `;}}
const EPSILON_FLOAT32=1e-7;const EPSILON_FLOAT16=1e-4;const binaryCaches={};function getBinaryCache(e){if(e in binaryCaches){return binaryCaches[e]}binaryCaches[e]={};return binaryCaches[e]}const CPU_HANDOFF_SIZE_THRESHOLD=env().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");const BEFORE_PAGING_CONSTANT=600;function numMBBeforeWarning(){if(env().global.screen==null){return 1024}return env().global.screen.height*env().global.screen.width*window.devicePixelRatio*BEFORE_PAGING_CONSTANT/1024/1024}class MathBackendWebGL extends KernelBackend{constructor(e){super();this.pendingRead=new WeakMap;this.pendingDisposal=new WeakSet;this.dataRefCount=new WeakMap;this.numBytesInGPU=0;this.uploadWaitMs=0;this.downloadWaitMs=0;this.lastGlFlushTime=0;this.warnedAboutMemory=false;this.pendingDeletes=0;this.disposed=false;if(!env().getBool("HAS_WEBGL")){throw new Error("WebGL is not supported on this device")}let t;if(e!=null){if(e instanceof GPGPUContext){t=e;}else {const n=getWebGLContext(env().getNumber("WEBGL_VERSION"),e);t=new GPGPUContext(n);}this.binaryCache={};this.gpgpuCreatedLocally=false;}else {const e=getWebGLContext(env().getNumber("WEBGL_VERSION"));t=new GPGPUContext(e);this.binaryCache=getBinaryCache(env().getNumber("WEBGL_VERSION"));this.gpgpuCreatedLocally=true;}this.gpgpu=t;this.canvas=this.gpgpu.gl.canvas;this.textureManager=new TextureManager(this.gpgpu);this.numMBBeforeWarning=numMBBeforeWarning();this.texData=new DataStorage(this,engine());}nextDataId(){return MathBackendWebGL.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if(env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||env().getBool("DEBUG")){this.checkNumericalProblems(e);}if(n==="complex64"&&e!=null){throw new Error(`Cannot write to a complex64 dtype. `+`Please use tf.complex(real, imag).`)}const r={id:this.nextDataId()};this.texData.set(r,{shape:t,dtype:n,values:e,usage:TextureUsage.UPLOAD,refCount:1});return r}refCount(e){if(this.texData.has(e)){const t=this.texData.get(e);return t.refCount}return 0}incRef(e){const t=this.texData.get(e);t.refCount++;}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--;}}move(e,t,n,r,s){if(env().getBool("DEBUG")){this.checkNumericalProblems(t);}if(r==="complex64"){throw new Error(`Cannot write to a complex64 dtype. `+`Please use tf.complex(real, imag).`)}this.texData.set(e,{shape:n,dtype:r,values:t,usage:TextureUsage.UPLOAD,refCount:s});}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId);}readSync(e){const t=this.texData.get(e);const{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:o,isPacked:i}=t;if(a!=null){let t;if(i){t=new UnaryOpPackedProgram(o,CLONE);}else {t=new UnaryOpProgram(o,CLONE);}const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:r}],r);const s=this.readSync(n.dataId);this.disposeIntermediateTensorInfo(n);return s}if(n!=null){return this.convertAndCacheOnCPU(e)}if(r==="string"){return n}const c=this.activeTimers!=null;let u;if(c){u=now();}let l;if(r==="complex64"){const e=this.readSync(s.real.dataId);const t=this.readSync(s.imag.dataId);l=mergeRealAndImagArrays(e,t);}else {l=this.getValuesFromTexture(e);}if(c){this.downloadWaitMs+=now()-u;}return this.convertAndCacheOnCPU(e,l)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e);const{values:n,shape:r,slice:s,dtype:a,complexTensorInfos:o,isPacked:i}=t;if(s!=null){let t;if(i){t=new UnaryOpPackedProgram(r,CLONE);}else {t=new UnaryOpProgram(r,CLONE);}const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:a}],a);const s=this.read(n.dataId);this.disposeIntermediateTensorInfo(n);return s}if(n!=null){return this.convertAndCacheOnCPU(e)}if(env().getBool("DEBUG")){if(!env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&env().getNumber("WEBGL_VERSION")===2){throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and `+`WEBGL_VERSION=2 not yet supported.`)}}let c=null;let u;if(a!=="complex64"&&env().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const t=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...getDenseTexShape(r));}this.pendingRead.set(e,[]);if(a!=="complex64"){await this.gpgpu.createAndWaitForFence();}let l;if(a==="complex64"){const e=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]);const t=e[0];const n=e[1];l=mergeRealAndImagArrays(t,n);}else if(c==null){l=this.getValuesFromTexture(e);}else {const e=sizeFromShape(r);l=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e);}if(u!=null){this.disposeIntermediateTensorInfo(u);}if(c!=null){const e=this.gpgpu.gl;callAndCheck(e,(()=>e.deleteBuffer(c)));}const p=this.convertAndCacheOnCPU(e,l);const d=this.pendingRead.get(e);this.pendingRead.delete(e);d.forEach((e=>e(p)));if(this.pendingDisposal.has(e)){this.pendingDisposal.delete(e);if(this.disposeData(e)){engine().removeDataId(e,this);}this.pendingDeletes--;}return p}readToGPU(e,t={}){const n=this.texData.get(e);const{values:r,shape:s,slice:a,dtype:o,isPacked:i,texture:c}=n;if(o==="complex64"){throw new Error("Does not support reading texture for complex64 dtype.")}if(a!=null){let n;if(i){n=new UnaryOpPackedProgram(s,CLONE);}else {n=new UnaryOpProgram(s,CLONE);}const r=this.runWebGLProgram(n,[{dataId:e,shape:s,dtype:o}],o);const a=this.readToGPU(r,t);this.disposeIntermediateTensorInfo(r);return a}if(c==null){if(r!=null){throw new Error("Data is not on GPU but on CPU.")}else {throw new Error("There is no data on GPU or CPU.")}}const u=this.decode(e,t.customTexShape);const l=engine().makeTensorFromTensorInfo(u);const p=this.texData.get(u.dataId);return Object.assign({tensorRef:l},p.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string"){try{const n=t.map((e=>decodeString(e)));return buffer(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}}return buffer(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e==null){return}for(let t=0;t<e.length;t++){const n=e[t];if(!canBeRepresented(n)){if(env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")){throw Error(`The value ${n} cannot be represented with your `+`current settings. Consider enabling float32 rendering: `+`'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`)}throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e);const s=sizeFromShape(t);if(env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e);const r=this.texData.get(n.dataId);const a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...getDenseTexShape(t)).subarray(0,s);this.disposeIntermediateTensorInfo(n);return a}const a=env().getBool("WEBGL_PACK")&&r===true;const o=a?getShapeAs3D(t):t;const i=a?new EncodeFloatPackedProgram(o):new EncodeFloatProgram(o);const c=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:e}],"float32");const u=this.texData.get(c.dataId);const l=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);this.disposeIntermediateTensorInfo(c);return l}timerAvailable(){return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers;const n=[];let r=false;if(this.programTimersStack==null){this.programTimersStack=n;r=true;}else {this.activeTimers.push(n);}this.activeTimers=n;e();const s=flatten(this.activeTimers.map((e=>e.query))).filter((e=>e!=null));const a=flatten(this.activeTimers.map((e=>e.name))).filter((e=>e!=null));this.activeTimers=t;if(r){this.programTimersStack=null;}const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return (async()=>{if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);o["kernelMs"]=sum$2(e);o["getExtraProfileInfo"]=()=>e.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ");}else {o["kernelMs"]={error:"WebGL query timers are not supported in this environment."};}this.uploadWaitMs=0;this.downloadWaitMs=0;return o})()}memory(){return {unreliable:false,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){return this.gpgpu.beginQuery()}return {startMs:now(),endMs:null}}endTimer(e){if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){this.gpgpu.endQuery();return e}e.endMs=now();return e}async getQueryTime(e){if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){return this.gpgpu.waitForQueryAndGetTime(e)}const t=e;return t.endMs-t.startMs}disposeData(e,t=false){if(this.pendingDisposal.has(e)){return false}if(!this.texData.has(e)){return true}if(t){this.texData.get(e).refCount=0;}else {this.texData.get(e).refCount--;}if(!t&&this.texData.get(e).refCount>0){return false}if(this.pendingRead.has(e)){this.pendingDisposal.add(e);this.pendingDeletes++;return false}this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);if(n!=null){this.disposeData(n.real.dataId,t);this.disposeData(n.imag.dataId,t);}this.texData.delete(e);return true}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:o}=this.texData.get(e);const i=o&&o.origDataId||e;const c=this.dataRefCount.get(i);if(c>1){this.dataRefCount.set(i,c-1);}else {this.dataRefCount.delete(i);if(t!=null){this.numBytesInGPU-=this.computeBytes(r,n);this.textureManager.releaseTexture(t,r,s,a);}}const u=this.texData.get(e);u.texture=null;u.texShape=null;u.isPacked=false;u.slice=null;}getTexture(e){this.uploadToGPU(e);return this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=CPU_HANDOFF_SIZE_THRESHOLD){return env().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>this.texData.get(e.dataId).texture==null&&sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){warn("tf.where() in webgl locks the UI thread. "+"Call tf.whereAsync() instead");const t=e.dataSync();return whereImpl(e.shape,t)}packedUnaryOp(e,t,n){const r=new UnaryOpPackedProgram(e.shape,t);const s=this.compileAndRun(r,[e],n);return engine().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const t=simpleAbsImplCPU(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS")){return this.packedUnaryOp(e,ABS,e.dtype)}const t=new UnaryOpProgram(e.shape,ABS);const n=this.compileAndRun(t,[e]);return engine().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if(t==="string"&&n!=null&&n.length>0&&isString(n[0])){const s=n.map((e=>encodeString(e)));r=this.write(s,e,t);}else {r=this.write(n,e,t);}this.texData.get(r).usage=null;return {dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return engine().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new UnpackProgram(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new PackProgram(e.shape);const n=true;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){const n=[getBatchDim(e.shape),...getRowsCols(e.shape)];const r={dtype:e.dtype,shape:n,dataId:e.dataId};const s=[getBatchDim(t),...getRowsCols(t)];const a=new ReshapePackedProgram(s,n);const o=true;const i=[n];const c=this.runWebGLProgram(a,[r],e.dtype,i,o);return {dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const n=this.texData.get(e);const{isPacked:r,shape:s,dtype:a}=n;if(t!=null){const e=sizeFromShape(s);const n=t[0]*t[1]*4;assert(e<=n,(()=>"customTexShape is too small. "+"Row * Column * 4 should be equal or larger than the "+"size of the tensor data."));}const o=getShapeAs3D(s);let i;if(r){i=new DecodeMatrixPackedProgram(o);}else {i=new DecodeMatrixProgram(o);}const c=true;const u=[t!=null?t:getDenseTexShape(o)];const l=this.runWebGLProgram(i,[{shape:o,dtype:a,dataId:e}],a,u,c,t);return {dtype:a,shape:s,dataId:l.dataId}}runWebGLProgram(e,t,n,r,s=false,a){const o=this.makeTensorInfo(e.outputShape,n);const i=this.texData.get(o.dataId);if(e.packedOutput){i.isPacked=true;}if(e.outPackingScheme===PackingScheme.DENSE){const t=a!=null?a:getDenseTexShape(e.outputShape);i.texShape=t.map((e=>e*2));}if(e.outTexUsage!=null){i.usage=e.outTexUsage;}if(sizeFromShape(o.shape)===0){i.values=getTypedArrayFromDType(o.dtype,0);return o}const c=[];const u=t.map((t=>{if(t.dtype==="complex64"){throw new Error(`GPGPUProgram does not support complex64 input. For complex64 `+`dtypes, please separate the program into real and imaginary `+`parts.`)}let n=this.texData.get(t.dataId);if(n.texture==null){if(!e.packedInputs&&sizeFromShape(t.shape)<=env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")){return {shape:t.shape,texData:null,isUniform:true,uniformValues:n.values}}if(e.packedInputs){n.isPacked=true;n.shape=t.shape;}}this.uploadToGPU(t.dataId);if(!!n.isPacked!==!!e.packedInputs){t=n.isPacked?this.unpackTensor(t):this.packTensor(t);c.push(t);n=this.texData.get(t.dataId);}else if(n.isPacked&&!isReshapeFree(n.shape,t.shape)){const e=t;const r=t.shape;t.shape=n.shape;t=this.packedReshape(t,r);c.push(t);n=this.texData.get(t.dataId);e.shape=r;}return {shape:t.shape,texData:n,isUniform:false}}));this.uploadToGPU(o.dataId);const l={shape:o.shape,texData:i,isUniform:false};const p=makeShaderKey(e,u,l);const d=this.getAndSaveBinary(p,(()=>compileProgram(this.gpgpu,e,u,l)));const h=this.activeTimers!=null;let m;if(h){m=this.startTimer();}if(!env().get("ENGINE_COMPILE_ONLY")){runProgram(this.gpgpu,d,u,l,r);}c.forEach((e=>this.disposeIntermediateTensorInfo(e)));if(h){m=this.endTimer(m);this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)});}const f=env().get("WEBGL_FLUSH_THRESHOLD");if(f>0){const e=now();if(e-this.lastGlFlushTime>f){this.gpgpu.gl.flush();this.lastGlFlushTime=e;}}if(!env().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&s===false){const e=this.unpackTensor(o);this.disposeIntermediateTensorInfo(o);return e}return o}compileAndRun(e,t,n,r,s=false){n=n||t[0].dtype;const a=this.runWebGLProgram(e,t,n,r,s);return a}getAndSaveBinary(e,t){if(!(e in this.binaryCache)){this.binaryCache[e]=t();}return this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(this.disposed){return}if(!env().getBool("IS_TEST")){const e=Object.keys(this.binaryCache);e.forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram);delete this.binaryCache[e];}));}this.textureManager.dispose();if(this.canvas!=null&&(typeof HTMLCanvasElement!=="undefined"&&this.canvas instanceof HTMLCanvasElement)){this.canvas.remove();}else {this.canvas=null;}if(this.gpgpuCreatedLocally){this.gpgpu.program=null;this.gpgpu.dispose();}this.disposed=true;}floatPrecision(){if(this.floatPrecisionValue==null){this.floatPrecisionValue=tidy((()=>{if(!env().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=env().getBool("DEBUG");env().set("DEBUG",false);const t=this.abs(scalar(1e-8)).dataSync()[0];env().set("DEBUG",e);if(t>0){return 32}}return 16}));}return this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?EPSILON_FLOAT32:EPSILON_FLOAT16}uploadToGPU(e){const t=this.texData.get(e);const{shape:n,dtype:r,values:s,texture:a,usage:o,isPacked:i}=t;if(a!=null){return}const c=this.activeTimers!=null;let u;if(c){u=now();}let l=t.texShape;if(l==null){l=getTextureShapeFromLogicalShape(n,i);t.texShape=l;}if(s!=null){const e=getShapeAs3D(n);let a;let o=l[1],p=l[0];const d=s instanceof Uint8Array||s instanceof Uint8ClampedArray;if(i||!d){[o,p]=getPackedMatrixTextureShapeWidthHeight(l[0],l[1]);}if(i){a=new EncodeMatrixPackedProgram(e,d);}else {a=new EncodeMatrixProgram(e,d);}const h=d?[p,o]:l;const m=this.makeTensorInfo(h,r);const f=this.texData.get(m.dataId);if(d){f.usage=TextureUsage.PIXELS;}else {f.usage=TextureUsage.UPLOAD;}f.texShape=h;this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(m.dataId),o,p,s);const g=[[p,o]];const y=true;const x=this.runWebGLProgram(a,[m],r,g,y);const T=this.texData.get(x.dataId);t.texShape=T.texShape;t.isPacked=T.isPacked;t.usage=T.usage;if(!env().get("ENGINE_COMPILE_ONLY")){t.texture=T.texture;t.values=null;this.texData.delete(x.dataId);}else {this.disposeData(x.dataId);}this.disposeIntermediateTensorInfo(m);if(c){this.uploadWaitMs+=now()-u;}}else {const e=this.acquireTexture(l,o,r,i);t.texture=e;}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e);const{dtype:r}=n;this.releaseGPUData(e);if(t!=null){n.values=float32ToTypedArray(t,r);}return n.values}acquireTexture(e,t,n,r){this.numBytesInGPU+=this.computeBytes(e,n);if(!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=true;console.warn(`High memory usage in GPU: ${e} MB, `+`most likely due to a memory leak`);}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache)){this.checkCompletion_(e);}}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache)){e.push(this.checkCompletionAsync_(t));}return Promise.all(e)}else {for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t);e(true);}catch(e){throw e}}));e.push(n);}return Promise.all(e)}}async checkCompletionAsync_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)){return this.checkCompletion_(e)}else {await nextFrame();return this.checkCompletionAsync_(e)}}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===false){console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram));if(this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===false){logShaderSourceAndInfoLog(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader));throw new Error("Failed to compile fragment shader.")}throw new Error("Failed to link vertex and fragment shaders.")}return true}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:n,infLoc:r,nanLoc:s,inShapesLocations:a,inTexShapesLocations:o,outShapeLocation:i,outShapeStridesLocation:c,outTexShapeLocation:u}=getUniformLocations(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t;e.customUniformLocations=n;e.infLoc=r;e.nanLoc=s;e.inShapesLocations=a;e.inTexShapesLocations=o;e.outShapeLocation=i;e.outShapeStridesLocation=c;e.outTexShapeLocation=u;}}}MathBackendWebGL.nextDataId=0;function float32ToTypedArray(e,t){if(t==="float32"||t==="complex64"){return e}else if(t==="int32"||t==="bool"){const n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t){n[t]=Math.round(e[t]);}return n}else {throw new Error(`Unknown dtype ${t}`)}}
if(isBrowser()){registerBackend("webgl",(()=>new MathBackendWebGL),2);}
class BinaryOpProgram{constructor(e,t,n){this.variableNames=["A","B"];this.outputShape=assertAndGetBroadcastShape(t,n);this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `;}}
const CHECK_NAN_SNIPPET=`\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;class BinaryOpPackedProgram{constructor(e,t,n,r=false){this.variableNames=["A","B"];this.supportsBroadcasting=true;this.packedInputs=true;this.packedOutput=true;this.outputShape=assertAndGetBroadcastShape(t,n);const s=this.outputShape.length;this.enableShapeUniforms=useShapeUniforms(s);let a="";if(r){if(s===0||sizeFromShape(this.outputShape)===1){a=`\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        `;}else {const e=getCoordsDataType(s);a=`\n          ${e} coords = getOutputCoords();\n        `;if(s===1){if(this.enableShapeUniforms){a+=`\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;}else {a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;}}else {const e=getChannels("coords",s);if(this.enableShapeUniforms){a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `;}else {a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `;}}}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `;}}
function identity(e){const{inputs:t,backend:n}=e;const{x:r}=t;n.incRef(r.dataId);return {dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const identityConfig={kernelName:Identity,backendName:"webgl",kernelFunc:identity};
function complex(e){const{inputs:t,backend:n}=e;const{real:r,imag:s}=t;const a=n.makeTensorInfo(r.shape,"complex64");const o=n.texData.get(a.dataId);const i=identity({inputs:{x:r},backend:n});const c=identity({inputs:{x:s},backend:n});o.complexTensorInfos={real:i,imag:c};return a}
const LEAKYRELU=`return (a < 0.) ? b * a : a;`;const LEAKYRELU_PACKED=`\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`
;const PRELU=`return (a < 0.) ? b * a : a;`;const PRELU_PACKED=`\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`
;const CHECK_NAN_SNIPPET_UNARY=`if (isnan(x)) return x;`;function unaryKernelFunc({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return ({inputs:s,backend:a})=>{const{x:o}=s;const i=a;const c=r||o.dtype;if(i.shouldExecuteOnCPU([o])&&n!=null){const e=i.texData.get(o.dataId);const t=n(e.values,c);return i.makeTensorInfo(o.shape,c,t)}const u=env().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let l;if(u){l=new UnaryOpPackedProgram(o.shape,t);}else {l=new UnaryOpProgram(o.shape,e);}return i.runWebGLProgram(l,[o],c)}}function binaryKernelFunc({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=false,supportsComplex:r=false,cpuKernelImpl:s,dtype:a}){return ({inputs:o,backend:i})=>{const{a:c,b:u}=o;const l=i;if(r&&c.dtype==="complex64"){const t=l.texData.get(c.dataId);const n=l.texData.get(u.dataId);const[r,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t;const s={dataId:n.dataId,dtype:n.dtype,shape:c.shape};const a={dataId:r.dataId,dtype:r.dtype,shape:u.shape};const o=new BinaryOpProgram(e,c.shape,u.shape);return l.runWebGLProgram(o,[s,a],upcastType(n.dtype,r.dtype))}));const a=complex({inputs:{real:r,imag:s},backend:l});l.disposeIntermediateTensorInfo(r);l.disposeIntermediateTensorInfo(s);return a}const p=a||upcastType(c.dtype,u.dtype);if((c.dtype==="string"||u.dtype==="string"||l.shouldExecuteOnCPU([c,u]))&&s!=null){const e=l.texData.get(c.dataId).values;const t=l.texData.get(u.dataId).values;const n=c.dtype==="string"?fromUint8ToStringArray(e):e;const r=c.dtype==="string"?fromUint8ToStringArray(t):t;const[a,o]=s(c.shape,u.shape,n,r,p);const i=l.makeTensorInfo(o,p);const d=l.texData.get(i.dataId);d.values=a;return i}const d=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let h;if(d){h=new BinaryOpPackedProgram(t,c.shape,u.shape,n);}else {h=new BinaryOpProgram(e,c.shape,u.shape);}return l.runWebGLProgram(h,[c,u],p)}}function mapActivationToShaderProgram(e,t=false){if(e==="linear"){if(t){return LINEAR}return LINEAR$1}else if(e==="relu"){if(t){return RELU$1}return RELU$2}else if(e==="elu"){if(t){return ELU}return ELU$1}else if(e==="relu6"){if(t){return RELU6}return RELU6$1}else if(e==="prelu"){if(t){return PRELU_PACKED}return PRELU}else if(e==="leakyrelu"){if(t){return LEAKYRELU_PACKED}return LEAKYRELU}else if(e==="sigmoid"){if(t){return SIGMOID$1}return SIGMOID$2}throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}
const ADD="return a + b;";const addKernelFunc=binaryKernelFunc({opSnippet:ADD,packedOpSnippet:ADD,supportsComplex:true,cpuKernelImpl:addImplCPU});const addConfig={kernelName:Add,backendName:"webgl",kernelFunc:addKernelFunc};
class MeanProgram{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];const o=Math.floor(n/4)*4;const i=n%4;let c=`sumValue += dot(values, ones);`;if(t!=null){const e=1/t;c=`sumValue += dot(values * ${isInt(e)?e.toPrecision(2):e}, ones);`;}let u="";if(s%n>0){u=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `;}this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${i===1}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${i===2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${i===3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `;}}
class ReduceProgram{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let o="0.0";let i=``;if(t==="prod"){o="1.0";}else if(t==="min"){o="1.0 / 1e-20";i=`min`;}else if(t==="max"){o="-1.0 / 1e-20";i=`max`;}let c=`${t}(${t}(${t}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";if(t==="sum"){c=`sumValue`;}else if(t==="prod"){c=`prodValue`;}else if(t==="all"){c=`allValue`;}else if(t==="any"){c=`anyValue`;}const u=Math.floor(n/4)*4;const l=n%4;let p=`\n      if (${t==="sum"}) {\n        sumValue += dot(values, ones);\n      } else if (${t==="prod"}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${i}(values, minMaxValue);\n        if (${t==="min"} || ${t==="max"}) {\n          minMaxValue = ${i}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `;let d=`vec4`;if(t==="all"){o="1.0";p=`\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      `;d=`bvec4`;}else if(t==="any"){o="0.0";p=`\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      `;d=`bvec4`;}let h="";if(s%n>0){h=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `;}this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${p}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${l===1}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${p}\n        } else if (${l===2}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${p}\n        } else if (${l===3}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${p}\n        }\n        setOutput(${c});\n      }\n    `;}}
function getReductionStages(e){const t=[];while(t.length===0||t[t.length-1].outSize!==1){const n=t.length?t[t.length-1].outSize:e[1];const r=computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)});}return t}function reduce(e,t,n,r){const s=getReductionStages(e.shape);let a=e;for(let o=0;o<s.length;o++){const{inSize:i,windowSize:c,outSize:u}=s[o];let l;let p;if(n==="mean"){l=o===0?new MeanProgram({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:u},i):new MeanProgram({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:u});}else {l=new ReduceProgram({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:u},n);}p=a;a=r.runWebGLProgram(l,[a],t);if(p.dataId!==e.dataId){r.disposeIntermediateTensorInfo(p);}}return a}
function packedReshape(e,t,n){const r=[getBatchDim(e.shape),...getRowsCols(e.shape)];const s={dtype:e.dtype,shape:r,dataId:e.dataId};const a=[getBatchDim(t),...getRowsCols(t)];const o=new ReshapePackedProgram(a,r);const i=true;const c=[r];const u=n.runWebGLProgram(o,[s],e.dtype,c,i);return {dataId:u.dataId,shape:t,dtype:u.dtype}}
function reshape(e){const{inputs:t,backend:n,attrs:r}=e;const{x:s}=t;const{shape:a}=r;const o=n;const i=sizeFromShape(s.shape);const c=inferFromImplicitShape(a,i);const u=sizeFromShape(c);assert(i===u,(()=>`The new shape (${c}) has ${u} elements and the old `+`shape (${s.shape}) has ${i} elements. The new shape and old `+`shape must have the same number of elements.`));const l=o.texData.get(s.dataId);if(l.isPacked&&!isReshapeFree(s.shape,c)&&!(l.texture!==null&&isReshapeFree(l.shape,c))){return packedReshape(s,c,o)}o.incRef(s.dataId);return {dataId:s.dataId,shape:c,dtype:s.dtype}}const reshapeConfig={kernelName:Reshape,backendName:"webgl",kernelFunc:reshape};
class TransposeProgram{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++){n[r]=e[t[r]];}this.outputShape=n;this.rank=n.length;const r=getCoordsDataType(this.rank);const s=getSwitchedCoords(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `;}}function getSwitchedCoords(e){const t=e.length;if(t>6){throw Error(`Transpose for rank ${t} is not yet supported`)}const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"];const r=new Array(t);for(let t=0;t<e.length;t++){r[e[t]]=n[t];}return r.join()}
class TransposePackedProgram{constructor(e,t){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;const n=new Array(e.length);for(let r=0;r<n.length;r++){n[r]=e[t[r]];}this.outputShape=n;this.rank=n.length;if(this.rank>6){throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`)}const r=getCoordsDataType(this.rank);const s=getVecChannels("rc",this.rank);const a=new Array(this.rank);for(let e=0;e<t.length;e++){a[t[e]]=s[e];}const o=`vec2(${a.slice(-2).join()})`;const i=`++${s[this.rank-1]} < ${n[this.rank-1]}`;const c=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${i}) {\n        result[1] = ${c};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${c};\n        if(${i}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `;}}
function transposeImpl(e,t,n){const r=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TransposePackedProgram(e.shape,t):new TransposeProgram(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}
function sumImpl(e,t,n,r){const s=t;const a=e.shape.length;const o=parseAxisParam(s,e.shape);let i=o;const c=getAxesPermutation(i,a);const u=c!=null;let l=e;if(u){l=transposeImpl(e,c,r);i=getInnerMostAxes(i.length,a);}assertAxesAreInnerMostDims("sum",i,a);const[p,d]=computeOutAndReduceShapes(l.shape,i);let h=p;if(n){h=expandShapeToKeepDim(p,o);}const m=sizeFromShape(d);const f=sizeFromShape(e.shape);const g=f/m;const y=reshape({inputs:{x:l},attrs:{shape:[g,m]},backend:r});const x=sumOutType(e.dtype);const T=reduce(y,x,"sum",r);const b=reshape({inputs:{x:T},attrs:{shape:h},backend:r});r.disposeIntermediateTensorInfo(y);r.disposeIntermediateTensorInfo(T);if(u){r.disposeIntermediateTensorInfo(l);}return b}
function sum(e){const{inputs:t,backend:n,attrs:r}=e;const{x:s}=t;const{axis:a,keepDims:o}=r;return sumImpl(s,a,o,n)}const sumConfig={kernelName:Sum,backendName:"webgl",kernelFunc:sum};
const POW=`\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n`;const POW_PACKED=`\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  `+CHECK_NAN_SNIPPET+`\n  return result;\n`;const pow=binaryKernelFunc({opSnippet:POW,packedOpSnippet:POW_PACKED});const powConfig={kernelName:Pow,backendName:"webgl",kernelFunc:pow};
class ConcatProgram{constructor(e){this.outputShape=[];this.outputShape=computeOutShape$1(e,1);this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++){t[n]=t[n-1]+e[n][1];}const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) `+`setOutput(getT${e}(yR, yC-${r}));`);}const r=t.length;const s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`);this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `;}}
class ConcatPackedProgram{constructor(e,t){this.packedInputs=true;this.packedOutput=true;this.outputShape=[];this.outputShape=computeOutShape$1(e,t);const n=this.outputShape;const r=n.length;const s=getCoordsDataType(r);const a=getChannels("coords",r);const o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const i=new Array(e.length-1);i[0]=e[0][t];for(let n=1;n<i.length;n++){i[n]=i[n-1]+e[n][t];}const c=o[t];const u=o.slice(-2);const l=o.join();let p=`if (${c} < ${i[0]}) {\n        return getChannel(\n            getT0(${l}), vec2(${u.join()}));\n        }`;for(let e=1;e<i.length;e++){const t=i[e-1];p+=`\n        if (${c} < ${i[e]}  && ${c} >= ${i[e-1]}) {\n          return getChannel(\n            getT${e}(${shiftedChannels(o,c,t)}),\n            vec2(${shiftedChannels(u,c,t)}));\n        }`;}const d=i.length;const h=i[i.length-1];p+=`\n        return getChannel(\n          getT${d}(${shiftedChannels(o,c,h)}),\n          vec2(${shiftedChannels(u,c,h)}));`;this.userCode=`\n      float getValue(${o.map((e=>"int "+e))}) {\n        ${p}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `;}}function shiftedChannels(e,t,n){const r=e.indexOf(t);const s=e.map(((e,t)=>{if(t===r){return `${e} - ${n}`}else {return e}}));return s.join()}
function real(e){const{inputs:t,backend:n}=e;const{input:r}=t;const s=n.texData.get(r.dataId);return identity({inputs:{x:s.complexTensorInfos.real},backend:n})}
function concatImpl(e,t,n){const r=e[0].dtype;if(r==="complex64"){const r=e.map((e=>real({inputs:{input:e},backend:n})));const s=e.map((e=>imag({inputs:{input:e},backend:n})));const a=concatImpl(r,t,n);const o=concatImpl(s,t,n);const i=complex({inputs:{real:a,imag:o},backend:n});r.forEach((e=>n.disposeIntermediateTensorInfo(e)));s.forEach((e=>n.disposeIntermediateTensorInfo(e)));n.disposeIntermediateTensorInfo(a);n.disposeIntermediateTensorInfo(o);return i}let s=n.shouldExecuteOnCPU(e);if(r==="string"){s=true;}if(s){const s=e.map((e=>{const r=sizeFromShape(e.shape.slice(t));const s=[-1,r];return reshape({inputs:{x:e},backend:n,attrs:{shape:s}})}));const a=s.map((e=>({vals:n.readSync(e.dataId),shape:e.shape})));const o=computeOutShape$1(s.map((e=>e.shape)),1);const i=s[0].shape[0]===1;const c=concatImplCPU(a,o,r,i);const u=computeOutShape$1(e.map((e=>e.shape)),t);const l=n.makeTensorInfo(u,r,c);s.forEach((e=>n.disposeIntermediateTensorInfo(e)));return l}const a=env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(e.length>a){const r=[];for(let s=0;s<e.length;s+=a){const o=e.slice(s,s+a);r.push(concatImpl(o,t,n));}const s=concatImpl(r,t,n);for(const e of r){n.disposeIntermediateTensorInfo(e);}return s}if(env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const s=new ConcatPackedProgram(e.map((e=>e.shape)),t);return n.runWebGLProgram(s,e,r)}const{tensors2D:o,outShape:i}=computeTensors2D(e,t,n);const c=new ConcatProgram(o.map((e=>e.shape)));const u=n.runWebGLProgram(c,o,r);o.forEach((e=>n.disposeIntermediateTensorInfo(e)));const l=reshape({inputs:{x:u},attrs:{shape:i},backend:n});n.disposeIntermediateTensorInfo(u);return l}
function concat(e){const{inputs:t,backend:n,attrs:r}=e;const{axis:s}=r;const a=parseAxisParam(s,t[0].shape)[0];const o=computeOutShape$1(t.map((e=>e.shape)),a);if(sizeFromShape(o)===0){return n.makeTensorInfo(o,t[0].dtype,[])}const i=t.filter((e=>sizeFromShape(e.shape)>0));if(i.length===1){return identity({inputs:{x:i[0]},backend:n})}const c=i.map((e=>e.shape));assertParamsConsistent(c,a);return concatImpl(i,a,n)}const concatConfig={kernelName:Concat,backendName:"webgl",kernelFunc:concat};
function expandDims(e){const{inputs:t,attrs:n,backend:r}=e;const{dim:s}=n;const{input:a}=t;const o=a.shape.length;const i=a.shape.slice();let c=s;if(s<0){assert(-(o+1)<=s,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`));c=o+s+1;}i.splice(c,0,1);return reshape({inputs:{x:a},backend:r,attrs:{shape:i}})}
function pack(e){const{inputs:t,backend:n,attrs:r}=e;const{axis:s}=r;if(t.length===1){return expandDims({inputs:{input:t[0]},backend:n,attrs:{dim:s}})}const a=t[0].shape;const o=t[0].dtype;t.forEach((e=>{assertShapesMatch(a,e.shape,"All tensors passed to stack must have matching shapes");assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"));}));const i=[];const c=t.map((e=>{const t=expandDims({inputs:{input:e},backend:n,attrs:{dim:s}});i.push(t);return t}));const u=concat({inputs:c,backend:n,attrs:{axis:s}});i.forEach((e=>n.disposeIntermediateTensorInfo(e)));return u}const packConfig={kernelName:Pack,backendName:"webgl",kernelFunc:pack};
const NOT_EQUAL=`return float(a != b);`;const notEqual=binaryKernelFunc({opSnippet:NOT_EQUAL,cpuKernelImpl:notEqualImplCPU,dtype:"bool"});
function cast(e){const{inputs:t,backend:n,attrs:r}=e;const{x:s}=t;const{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64"){return identity({inputs:{x:s},backend:n})}const e=zeros$1(s.shape);const t=cast({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});const r=complex({inputs:{real:t,imag:e},backend:n});e.dispose();n.disposeIntermediateTensorInfo(t);return r}if(s.dtype==="complex64"){const e=real({inputs:{input:s},backend:n});const t=cast({inputs:{x:e},backend:n,attrs:{dtype:a}});n.disposeIntermediateTensorInfo(e);return t}if(!hasEncodingLoss(s.dtype,a)){const e=identity({inputs:{x:s},backend:n});return {dataId:e.dataId,shape:e.shape,dtype:a}}if(a==="int32"){return int(s,n)}if(a==="bool"){const e=n.makeTensorInfo([],"bool",getTypedArrayFromDType("bool",1));const t={a:s,b:e};const r=notEqual({inputs:t,backend:n});n.disposeIntermediateTensorInfo(e);return r}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}const castConfig={kernelName:Cast,backendName:"webgl",kernelFunc:cast};
const RELU=CHECK_NAN_SNIPPET$1+`\n  return (x < 0.0) ? 0.0 : x;\n`;const RELU_PACKED=`\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const relu=unaryKernelFunc({opSnippet:RELU,packedOpSnippet:RELU_PACKED});const reluConfig={kernelName:Relu,backendName:"webgl",kernelFunc:relu};
function meanImpl(e,t,n,r){const s=sizeFromShape(t);const a=sizeFromShape(e.shape);const o=a/s;const i=reshape({inputs:{x:e},attrs:{shape:[o,s]},backend:r});const c=reduce(i,"float32","mean",r);const u=reshape({inputs:{x:c},attrs:{shape:n},backend:r});r.disposeIntermediateTensorInfo(i);r.disposeIntermediateTensorInfo(c);return u}
const meanConfig={kernelName:Mean,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e;const{keepDims:s,axis:a}=t;const o=n;const i=r.shape.length;const c=parseAxisParam(a,r.shape);let u=c;const l=getAxesPermutation(u,i);const p=l!=null;const d=o.shouldExecuteOnCPU([r]);const h=[];let m=r;if(p){if(d){const e=o.texData.get(m.dataId);const t=e.values;const n=new Array(i);for(let e=0;e<n.length;e++){n[e]=r.shape[l[e]];}const s=transposeImplCPU(t,r.shape,r.dtype,l,n);m=o.makeTensorInfo(n,r.dtype);const a=o.texData.get(m.dataId);a.values=s;}else {m=transposeImpl(r,l,o);}h.push(m);u=getInnerMostAxes(u.length,i);}assertAxesAreInnerMostDims("sum",u,i);const[f,g]=computeOutAndReduceShapes(m.shape,u);let y=f;if(s){y=expandShapeToKeepDim(f,c);}const x=meanImpl(m,g,y,o);for(const e of h){o.disposeIntermediateTensorInfo(e);}return x}};
function prod(e){const{inputs:t,backend:n,attrs:r}=e;const{x:s}=t;const{axis:a,keepDims:o}=r;const i=s.shape.length;const c=[];const u=parseAxisParam(a,s.shape);let l=u;const p=getAxesPermutation(l,i);let d=s;if(p!=null){d=transpose({inputs:{x:s},backend:n,attrs:{perm:p}});l=getInnerMostAxes(l.length,i);c.push(d);}assertAxesAreInnerMostDims("prod",l,i);let h;if(n.shouldExecuteOnCPU([d])){const e=n.texData.get(d.dataId).values;const{outVals:t,outShape:r,outDtype:s}=prodImplCPU(d.shape,d.dtype,e,l);h=n.makeTensorInfo(r,s,t);}else {const[e,t]=computeOutAndReduceShapes(d.shape,l);const r=sizeFromShape(t);const a=reshape({inputs:{x:d},backend:n,attrs:{shape:[-1,r]}});const o=sumOutType(s.dtype);const i=reduce(a,o,"prod",n);h=reshape({inputs:{x:i},backend:n,attrs:{shape:e}});c.push(a);c.push(i);}if(o){c.push(h);const e=expandShapeToKeepDim(h.shape,u);h=reshape({inputs:{x:h},backend:n,attrs:{shape:e}});}c.forEach((e=>n.disposeIntermediateTensorInfo(e)));return h}const prodConfig={kernelName:Prod,backendName:"webgl",kernelFunc:prod};
class PadProgram{constructor(e,t,n){this.variableNames=["x"];this.customUniforms=[{name:"value",type:"float"}];this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length;const s=getCoordsDataType(r);const a=t.map((e=>e[0])).join(",");const o=t.map(((t,n)=>t[0]+e[n])).join(",");const i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`\n        int start = ${a};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `;return}this.userCode=`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${o});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `;}}
class PadPackedProgram{constructor(e,t,n){this.variableNames=["x"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"value",type:"float"}];this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length;const s=getCoordsDataType(r);const a=t.map((e=>e[0])).join(",");const o=t.map(((t,n)=>t[0]+e[n])).join(",");const i=getChannels("rc",r);const c=getChannels("source",r);const u=`${i[r-1]} < ${this.outputShape[r-1]}`;const l=r===1?"source":`vec2(${c.slice(-2).join()})`;const p=[`${s} rc = outputLoc;`,`${i[r-1]} += 1;\n       if(${u}) {\n      `,r===1?"":`}\n       rc = outputLoc;\n       ${i[r-2]} += 1;\n       if(${i[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${i[r-1]} += 1;\n         if(${u}) {`];const d=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let h="";for(let e=0,t=r===1?2:4;e<t;e++){h+=`\n        ${p[e]}\n        if (${d}) {\n          result[${e}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${e}] = getChannel(getX(${c.join()}), ${l});\n        }\n      `;}h+=r===1?`} `:`}}`;this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${o});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `;}}
const padV2=e=>{const{inputs:t,backend:n,attrs:r}=e;const{x:s}=t;const{paddings:a,constantValue:o}=r;if(sizeFromShape(s.shape)===0){const e=a.map(((e,t)=>e[0]+s.shape[t]+e[1]));return fill({backend:n,attrs:{shape:e,value:o,dtype:s.dtype}})}const i=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PadPackedProgram(s.shape,a,o):new PadProgram(s.shape,a,o);const c=[[o]];return n.runWebGLProgram(i,[s],s.dtype,c)};const padV2Config={kernelName:PadV2,backendName:"webgl",kernelFunc:padV2};
class SliceProgram{constructor(e){this.variableNames=["source"];this.outputShape=e;this.rank=e.length;const t=getCoordsDataType(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=getCoords(this.rank);let r;const s=e.map(((e,t)=>`sourceLoc.${coords[t]} = start[${t}] + coords.${coords[t]};`));r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${s.join("\n")}\n      `;this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `;}}const coords=["x","y","z","w","u","v"];function getCoords(e){if(e===1){return "sourceLoc"}else if(e<=6){return coords.slice(0,e).map((e=>"sourceLoc."+e)).join(",")}else {throw Error(`Slicing for rank ${e} is not yet supported`)}}
class SlicePackedProgram{constructor(e){this.variableNames=["source"];this.packedInputs=true;this.packedOutput=true;this.outputShape=e;this.rank=e.length;this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=getCoordsDataType(this.rank);const n=getChannels("coords",this.rank);const r=getChannels("sourceLoc",this.rank);const s=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`;const a=`getChannel(getSource(${r.join()}), ${s})`;const o=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `;const i=this.rank===1?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `;const c=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${c}\n        vec4 result = vec4(0.);\n        ${o}\n        ${i}\n        setOutput(result);\n      }\n    `;}}
function slice(e){const{inputs:t,backend:n,attrs:r}=e;const{x:s}=t;const{begin:a,size:o}=r;const[i,c]=parseSliceParams(s,a,o);assertParamsValid(s,i,c);if(sizeFromShape(c)===0){return n.makeTensorInfo(c,s.dtype,[])}if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){const e=n.texData.get(s.dataId);const t=sliceImplCPU(e.values,i,c,s.shape,s.dtype);return n.makeTensorInfo(c,s.dtype,t)}const{isPacked:u}=n.texData.get(s.dataId);const l=isSliceContinous(s.shape,i,c);if(u||!l){const e=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SlicePackedProgram(c):new SliceProgram(c);const t=[i];return n.runWebGLProgram(e,[s],s.dtype,t)}n.uploadToGPU(s.dataId);return shallowSlice(s,i,c,n)}
function unpack(e){const{inputs:t,backend:n,attrs:r}=e;const{value:s}=t;let{axis:a}=r;if(a<0){a+=s.shape.length;}const o=s;const i=o.shape.length;const c=s.shape[a];const u=new Array(i-1);let l=0;for(let e=0;e<i;e++){if(e!==a){u[l++]=o.shape[e];}}const p=[];const d=new Array(i).fill(0);const h=o.shape.slice();h[a]=1;const m=new Array(c);for(let e=0;e<m.length;e++){d[a]=e;const t=slice({inputs:{x:o},backend:n,attrs:{begin:d,size:h}});const r=reshape({inputs:{x:t},backend:n,attrs:{shape:u}});m[e]=r;p.push(t);}p.forEach((e=>n.disposeIntermediateTensorInfo(e)));return m}const unpackConfig={kernelName:Unpack,backendName:"webgl",kernelFunc:unpack};
const IS_FINITE=`return float(!isnan(x) && !isinf(x));`;const isFinite$1=unaryKernelFunc({opSnippet:IS_FINITE,dtype:"bool"});const isFiniteConfig={kernelName:IsFinite,backendName:"webgl",kernelFunc:isFinite$1};
class SelectProgram{constructor(e,t,n){this.variableNames=["c","a","b"];this.outputShape=t;let r;let s;if(n>4){throw Error(`Where for rank ${n} is not yet supported`)}if(n===1){s=`resRC`;r=`resRC`;}else {const n=["resRC.x","resRC.y","resRC.z","resRC.w"];const a=[];const o=[];for(let r=0;r<t.length;r++){o.push(`${n[r]}`);if(r<e){a.push(`${n[r]}`);}}r=a.join();s=o.join();}const a=getCoordsDataType(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `;}}
function select(e){const{inputs:t,backend:n}=e;const{condition:r,t:s,e:a}=t;const o=new SelectProgram(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(o,[r,s,a],upcastType(s.dtype,a.dtype))}const selectConfig={kernelName:Select,backendName:"webgl",kernelFunc:select};
const COMPLEX_MULTIPLY={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class BinaryOpComplexProgram{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"];this.outputShape=assertAndGetBroadcastShape(t,n);this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `;}}
const MUL="return a * b;";function multiply(e){const{inputs:t,backend:n}=e;const{a:r,b:s}=t;const a=upcastType(r.dtype,s.dtype);if(r.dtype==="complex64"){const e=n.texData.get(r.dataId);const t=n.texData.get(s.dataId);const a=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL,r.shape,s.shape);const o=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG,r.shape,s.shape);const i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}];const c=n.runWebGLProgram(a,i,"float32");const u=n.runWebGLProgram(o,i,"float32");const l=complex({inputs:{real:c,imag:u},backend:n});n.disposeIntermediateTensorInfo(c);n.disposeIntermediateTensorInfo(u);return l}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId);const t=n.texData.get(s.dataId);const[o,i]=multiplyImplCPU(r.shape,s.shape,e.values,t.values,a);const c=n.makeTensorInfo(i,a);const u=n.texData.get(c.dataId);u.values=o;return c}let o;if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS")){o=new BinaryOpPackedProgram(MUL,r.shape,s.shape);}else {o=new BinaryOpProgram(MUL,r.shape,s.shape);}return n.runWebGLProgram(o,[r,s],a)}const multiplyConfig={kernelName:Multiply,backendName:"webgl",kernelFunc:multiply};
class MatMulPackedProgram{constructor(e,t,n,r=false,s=false,a=false,o=null,i=false,c=false){this.variableNames=["matrixA","matrixB"];this.packedInputs=true;this.packedOutput=true;this.outputShape=n;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);const u=r?e[1]:e[2];const l=Math.ceil(u/2);const p=r?"i * 2, rc.y":"rc.y, i * 2";const d=s?"rc.z, i * 2":"i * 2, rc.z";const h=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"];const m=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",g="";if(o){if(i){f=`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`;}else if(c){f=`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`;}else {f=`vec4 activation(vec4 x) {\n          ${o}\n        }`;}g=`result = activation(result);`;}const y=a?"result += getBiasAtOutCoords();":"";if(a){this.variableNames.push("bias");}if(i){this.variableNames.push("preluActivationWeights");}if(c){this.variableNames.push("leakyreluAlpha");}let x="rc.x";let T="rc.x";if(e[0]<t[0]){x=`int(min(float(rc.x), ${e[0]-1}.))`;}else if(t[0]<e[0]){T=`int(min(float(rc.x), ${t[0]-1}.))`;}this.userCode=`\n      ${f}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${l}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${l}; i++) {\n          int batchA = ${x};\n          int batchB = ${T};\n          vec4 a = getMatrixA(batchA, ${p});\n          vec4 b = getMatrixB(batchB, ${d});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${m[0]});\n          result += (${h[1]} * ${m[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `;}}
const MATMUL_SHARED_DIM_THRESHOLD=1e3;function batchMatMulImpl({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:c=null}){const u=e.shape.length;const l=t.shape.length;const p=n?e.shape[u-2]:e.shape[u-1];const d=r?t.shape[l-1]:t.shape[l-2];const h=n?e.shape[u-1]:e.shape[u-2];const m=r?t.shape[l-2]:t.shape[l-1];const f=e.shape.slice(0,-2);const g=t.shape.slice(0,-2);const y=sizeFromShape(f);const x=sizeFromShape(g);const T=assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2));const b=T.concat([h,m]);assert(p===d,(()=>`Error in matMul: inner shapes (${p}) and (`+`${d}) of Tensors with shapes ${e.shape} and `+`${t.shape} and transposeA=${n}`+` and transposeB=${r} must match.`));const E=n?[y,p,h]:[y,h,p];const S=r?[x,m,d]:[x,d,m];const v=reshape({inputs:{x:e},backend:s,attrs:{shape:E}});const N=reshape({inputs:{x:t},backend:s,attrs:{shape:S}});const I=[v,N];const _=Math.max(y,x);const w=n?v.shape[1]:v.shape[2];const $=a!=null;const A=o!=null;const k=c==="leakyrelu";const P=c!=null?mapActivationToShaderProgram(c,true):null;const O=$||A||k||P!=null;let C;if((h===1||m===1)&&w>MATMUL_SHARED_DIM_THRESHOLD&&O===false){let e=v;let t=N;if(n){e=transpose({inputs:{x:v},backend:s,attrs:{perm:[0,2,1]}});I.push(e);}if(r){t=transpose({inputs:{x:N},backend:s,attrs:{perm:[0,2,1]}});I.push(t);}const a=m!==1;const o=m===1;let i=e;if(a){i=reshape({inputs:{x:e},backend:s,attrs:{shape:[_,w,1]}});I.push(i);}const c=m===1?2:1;let u=t;if(o){u=reshape({inputs:{x:t},backend:s,attrs:{shape:[_,1,w]}});I.push(u);}const l=multiply({inputs:{a:i,b:u},backend:s});C=sum({inputs:{x:l},backend:s,attrs:{axis:c,keepDims:true}});I.push(l);}else {const c=upcastType(e.dtype,t.dtype);const u=new MatMulPackedProgram(E,S,[_,h,m],n,r,$,P,A,k);const l=[v,N];if(a!=null){l.push(a);}if(A){l.push(o);}if(k){const e=s.makeTensorInfo([],"float32",createScalarValue(i,"float32"));l.push(e);I.push(e);}C=s.runWebGLProgram(u,l,c);}const R=reshape({inputs:{x:C},backend:s,attrs:{shape:b}});I.push(C);for(const e of I){s.disposeIntermediateTensorInfo(e);}return R}
function batchMatMul(e){const{inputs:t,backend:n,attrs:r}=e;const{a:s,b:a}=t;const{transposeA:o,transposeB:i}=r;return batchMatMulImpl({a:s,b:a,transposeA:o,transposeB:i,backend:n})}const batchMatMulConfig={kernelName:BatchMatMul,backendName:"webgl",kernelFunc:batchMatMul};
class GatherProgram{constructor(e,t){this.variableNames=["A","indices"];this.outputShape=t;this.rank=t.length;const n=getCoordsDataType(this.rank);const r=getSourceCoords(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `;}}function getSourceCoords(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"];const r=[];for(let t=0;t<e.length;t++){if(t===2){r.push("index");}else {r.push(`${n[t]}`);}}return r.join()}
function gatherV2(e){const{inputs:t,backend:n,attrs:r}=e;const{x:s,indices:a}=t;const{axis:o,batchDims:i}=r;const c=parseAxisParam(o,s.shape)[0];if(env().get("DEBUG")){const e=n.readSync(a.dataId);const t=s.shape[c];for(let n=0;n<e.length;++n){const r=e[n];assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`));}}const u=collectGatherOpShapeInfo(s,a,c,i);const l=sizeFromShape(a.shape);const p=[];const d=reshape({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}});const h=reshape({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,l/u.batchSize]}});p.push(d);p.push(h);const m=[u.batchSize,u.outerSize,l/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])||s.dtype==="string"){const e=n.bufferSync(h);const t=n.bufferSync(d);const r=gatherV2ImplCPU(t,e,m);p.forEach((e=>n.disposeIntermediateTensorInfo(e)));return n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const f=new GatherProgram(d.shape,m);const g=n.runWebGLProgram(f,[d,h],d.dtype);p.push(g);const y=reshape({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});p.forEach((e=>n.disposeIntermediateTensorInfo(e)));return y}const gatherV2Config={kernelName:GatherV2,backendName:"webgl",kernelFunc:gatherV2};
const SIGMOID=CHECK_NAN_SNIPPET_UNARY+`\n  return 1.0 / (1.0 + exp(-1.0 * x));\n`;const SIGMOID_PACKED=`\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const sigmoid=unaryKernelFunc({opSnippet:SIGMOID,packedOpSnippet:SIGMOID_PACKED,cpuKernelImpl:sigmoidImplCPU});const sigmoidConfig={kernelName:Sigmoid,backendName:"webgl",kernelFunc:sigmoid};
function _fusedMatMul(e){const{inputs:t,backend:n,attrs:r}=e;const{a:s,b:a,bias:o,preluActivationWeights:i}=t;const{transposeA:c,transposeB:u,activation:l,leakyreluAlpha:p}=r;return batchMatMulImpl({a:s,b:a,transposeA:c,transposeB:u,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:p,activation:l})}const _fusedMatMulConfig={kernelName:_FusedMatMul,backendName:"webgl",kernelFunc:_fusedMatMul};for(let e of [addConfig,sumConfig,powConfig,packConfig,castConfig,reluConfig,meanConfig,prodConfig,padV2Config,unpackConfig,reshapeConfig,isFiniteConfig,identityConfig,selectConfig,multiplyConfig,batchMatMulConfig,gatherV2Config,concatConfig,sigmoidConfig,_fusedMatMulConfig])registerKernel(e);

var tfjs = /*#__PURE__*/Object.freeze({
   __proto__: null,
   cast: cast$1,
   enableProdMode: enableProdMode,
   env: env,
   loadGraphModel: loadGraphModel,
   oneHot: oneHot,
   stack: stack,
   sum: sum$1,
   tensor: tensor,
   tidy: tidy,
   unstack: unstack,
   zeros: zeros$1
});

// noinspection JSUnusedLocalSymbols

const WHITESPACE_PATTERN = /\s+/g;
const PUNCTUATION_PATTERN = /[\xA0!"\\'()*,-./:;?&[\]^_`{|}~“”]/g;
const RGB_PATTERN = /rgb\((\d+), (\d+), (\d+)\)/;
const RGBA_PATTERN = /rgba\((\d+), (\d+), (\d+), (\d+)\)/;
const ORIGIN_PATTERN = /(\d*?\.?\d*)px (\d*?\.?\d*)px/;
const PIXEL_PATTERN = /(\d*?\.?\d*)px/;
const DOT_PATTERN = /\./g;
const BRACKETS_PATTERN = /^\[|\]$/g;
const SLASH_PATTERN = /\//g;
const WORD_INDEX =
  Object.fromEntries([..." abcdefghijklmnopqrstuvwxyz1234567890:;/?!=+.,()[]-`*_|~"].map((c, i) => [c, i + 1]));


/**
 * Base class for normalizers.
 * Usage:
 *     from feature.normalizer import Lowercase
 *     from feature.normalizer import CollapseWhitespace
 *
 *     >>> f = FeatureNormalizer(Lowercase, CollapseWhitespace)
 *     >>> f.normalize(u'HouSEs   Var')
 *     >>> u'houses var'
 *
 *     Normalizers are applied in the order which they are passed in,
 *     so the outcome may differ only because of the ordering, e.g.:
 *
 *     >>> f1 = FeatureNormalizer(ReplacePunctuation, CollapseWhitespace)
 *     >>> f1.normalize('abc???abc')
 *     >>> 'abc abc'
 *     >>> f2 = FeatureNormalizer(CollapseWhitespace, ReplacePunctuation)
 *     >>> f2.normalize('abc???abc')
 *     >>> u'abc   abc'
 */
class FeatureNormalizer {
  constructor(args) {
    this.normalizers = [];
    args.forEach(normalizer => {
      if (Array.isArray(normalizer)) {
        let [norm, kwargs] = normalizer;
        this.normalizers.push(new norm(kwargs));
      }
      else {
        this.normalizers.push(new normalizer());
      }
    }
    );
  }

  normalize(feature, kwargs) {
    this.normalizers.forEach(normalizer => {
      feature = normalizer.normalize(feature, kwargs);
    });
    return feature;
  }
}


class StringNormalizer {
  normalize(str) {
    throw new Error("Not implemented.");
  }
}

/**
 *   Transform all characters to lowercase.
 *
 *     >>> normalize('AbC DeF')
 *     >>> 'abc def'
 */
class Lowercase extends StringNormalizer {
  normalize(str) {
    return str.toLowerCase();
  }
}

/**
 * Strip white spaces from the beginning and end of string.
 *
 *     >>> normalize('  a   ')
 *     >>> 'a'
 */
class StripWhitespace extends StringNormalizer {
  normalize(str) {
    return str.trim();
  }
}

/**
 * Replace multiple white spaces with a single whitespace.
 *
 *     >>> normalize('  a  b c d  ')
 *     >>> ' a b c d '
 */
class CollapseWhitespace extends StringNormalizer {
  normalize(str) {
    return str.replace(WHITESPACE_PATTERN, " ");
  }
}

/**
 * Strip and collapse white spaces from a string.
 */
class StripAndCollapseWhitespace extends StringNormalizer {
  normalize(str) {
    return str.replace(WHITESPACE_PATTERN, " ").trim();
  }
}

/**
 * Remove punctuation.
 */
class RemovePunctuation extends StringNormalizer {
  normalize(str) {
    return str.replace(PUNCTUATION_PATTERN, "");
  }
}

/**
 * Replace punctuation with a whitespace.
 */
class ReplacePunctuation extends StringNormalizer {
  normalize(str) {
    return str.replace(PUNCTUATION_PATTERN, " ");
  }
}

/**
 * Replace old with new values.
 */
class ReplaceStr extends StringNormalizer {
  constructor(pairs) {
    super();
    this.pairs = pairs;
  }

  normalize(str) {
    if (str) {
      this.pairs.forEach(pair => {
        str = str.replaceAll(pair[0], pair[1]);
      });
    }
    return str;
  }
}

/**
 * Extract only the last CSS class in the CSS class sequence.
 * >>> normalize('rq0escxv l9j0dhe7 du4w35lb hybvsw6c io0zqebd m5lcvass')
 * >>> 'm5lcvass'
 */
class LastCSSClassNormalizer extends StringNormalizer {
  normalize(str) {
    return str.split(" ").pop();
  }
}


class VectorNormalizer {
  normalize(str) {
    throw new Error("Not implemented.");
  }
}

class FloatNormalizer extends VectorNormalizer {
  normalize(str) {
    return [parseFloat(str) || 0];
  }
}

/**
 * Generates a sequence for a given string based on a WORD_INDEX
 */
class SequenceNormalizer extends VectorNormalizer {
  /**
   * @param {number} maxLen - the maximum length of the sequences
   */
  constructor(maxLen) {
    super();
    this.maxLen = maxLen;
  }

  /**
   *
   * @param {string} str - the string to generate the sequence for
   * @returns {Array} - the generated sequence
   */
  normalize(str) {
    let seq = [...str.toLowerCase()].slice(-this.maxLen).map(c => c in WORD_INDEX ? WORD_INDEX[c] : 1);
    return seq.length >= this.maxLen ? seq : seq.concat(new Array(this.maxLen - seq.length).fill(0));
    // Candidates for potential better performance:
    // -------
    // return [...str.toLowerCase()]
    //   .slice(-this.maxLen)
    //   .map(c => WORD_INDEX[c] ?? 1)
    //   .concat(
    //     (new Array(Math.max(0, this.maxLen - str.length)).fill(0))
    //   );
    // -------
    // return Object.assign(
    //   (new Array(this.maxLen)).fill(0),
    //   [...str.toLowerCase()].slice(-this.maxLen).map(c => WORD_INDEX[c] ?? 1)
    // );
    // -------
  }
}

class OneHotVectorNormalizer extends VectorNormalizer {
  constructor(values) {
    super();
    const len = values.length;
    this.empty = new Array(len).fill(0);
    // Optimized for performance
    let i = 0;
    this.categoryMap = values.reduce((map, val) => {
      let oneHot = [...this.empty];
      oneHot[i++] = 1;
      map[val] = oneHot;
      return map;
    }, {});
  }

  normalize(str) {
    return this.categoryMap[str] || this.empty;
  }
}

class FontSizeNormalizer extends VectorNormalizer {
  normalize(str) {
    return [parseFloat(str) || 0];
  }
}

/**
 * Extract and normalize RGB colors from a CSS string.
 *
 *     >>> cn = ColorNormalizer(3)
 *     >>> cn.normalize('rgb(255, 0, 255);')
 *     >>> [255.0, 0.0, 255.0]
 *     >>> cn.normalize('rgba(255, 0, 255, 0);')
 *     >>> [255.0, 0.0, 255.0]
 *
 *     >>> cn = ColorNormalizer(4)
 *     >>> cn.normalize('rgb(255, 0, 255);')
 *     >>> [255.0, 0.0, 255.0, 0.0]
 *     >>> normalize('rgba(255, 0, 255, 0);')
 *     >>> [255.0, 0.0, 255.0, 0.0]
 *
 *     TODO: cover cases when color is not in RGB format, e.g. 'red', '#090a', or
 *     'hsl(30, 100%, 50%, 0.6)'
 *     How often do we see other color formats? -> 100% RGB
 */
class ColorNormalizer extends VectorNormalizer {
  /**
   * @param {number} maxLen - the maximum length of the sequences
   */
  constructor(maxLen) {
    super();
    this.maxLen = maxLen;
  }

  normalize(str) {
    let matchResult = [0.0, 0.0, 0.0, 0.0];
    const rgbMatch = str.match(RGB_PATTERN);
    if (rgbMatch) {
      rgbMatch.shift();
      matchResult = rgbMatch.map(v => parseFloat(v) || 0);
      matchResult.push(0.0);
    }
    else {
      const rgbaMatch = str.match(RGBA_PATTERN);
      if (rgbaMatch) {
        rgbaMatch.shift();
        matchResult = rgbaMatch.map(v => parseFloat(v) || 0);
      }
    }
    return matchResult.slice(0, this.maxLen);
  }
}

/**
 * Extract pixel sizes from a CSS string.
 *
 *     >>> normalize('100px;')
 *     >>> [100.0]
 *
 *     TODO: cover cases when the weight is not in pixels, e.g. 'auto', '20em',
 *     or '75%'
 *     How often do we see other weight formats? -> 86% px, 13% other
 *     TODO: normalize values from 0 to 1?
 */
class PixelNormalizer extends VectorNormalizer {
  normalize(str) {
    const match = str.match(PIXEL_PATTERN);
    if (match)
      return [parseFloat(match[1]) || 0];
    return [0.0];
  }
}

/**
 * Extract origins from a CSS string.
 *
 *     >>> normalize('100px 100px;')
 *     >>> [100.0, 100.0]
 *
 *     TODO: cover cases when origins are not in pixels, e.g. 'bottom right',
 *     '-170%', or '500% 200%'
 *     How often do we see other origin formats? -> 86% px, 13% other
 */
class OriginNormalizer extends VectorNormalizer {
  normalize(str) {
    const match = str.match(ORIGIN_PATTERN);
    if (match) {
      match.shift();
      return match.map(v => parseFloat(v) || 0);
    }
    return [0.0, 0.0];
  }
}

class NodeChildrenLenNormalizer {
  normalize(node) {
    if (Array.isArray(node))
      return [node.length];

    return [0];
  }
}

/**
 * Extract URL meta data.
 *
 *     Meta data is length and number of elements from URL domain, path and query.
 *
 *     return: [has_url, is_url, is3rd_party, host_len, path_len, qry_len,
 *              host_elems, path_elems, qry_elems]
 *
 *     >>> normalize('https://doubleclick.net', {'domain': 'www.facebook.com'})
 *     >>> [1, 1, 0, 15, 0, 0, 2, 0, 0]
 *     >>> normalize('https://doubleclick.net?a=1',
 *                   {'domain': 'www.facebook.com'})
 *     >>> [1, 1, 0, 15, 0, 3, 2, 0, 1]
 *     >>> normalize('https://doubleclick.net/pagead/ads',
 *                   {'domain': 'www.facebook.com'})
 *     >>> [1, 1, 0, 15, 11, 0, 2, 2, 0]
 *     >>> normalize('https://doubleclick.net/pagead/ads?a=1',
 *                   {'domain': 'www.facebook.com'})
 *     >>> [1, 1, 0, 15, 11, 3, 2, 2, 1]
 */
const URL_MARKERS = ["http", "data", "blob", "ftp:"];
class MetaURLPartsNormalizer {
  normalize(urlStr, kwargs) {
    if (!urlStr)
      return [0, 0, 0, 0, 0, 0, 0, 0, 0];
    const hasUrl = 1;
    const isUrl = URL_MARKERS.includes(urlStr.slice(0, 4).toLowerCase()) ? 1 : 0;
    if (!isUrl)
      return [hasUrl, isUrl, 0, 0, urlStr.length, 0, 0, 0, 0];
    let url;
    try {
      url = new URL(urlStr);
    }
    catch (e) {
      return [hasUrl, isUrl, 0, 0, urlStr.length, 0, 0, 0, 0];
    }
    const is3rdParty = url.hostname.includes(kwargs["domain"]) ? 0 : 1;
    const netloc = url.username + url.password + url.hostname + (url.port ? url.port : "");
    const path = url.pathname === "/" ? "" : url.pathname;
    const queryValues = Array.from(url.searchParams);

    const hostLen = netloc.length;
    const pathLen = path.length;
    const queryLen = queryValues.flat().join("").length;
    const hostParts = netloc ? url.hostname.split(".").length : 0;
    const pathParts = path.split("/").filter(Boolean).length;
    const queryParts = queryValues.length;

    return [hasUrl, isUrl, is3rdParty, hostLen, pathLen, queryLen, hostParts, pathParts, queryParts];
  }
}

/**
 *     Extract URL domain, path and query parameters (w/o their values).
 *
 *     >>> urln = URLPartsNormalizer(128)
 *     >>> urln.normalize('https://doubleclick.net')
 *     >>> 'doubleclick net'
 *     >>> urln.normalize('https://doubleclick.net/pagead/ads')
 *     >>> 'doubleclick net pagead ads'
 *     >>> urln.normalize('https://doubleclick.net?a=1')
 *     >>>'doubleclick net a'
 *     >>> urln.normalize('https://doubleclick.net/pagead/ads?a=1')
 *     >>> 'doubleclick net pagead ads'
 */
class URLPartsNormalizer {
  constructor(maxLen) {
    this.maxLen = maxLen;
    this.maxPartsLen = this.maxLen / 3;
    this.replacePunctuation = new ReplacePunctuation();
  }

  normalize(urlStr, kwargs) {
    let url;
    const isUrl = URL_MARKERS.includes(urlStr.slice(0, 4).toLowerCase()) ? 1 : 0;
    if (!isUrl)
      return urlStr.substring(0, this.maxLen).trim();
    try {
      url = new URL(urlStr);
    }
    catch (e) {
      return urlStr.substring(0, this.maxLen).trim();
    }

    const hostname = url.hostname.replace(BRACKETS_PATTERN, "");
    const host = [url.username, url.password, hostname.replace(DOT_PATTERN, " "), url.port]
      .filter(Boolean)
      .join(" ")
      .slice(0, this.maxPartsLen).trim();
    const path = (url.pathname.replace(SLASH_PATTERN, " ")).slice(0, 2 * this.maxPartsLen - host.length).trim();
    const queryPairs = url.search.substring(1).split("&")
      .map(a => a.split("=")[0].trim())
      .join(" ").slice(0, 3 * this.maxPartsLen - host.length - path.length).trim();
    return [[host, path].join(" ").trim(), queryPairs].join(" ").trim();
  }
}

class MetaContentNormalizer {
  normalize(str, kwargs) {
    let contentLen = 0;
    let contentParts = 0;

    if (str) {
      contentLen = str.length;
      contentParts = str.split(" ").length;
    }
    return [contentLen, contentParts];
  }
}

/*
 * This file is part of Adblock Plus <https://adblockplus.org/>,
 * Copyright (C) 2006-present eyeo GmbH
 *
 * Adblock Plus is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * Adblock Plus is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adblock Plus.  If not, see <http://www.gnu.org/licenses/>.
 */

/* eslint-env commonjs */

class FeaturePreProcessor {
  constructor(args) {
    this.preprocesors = [];
    for (let preprocesor of args)
      this.preprocesors.push(new preprocesor());
  }

  // noinspection JSUnusedLocalSymbols
  process(data, kwargs) {
    this.preprocesors.forEach(preprocessor =>
      data = preprocessor.process(data));
    return data;
  }
}

class EmptyPreProcessor {
  // noinspection JSUnusedLocalSymbols
  process(data, kwargs) {
    if (!data)
      return new Map();
    return data;
  }
}

class CSSSelectorPreProcessor {
  // noinspection JSUnusedLocalSymbols
  process(data, kwargs) {
    if (!data || !(typeof data === "string" || data instanceof String))
      return new Map();

    return data.split(";").reduce((map, pair) => {
      const [key, val] = pair.split(":");
      if (key && val && !(key in map))
        map[key.trim()] = val.trim();
      return map;
    }, {});
  }
}

/*
 * This file is part of Adblock Plus <https://adblockplus.org/>,
 * Copyright (C) 2006-present eyeo GmbH
 *
 * Adblock Plus is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * Adblock Plus is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adblock Plus.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Reads the JSON configuration and produces feature parsers
 * @param jsonConfig
 * @returns {Array<Array, Array>} featureGroups for nodes and graph
 */
function createFeatureGroups(jsonConfig) {
  let graphFeatureGroups = [];
  let nodeFeatureGroups = [];

  for (let node of jsonConfig)
    node.groupName = Object.keys(node)[2];

  for (let group of jsonConfig) {
    if (group.scope === "graph" && group.include)
      graphFeatureGroups.push(new FeatureGroup(group.groupName, group[group.groupName]));
    else if (group.scope === "node" && group.include)
      nodeFeatureGroups.push(new FeatureGroup(group.groupName, group[group.groupName]));
  }

  return [nodeFeatureGroups, graphFeatureGroups];
}

const Preprocessor2Class = {
  empty: EmptyPreProcessor,
  css_selector: CSSSelectorPreProcessor
};

const Normalizers2Class = {
  lower: Lowercase,
  strip_whitespace: StripWhitespace,
  collapse_whitespace: CollapseWhitespace,
  strip_and_collapse_whitespace: StripAndCollapseWhitespace,
  remove_punctuation: RemovePunctuation,
  replace_punctuation: ReplacePunctuation,
  sequence: SequenceNormalizer,
  one_hot_vector: OneHotVectorNormalizer,
  font_size: FontSizeNormalizer,
  color: ColorNormalizer,
  pixel: PixelNormalizer,
  origin: OriginNormalizer,
  children_len: NodeChildrenLenNormalizer,
  replace_str: ReplaceStr,
  meta_url: MetaURLPartsNormalizer,
  url_parts: URLPartsNormalizer,
  meta_content: MetaContentNormalizer,
  css_class: LastCSSClassNormalizer,
  float: FloatNormalizer
};

const splitWithEmpty = (str, sep) => {
  const a = str.split(sep);
  if (a[0] === "" && a.length === 1)
    return [];
  return a;
};

/**
 * Extracts the ML feature
 */
class Feature {
  constructor(name, conf) {
    this.name = name;
    this.dim = conf.dim;

    // Mutually exclusive feature names such as: 'src', 'href' and 'xlink:href' should be concatenated with '^',
    // e.g.: 'src^href^xlink:href'
    this.altNames = splitWithEmpty(name, "^");

    // JSON path in cases when feature data is nested inside of a larger JSON object, for instance:
    //
    //    {'attributes': {'src': { 'url: '<url>' }}}
    //
    // the 'url' is in 'attributes' feature group, but not directly accessible with attributes.get('url') b/c it is
    // nested in 'src'.
    this.path = [];
    if (conf.path)
      this.path = splitWithEmpty(conf.path, "^");

    // create feature normalizers
    let classes = [];
    if (!Object.hasOwn(conf, "normalizers")) {
      classes.push(Normalizers2Class.empty);
    }
    else {
      for (const ncKey in conf.normalizers) {
        const nc = conf.normalizers[ncKey];
        if (typeof nc === "string" || nc instanceof String) {
          classes.push(Normalizers2Class[nc]);
        }
        else if (typeof nc === "object" && nc !== null) {
          const nName = Object.keys(nc)[0];
          classes.push([Normalizers2Class[nName], Object.values(nc[nName])[0]]);
        }
      }
    }
    this.normalizer = new FeatureNormalizer(classes);
  }

  getName(featureData) {
    if (this.altNames && Object.keys(featureData).length > 0) {
      for (let altName of this.altNames) {
        if (altName in featureData)
          return altName;
      }
    }
    return this.name;
  }

  extractValues(data, kwargs) {
    let featureData = data;
    // Search feature JSON path if it exists
    this.path.forEach(p => {
      if (p in featureData)
        featureData = featureData[p];
    });
    const featureName = this.getName(featureData);
    const featureString = featureName in featureData ? featureData[featureName] : "";
    const featureVec = this.normalizer.normalize(featureString || "", kwargs);
    if (featureVec.length !== this.dim)
      throw new Error("Feature dimensionality mismatch");

    return featureVec;
  }
}

class FeatureGroup {
  constructor(name, conf) {
    this.name = name;
    this.path = splitWithEmpty(conf.path, "/");
    this.prep = this.initPreprocessing(conf);
    this.features = this.initFeatures(conf.features);
  }

  initPreprocessing(conf) {
    let classes = [];
    if (!Object.hasOwn(conf, "prep")) {
      classes.push(Preprocessor2Class.empty);
    }
    else {
      for (let pp of conf.prep)
        classes.push(Preprocessor2Class[pp]);
    }
    return new FeaturePreProcessor(classes);
  }

  initFeatures(featureConfList) {
    let features = [];
    for (const feature of featureConfList) {
      const name = Object.keys(feature)[0];
      const conf = feature[name];
      if (!Object.hasOwn(conf, "names")) {
        features.push(new Feature(name, conf));
        continue;
      }
      for (const fName of conf.names)
        features.push(new Feature(fName, conf));
    }
    return features;
  }

  extractValues(node, kwargs) {
    let data = node;
    // Search feature JSON path if it exists
    this.path.forEach(p => {
      if (p in data)
        data = data[p];
    });

    data = this.prep.process(data, kwargs);

    if (
      typeof data !== "object" ||
      Array.isArray(data) ||
      data === null
    ) {
      throw new Error(
        `path ${this.path}, value ${data}, expected ${typeof {}}, got ${data}`
      );
    }
    let values = [];
    this.features.forEach(feature =>
      values.push(...feature.extractValues(data, kwargs)));
    return values;
  }
}

/*
 * This file is part of Adblock Plus <https://adblockplus.org/>,
 * Copyright (C) 2006-present eyeo GmbH
 *
 * Adblock Plus is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * Adblock Plus is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adblock Plus.  If not, see <http://www.gnu.org/licenses/>.
 */

const URL_DATA_ATTRS = ["src", "href", "xlink:href"];

const zeros = (w, h, v = 0) => Array.from(new Array(h), _ => Array(w).fill(v));
const get = (o, k, d) => k in o ? o[k] : d;

class Graph {
  constructor(kwargs) {
    this.numNodes = 0;
    this.root = kwargs["obj"]["graph"];
    this.domain = kwargs["obj"]["domain"];
    this.graphAttributes = {domain: kwargs["obj"]["domain"]};
    this.featureGroups = kwargs["nodeFeatureGroups"];
    this.graphFeatureGroups = kwargs["graphFeatureGroups"];
    this.cutoff = kwargs["cutoff"];
  }

  getData() {
    // 1st graph traversal collects number of nodes and other stats
    this.setNodeAttributes();
    // 2nd graph traversal creates edges and features
    let edges = zeros(this.numNodes, this.numNodes);
    let features = [];
    let graphFeatures = [];
    // DFS graph traversal
    let toVisit = [[this.root, {}]];
    let cutoffCount = this.cutoff;
    while (toVisit.length && --cutoffCount >= 0) {
      let children;
      let [node, parent] = toVisit.pop();
      this._updateFeatures(node, this.featureGroups, features);
      if (parent && Object.keys(parent).length > 0)
        this._updateEdges(node, parent, edges);

      [parent, children] = [node, node["children"]];
      for (let i = children.length - 1; i >= 0; i--)
        toVisit.push([children[i], parent]);
    }

    this._updateFeatures(this.graphAttributes, this.graphFeatureGroups, graphFeatures);
    return this._formatData(edges, features, graphFeatures);
  }

  setNodeAttributes() {
    // DFS graph traversal
    let toVisit = [[this.root, {}]];
    let cutoffCount = this.cutoff;
    while (toVisit.length && --cutoffCount >= 0) {
      let children;
      let [node, parent] = toVisit.pop();
      this._setNodeAttributes(node, parent);
      [parent, children] = [node, node["children"]];
      for (let i = children.length - 1; i >= 0; i--)
        toVisit.push([children[i], parent]);
    }
  }

  _setNodeAttributes(node, parent) {
    node["node_id"] = this.numNodes++;
    node["dom"] = this.domain;
    node["parent_id"] = get(parent, "node_id", 0);
    node["siblings"] = get(parent, "children", []).length;
    node["level"] = get(parent, "level", -1) + 1;

    let nodeAttributes = get(node, "attributes", {});
    let parentAttributes = get(parent, "attributes", {});
    URL_DATA_ATTRS.forEach(attr => {
      let levKey = `${attr}_level`;
      if (this._hasAttribute(attr, nodeAttributes)) {
        node["attributes"][levKey] = 0;
      }
      else if (this._hasAttribute(attr, parentAttributes)) {
        node["attributes"][attr] = parentAttributes[attr];
        node["attributes"][levKey] = parentAttributes[levKey] + 1;
        if ("requestType" in parent)
          node["requestType"] = parent["requestType"];
      }
    });
  }

  _hasAttribute(attribute, nodeAttributes) {
    return attribute in nodeAttributes && nodeAttributes[attribute];
  }

  _updateFeatures(node, featureGroups, features) {
    let values = [];
    featureGroups.forEach(fg =>
      values.push(...fg.extractValues(node, {domain: this.domain}).map(val => Math.round(val * 100) / 100 || 0)));
    features.push(values);
  }

  _updateEdges(child, parent, edges) {
    edges[parent["node_id"]][child["node_id"]] = 1;
    edges[child["node_id"]][parent["node_id"]] = 1;
  }

  _formatData(edges, features, graphFeatures) {
    if (edges.length > features.length)
      this._cutEdges(edges, features.length);

    if (this.graphFeatureGroups.length > 0)
      return [edges, features, graphFeatures];
    return [edges, features];
  }

  _cutEdges(edges, length) {
    edges = edges.slice(0, length);
    edges.forEach((edge, i, arr) => {
      arr[i] = edge.slice(0, length);
    });
  }
}

/*
 * This file is part of Adblock Plus <https://adblockplus.org/>,
 * Copyright (C) 2006-present eyeo GmbH
 *
 * Adblock Plus is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * Adblock Plus is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Adblock Plus.  If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * An `ML` object implements machine learning based on
 * {@link https://www.tensorflow.org/js TensorFlow.js}.
 *
 * Currently these preprocessing functions are supported:
 *
 * - `cast` - cast tensor into a type provided as an argument
 * - `stack` - {@link https://js.tensorflow.org/api/latest/#stack tf.stack}
 * - `unstack` - {@link https://js.tensorflow.org/api/latest/#unstack tf.unstack}
 * - `localPooling` - run local pooling on each element in an array
 * - `pad` - {@link https://js.tensorflow.org/api/latest/#pad tf.pad}
 *
 * @example <caption>Simple usage</caption>
 * let tf = require("@tensorflow/tfjs");
 * let ml = new ML(tf);
 * // Assuming a pretrained model that predicts (y = 2x - 1)
 *
 * // See here: https://github.com/tensorflow/tfjs-examples/blob/master/getting-started/index.js
 * ml.modelURL = "https://example.com/model.json";
 * console.log(await ml.predict([{data: [[20]]}]));
 * // Outputs approximately 39
 *
 * @example <caption>Usage with preprocessing options</caption>
 * let tf = require("@tensorflow/tfjs");
 * let ml = new ML(tf);
 * // Assuming a graph classification model
 * ml.modelURL = "https://example.com/model.json";
 * let adjacencyMatrices = [[0, 1, 0],
 *                          [1, 0, 1],
 *                          [0, 1, 0]];
 * let numberOfFeatures = 100;
 * let graphSize = 10;
 * let preprocessAdjacency = [
 *   {funcName: "pad", args: graphSize}
 *   {funcName: "unstack"}
 *   {funcName: "localPooling"}
 *   {funcName: "stack"}
 * ];
 * let featureVectors = [[1], [2], [3]];
 * let preprocessFeatures = [
 *   {funcName: "cast", args: "int32"}
 *   {funcName: "pad", args: graphSize}
 *   {funcName: "oneHot", args: numberOfFeatures}
 *   {funcName: "cast", args: "float32"}
 * ];
 * console.log(await ml.predict([
 *   {data: adjacencyMatrices, preprocess: preprocessAdjacency},
 *   {data: featureVectors, preprocess: preprocessFeatures}
 * ]));
 */
class ML {
  constructor(tfjs) {
    this.tfjs = tfjs;
    this._preprocessingFunctions = new Map([
      ["cast", tfjs.cast],
      ["stack", tfjs.stack],
      ["unstack", tfjs.unstack],
      ["localPooling", this._localPoolingMap.bind(this)],
      ["padAdjacency", this._padTensorAdjacency.bind(this)],
      ["padFeatures", this._padTensorFeatures.bind(this)]
    ]);
  }

  /**
   * Pads adjacency matrix tensor in two dimensions with `0`s or according
   * to the padSize given.
   *
   * See {@link https://js.tensorflow.org/api/latest/#pad here} for details.
   * @param {tfjs.Tensor} tensor
   * @param {number} padSize
   * @returns {tfjs.Tensor}
   * @private
   *
   * @example
   * // returns [[[0, 1, 0, 0, 0],
   *              [1, 0, 1, 0, 0],
   *              [0, 1, 0, 0, 0],
   *              [0, 0, 0, 0, 0],
   *              [0, 0, 0, 0, 0]]]
   * _padTensorAdjacency([[[0, 1, 0],
   *                       [1, 0, 1],
   *                       [0, 1, 0]]]
   *                      5
   *                     );
   */
  _padTensorAdjacency(tensor, padSize) {
    return tensor.pad([
      [0, 0],
      [0, padSize - tensor.shape[1]],
      [0, padSize - tensor.shape[2]]
    ]);
  }

  /**
   * Runs `{@link ML#_localPooling}` on an array of tensors.
   * @param {Array.<tfjs.Tensor>} adjacencyMatrices
   * @returns {Array.<tfjs.Tensor>}
   * @private
   */
  _localPoolingMap(adjacencyMatrices) {
    return adjacencyMatrices.map(x => this._localPooling(x));
  }

  /**
   * Computes a pooling operation for a matrix `A: (D^(-0.5))*(A)*(D^(-0.5))`
   * where `D` is the diagonal node degree matrix.
   *
   * Based on Kipf & Welling (2017).
   *
   * See {@link https://github.com/danielegrattarola/spektral/blob/a3883117b16b958e2e24723afc6885fbc7df397a/spektral/utils/convolution.py#L88 Python implementation}
   * @param {tfjs.Tensor} adjacencyMatrix
   * @param {tfjs} TensorFlow.js instance
   * @returns {tfjs.Tensor} The normalized adjacency matrix.
   * @private
   */
  _localPooling(adjacencyMatrix) {
    let aTilde = adjacencyMatrix.add(this.tfjs.eye(adjacencyMatrix.shape[0]));
    let degreePow = this.tfjs.pow(this.tfjs.sum(aTilde, 1), -0.5);
    degreePow = degreePow.where(
      this.tfjs.isFinite(degreePow),
      this.tfjs.zeros(degreePow.shape)
    );
    let degreeMx = degreePow.mul(this.tfjs.eye(aTilde.shape[0]));
    let normalized = degreeMx.dot(aTilde).dot(degreeMx);
    return normalized;
  }


  /**
   * Pads feature matrix tensor in one dimension with `0`s according
   * to the padSize given.
   *
   * See {@link https://js.tensorflow.org/api/latest/#pad here} for details.
   * @param {tfjs.Tensor} tensor
   * @param {number} padSize
   * @returns {tfjs.Tensor}
   * @private
   *
   * @example
   * // returns [[[0, 0, 0],
   *              [1, 0, 0],
   *              [2, 1, 0],
   *              [0, 0, 0],
   *              [0, 0, 0]]]
   * _padTensorAdjacency([[[0, 0, 0],
   *                       [1, 0, 0],
   *                       [2, 1, 0]]]
   *                      5
   *                     );
   */
  _padTensorFeatures(tensor, padSize) {
    return tensor.pad([
      [0, 0],
      [0, padSize - tensor.shape[1]],
      [0, 0]
    ]);
  }


  createTensors(data, cutoff) {
    const [adjacencyMatrix, features] = data;

    const process = [
      {
        data: [adjacencyMatrix], preprocess: [
          {funcName: "padAdjacency", args: cutoff}
        ]
      },
      {
        data: [features], preprocess: [
          {funcName: "padFeatures", args: cutoff}
        ]
      }
    ];

    let tensors = this.tfjs.tidy(() => process.map(input => {
      let preprocessed = this.tfjs.tensor(input.data);
      if (input.preprocess) {
        for (let params of input.preprocess) {
          preprocessed = this._preprocessingFunctions.get(params.funcName)(
            preprocessed, params.args
          );
        }
      }
      return preprocessed;
    }));

    return tensors;
  }
}

/* globals atob getComputedStyle */

const DEFAULT_GRAPH_CUTOFF = 500;

/**
 * Perform data preprocessing
 * @param {Object} bundle - Model bundle as a JSON object
 * @param {Object} graph - JSON object representing target as a graph
 * @returns {Promise.<Object>} Returns Object containing preprocessed data
 */
async function preprocessGraph(bundle, graph, domain = ".") {
  return new Promise((resolve, reject) => {
    if (!bundle || !graph)
      return reject();

    let config = bundle.config;
    let cutoff = config.cutoff || bundle.topology.graphml.nodes || DEFAULT_GRAPH_CUTOFF;

    let [nodeFeatureGroups, graphFeatureGroups] = createFeatureGroups(config);
    let kwargs = {nodeFeatureGroups, graphFeatureGroups, obj: {domain, graph}, cutoff};

    const g = new Graph(kwargs);
    const data = g.getData();

    resolve(data);
  });
}

/**
 * Runs inference
 * @param {Object} tfjs - TensorFlow.js instance
 * @param {Object} model - TensorFlow.js model
 * @param {Object} bundle - Model bundle as a JSON object
 * @param {Object} input - Object containing adjacencyMatrix and feature matrix
 * @returns {Promise.<Array>} Returns array of predictions
 */
async function predict(tfjs, model, bundle, input) {
  return new Promise((resolve, reject) => {
    if (!bundle || !tfjs || !model || !input)
      return reject();

    let config = bundle.config;
    let cutoff = config.cutoff || bundle.topology.graphml.nodes || DEFAULT_GRAPH_CUTOFF;
    let tensorUtils = new ML(tfjs);
    let tensors = tensorUtils.createTensors(input, cutoff);

    // Run preprocessed graph against TFJS
    let result = model.execute(tensors);
    result.data().then(data => {
      resolve(data);
    }).catch(err => {
      reject(err);
    }).finally(() => {
      result.dispose();
      for (let inputTensor of tensors)
        inputTensor.dispose();
    });
  });
}


/**
 * Normalizes predictions
 * @param {Object} predictions - An array of predictions
 * @returns {Promise.<Array>} Returns array of predictions
 */
async function digestPrediction(predictions) {
  return new Promise((resolve, reject) => {
    // Check if TFJS' predictions are true or false
    predictions = Array.from(predictions);
    if (!predictions || !Array.isArray(predictions) || !predictions.some(v => v > 0) || predictions.length < 2)
      return reject();
    let norm = predictions.reduce((acc, val) => acc + val, 0);
    predictions = predictions.map(val => val / norm);
    resolve(predictions[1] > predictions[0]);
  });
}

/**
 * Loads model from a model bundle.
 * @param {Object} tfjs - A TFJS instance
 * @param {Object} bundle - Model bundle as a JSON object
 * @returns {Promise.<Array.<number>>} A promise that fulfills with an
 *   instance of a model.
 */
async function loadBundledModel(tfjs, bundle) {
  if (!bundle)
    return Promise.reject("model not found");

  return tfjs.loadGraphModel({
    load() {
      let data = {
        modelTopology: bundle.topology.modelTopology || {},
        signature: bundle.topology.signature || {},
        weightsManifest: bundle.topology.weightsManifest || [],
        weightSpecs: bundle.topology.weightsManifest.map(e => e.weights)[0] || [],
        weightData: concatWeights(
          bundle.weights.map(d => Uint8Array.from(atob(d.shard), bin => bin.charCodeAt(0)))
        ) || []
      };
      return data;
    }
  });
}

/**
 * Concats weights.
 * @param {Uint8Array} buffers - A buffer of weights
 * @returns {Uint8Array} A buffer of concatenated weights
 *   instance of a model.
 */
function concatWeights(buffers) {
  let totalByteLength = 0;

  buffers.forEach(buffer => {
    totalByteLength += buffer.byteLength;
  });

  let concatBuffer = new Uint8Array(totalByteLength);
  let offset = 0;
  buffers.forEach(buffer => {
    concatBuffer.set(new Uint8Array(buffer), offset);
    offset += buffer.byteLength;
  });
  return concatBuffer.buffer;
}

const MESSAGE_PREFIX = "ML:";
const MESSAGE_PREPARE_SUFFIX = "prepare";
const MESSAGE_INFERENCE_SUFFIX = "inference";
const errors = {
  UNKNOWN_REQUEST: 1,
  MISSING_REQUEST_DATA: 2,
  UNKNOWN_MODEL: 3,
  MISSING_INFERENCE_DATA: 4,
  INFERENCE_FAILED: 5,
  MODEL_INSTANTIATION_FAILED: 6,
  MISSING_ENVIRONMENTAL_SUPPORT: 7
};

// Map of all models held in memory
let models = new Map();

// Enable debug output.
// Can be turned on by adding "mldebug:" to the beginning of filters:
// domain.com$%$hide-if-classifies mldebug:div.someclass
let debug = false;

// Holds a reusable reference to indexedDB
let databaseRef;

// Indicator whether maintenance has already been performed during
// the service worker's/backend script's current lifetime
let performedMaintenance = false;

// General configuration
const DATABASE_NAME = "abpml";
const TABLE_NAME = "data";
const BACKEND_URL = "https://easylist-downloads.adblockplus.org/models/";
// Timeout in MS before model download attempts are cancelled
const BACKEND_TIMEOUT = 10000;
// Amount of retries per invocation/filter hit the application tries
// to re-download upon connection errors/timeouts.
const BACKEND_RETRIES = 1;
// Time in MS after which unused models are removed
// 2.592.000.000 = 30 days
const MODEL_TTL = 2592000000;
// Timeout in MS between model deletion.
const MODEL_DELETION_TIMEOUT = 1000;
// Interval for maintenance routine like model cleanup
// 86.400.000 = 1 day
const MAINTENANCE_INTERVAL = 86400000;
// Database key which stores the value for when maintenance
// was initiated last
const MAINTENANCE_DATABASE_KEY = "conf_maintenance_time";
const WEBGL_SUPPORT = checkWebGlSupport();

// Enable TFJS production mode
enableProdMode();
env().set("WEBGL_USE_SHAPES_UNIFORMS", true);

/**
 * Message listener for incoming requests. Needs to be registered with
 * `chrome.runtime.onMessage.addListener` for incoming requests to be digested.
 * @param {Object} request - onMessage request object
 * @param {Object} sender - onMessage sender object
 * @param {Function} sendResponse - onMessage sendResponse callback
 * @returns {Boolean} Returns a boolean indicating asynchronous message digestion
 */
function messageListener(request, sender, sendResponse) {
  // Listen to any request and digest relevant messages
  if (request && typeof request.type === "string" && request.type.startsWith(MESSAGE_PREFIX)) {
    digestMessage(request)
      .then(sendResponse)
      .catch(sendResponse);
    return true;
  }
  return false;
}

/**
 * Digests incoming requests and returns a promise resolving to a corresponding response.
 * Expected request for model preparation:
 * `{type: 0, model: <model_name>}`
 * Expected request for inference:
 * `{type: 1, model: <model_name>, graph: <model_graph>}`
 * Example response for a `prepare` request:
 * `{type: 0, config: <model_config>, cutoff: <model_cutoff>}`
 * Example response for a `inference` request:
 * `{type: 1, prediction: <inference_results>}`
 * Example response for erroneous request:
 * `{type: <request_type_number>, error: <error_number>}`
 * @param {Object} request - onMessage request object
 * @returns {Promise.<Object>} Returns a promise resolving/rejecting with a dictionary
 *   containing the expected data or an error message
 */
function digestMessage(request) {
  if (!request)
    return Promise.reject({type: request.type, error: errors.MISSING_REQUEST_DATA});
  // Remove illegal characters from model name
  let modelName = (request.model || "").replace([/[^a-zA-Z0-9._-]/g, ""]);
  if (!request.type || !modelName || (request.type === MESSAGE_PREFIX + MESSAGE_INFERENCE_SUFFIX && !request.graph))
    return Promise.reject({type: request.type, error: errors.MISSING_REQUEST_DATA});

  // Enable debug mode if corresponding filter contains mldebug flag
  if (request.debug)
    debug = true;

  debugOut(`Digesting request ${JSON.stringify(request || {}).slice(0, 100)}...`);

  if (typeof indexedDB === "undefined") {
    debugOut("Request aborted due to missing database support", true);
    return Promise.reject({type: request.type, error: errors.MISSING_ENVIRONMENTAL_SUPPORT});
  }

  if (!WEBGL_SUPPORT) {
    debugOut("Request aborted due to missing WebGL support", true);
    return Promise.reject({type: request.type, error: errors.MISSING_ENVIRONMENTAL_SUPPORT});
  }

  // Run maintenance task like database cleanup
  if (!performedMaintenance) {
    maintenance();
    performedMaintenance = true;
  }

  if (request.type === MESSAGE_PREFIX + MESSAGE_PREPARE_SUFFIX) {
    // Preload model and send configuration to snippet
    return digestPrepare(modelName)
      .then(bundle => ({type: request.type, config: bundle.config, cutoff: bundle.topology.graphml.nodes}))
      .catch(() => Promise.reject({type: request.type, error: errors.MODEL_INSTANTIATION_FAILED}));
  }
  else if (request.type === MESSAGE_PREFIX + MESSAGE_INFERENCE_SUFFIX) {
    // Run inference
    return digestInference(modelName, request.graph)
      .then(prediction => ({type: request.type, prediction}))
      .catch(() => Promise.reject({type: request.type, error: errors.INFERENCE_FAILED}));
  }

  // Request type unknown
  return Promise.reject({type: request.type, error: errors.UNKNOWN_REQUEST});
}

/**
 * Loads a model from remote/local and resolves to the corresponding model bundle
 * @param {String} modelName - Name of the model
 * @returns {Promise.<Object>} Returns a promise resolving/rejecting with a model bundle
 *   or an error message
 */
function digestPrepare(modelName) {
  return getModelInstance(modelName)
    .then(model => model.bundle)
    .catch(() => {
      // Model failed to load
      // Remove model so it can be re-fetched
      deleteModelLocal(modelName);
      return Promise.reject("Model corrupted");
    });
}

/**
 * Runs inference for the provided graph using the model corresponding to the provided
 * model name.
 * @param {String} modelName - Name of the model
 * @param {Object} graph - Dictionary representing a graph
 * @returns {Promise.<Boolean>} Returns a promise resolving/rejecting with inference results
 *   or an error message
 */
function digestInference(modelName, graph) {
  debugOut(`Running inference: ${modelName}, ${JSON.stringify(graph || {}).slice(0, 100)}...`);
  return getModelInstance(modelName)
    .then(model => Promise.all([model.instance, model.bundle]))
    .then(([instance, bundle]) => preprocessGraph(bundle, graph, ".")
      .then(predict.bind(this, tfjs, instance, bundle))
      .then(digestPrediction))
    .catch(() => {
      // Model failed to run inference
      // Remove model so it can be re-fetched
      deleteModelLocal(modelName);
      return Promise.reject("Model corrupted");
    });
}

/**
 * Loads a model instance from memory, from the database or from remote depending on the
 * availability of the corresponding model. If the model has been loaded from the database
 * or from remote, it will be stored in memory for faster availability.
 * @param {String} modelName - Name of the model
 * @returns {Promise.<Object>} Returns a promise resolving/rejecting with a model instance
 *   or an error message
 */
function getModelInstance(modelName) {
  if (!modelName)
    return Promise.reject("No model name provided");

  if (!models.has(modelName)) {
    // If model isn't loaded in memory, initiate loading both
    // `bundle` and `instance` and hold promises resolving to
    // the respective expected value
    let bundle = getModel(modelName);
    let instance = bundle.then(loadModel);
    // Silently catch errors in case Promises are never digested.
    bundle.catch(() => { /* no-op */ });
    instance.catch(() => { /* no-op */ });
    models.set(modelName, {bundle, instance});
  }
  let model = models.get(modelName);
  if (!model.bundle || !model.instance) {
    models.delete(modelName);
    return Promise.reject("Model corrupted");
  }
  return Promise.resolve(model);
}

/**
 * Instantiates a model using a provided model bundle.
 * @param {String} modelBundle - A dictionary representing a model bundle
 * @returns {Promise.<Object>} Returns a promise resolving/rejecting with a model instance
 *   or an error message
 */
function loadModel(modelBundle) {
  return loadBundledModel(tfjs, modelBundle);
}

/**
 * Fetches a model bundle from the database or from remote depending on the availability.
 * @param {String} modelName - Name of the model
 * @returns {Promise.<Object>} Returns a promise resolving/rejecting with a model bundle
 *   or an error message
 */
function getModel(modelName) {
  return fetchModelLocal(modelName)
    .catch(fetchModelRemote.bind(this, modelName, BACKEND_RETRIES));
}

/**
 * Fetches a model bundle from the database.
 * @param {String} modelName - Name of the model
 * @returns {Promise.<Object>} Returns a promise resolving/rejecting with a model bundle
 *   or an error message
 */
function fetchModelLocal(modelName) {
  // If IndexedDB isn't supported, skip to fetching it remotely
  if (typeof indexedDB === "undefined")
    return Promise.reject("No IndexedDB support");
  return databaseTransaction({action: "get", key: modelName})
    .then(data => {
      // Check sanity of model bundle
      if (!data.config || !data.topology || !data.weights) {
        databaseTransaction({action: "del", key: modelName})
          .catch(e => debugOut(`Warning: can't remove corrupted model (${e})`, true));
        return Promise.reject("model corrupted");
      }
      // Update usage timestamp
      storeModelLocal(modelName, data)
        .catch(e => debugOut(`Warning: can't update existing model (${e})`, true));

      debugOut(`Loaded model from database: ${modelName}`);
      return data;
    });
}

/**
 * Removes a model bundle from the database.
 * @param {String} modelName - Name of the model
 * @returns {Promise.<Object>} Returns a promise resolving/rejecting with a database
 *   transaction or an error message
 */
function deleteModelLocal(modelName) {
  if (typeof indexedDB === "undefined")
    return Promise.reject("No IndexedDB support");
  if (models.has(modelName)) {
    debugOut(`Removing model from memory: ${modelName}`);
    models.delete(modelName);
  }
  debugOut(`Removing model from database: ${modelName}`);
  return databaseTransaction({action: "del", key: modelName});
}

/**
 * Stores a model bundle in the database.
 * @param {String} modelName - Name of the model
 * @param {String} modelBundle - Model bundle
 * @returns {Promise.<Object>} Returns a promise resolving/rejecting with a database
 *   transaction or an error message
 */
function storeModelLocal(modelName, modelBundle) {
  // If IndexedDB isn't supported, only keep it in memory
  if (typeof indexedDB === "undefined")
    return Promise.reject("No IndexedDB support");
  return databaseTransaction({
    action: "put",
    key: modelName,
    data: {...modelBundle, dt: Date.now()}
  });
}

/**
 * Fetches a model bundle from remote.
 * @param {String} modelName - Name of the model
 * @param {Integer} retries - The allowed amount of retries in case the download fails
 * @returns {Promise.<Object>} Returns a promise resolving/rejecting with a model bundle
 *   or an error message
 */
function fetchModelRemote(modelName, retries) {
  debugOut(`Attempting to fetch ${modelName} from remote`);
  let ac = new AbortController();
  let timer = setTimeout(ac.abort, BACKEND_TIMEOUT);
  if (isNaN(retries))
    retries = BACKEND_RETRIES;
  return fetch(`${BACKEND_URL}${modelName}.json`, {signal: ac.signal})
    .then(ret => ret.json())
    .then(data => {
      // Check sanity of model bundle
      if (!data.config || !data.topology || !data.weights)
        return Promise.reject("model corrupted");
      debugOut(`Loaded model from remote: ${modelName}`);
      debugOut(`Storing model in database: ${modelName}`);
      return storeModelLocal(modelName, data).catch(e => Promise.resolve(data));
    })
    .catch(e => {
      // Retry as per configuration per operation/filter hit
      if (retries > 0)
        return fetchModelRemote(modelName, --retries);
      debugOut(`Failed to fetch ${modelName} from remote: offline`, true);
      return Promise.reject(e);
    })
    .finally(() => clearTimeout(timer));
}

/**
 * Runs maintenance tasks once per MAINTENANCE_INTERVAL
 */
function maintenance() {
  // Get timestamp of last maintenance run
  databaseTransaction({action: "get", key: MAINTENANCE_DATABASE_KEY})
    .then(time => {
      // Perform database cleanup if MAINTENANCE_INTERVAL has been reached
      if (isNaN(time) || Date.now() - time > MAINTENANCE_INTERVAL) {
        cleanUpDatabase();
        // Update maintenance timestamp
        return databaseTransaction({action: "put", key: MAINTENANCE_DATABASE_KEY, data: Date.now()});
      }
    })
    .catch(e => debugOut(`Warning: maintenance failed (${e})`));
}

/**
 * Removes all models from the database which are older than MODEL_TTL
 */
function cleanUpDatabase() {
  debugOut("Cleaning up database");
  databaseTransaction({action: "keys"})
    .then(keys => {
      keys.forEach((key, index) => {
        if (!key || key.startsWith("conf"))
          return;
        setTimeout(() => {
          databaseTransaction({action: "get", key})
            .then(data => {
              // Remove model if it hasn't been used for longer than MODEL_TTL
              if (data && !isNaN(data.dt) && Date.now() - data.dt > MODEL_TTL)
                return this.deleteModelLocal(key);
            })
            .catch(e => debugOut(`Warning: database cleanup for ${key} failed (${e})`));
        }, MODEL_DELETION_TIMEOUT * index);
      });
    })
    .catch(e => debugOut(`Warning: database cleanup failed (${e})`));
}

/**
 * Runs a database transaction according to `options`.
 * Example to get a database entry:
 * `{action: "get", key: "<key_name>"}`
 * Example to write/update a database entry:
 * `{action: "put", key: "<key_name>" data: <value_to_store>}`
 * Example to remove database entry:
 * `{action: "del", key: "<key_name>"}`
 * Example to get all database keys:
 * `{action: "keys"}`
 * @param {Object} options - A dictionary containing transaction instructions
 * @param {Integer} retries - The allowed amount of retries in case the download fails
 * @returns {Promise.<Object>} Returns a promise resolving/rejecting with an object of
 *   the expected values or an error message
 */
function databaseTransaction(options) {
  if (!options.action || (options.action !== "keys" && !options.key) || (options.action === "put" && !options.data))
    return Promise.reject("Missing database transaction options/data.");

  if (typeof indexedDB === "undefined")
    return Promise.reject("No IndexedDB support");

  return openDatabase()
    .then(db => {
      let tx = db.transaction(TABLE_NAME, "readwrite");
      let store = tx.objectStore(TABLE_NAME);
      let req;
      if (options.action === "get")
        req = store.get(options.key);
      else if (options.action === "put")
        req = store.put(options.data, options.key);
      else if (options.action === "del")
        req = store.delete(options.key);
      else if (options.action === "keys")
        req = store.getAllKeys();
      else
        return Promise.reject("Database transaction request not recognized");
      return new Promise((resolve, reject) => {
        tx.onerror = reject;
        req.onerror = reject;
        req.onsuccess = () => {
          if (options.action === "put")
            resolve(options.data);
          else if (options.action === "get")
            resolve(req.result);
          else if (options.action === "del")
            resolve();
          else if (options.action === "keys")
            resolve(req.result);
          else
            reject("Database transaction request not recognized");
        };
      });
    });
}

/**
 * Prepares IndexedDB for transactions.
 * @returns {Promise.<Object>} Returns a promise resolving/rejecting with a reference to
 *   the database or an error message
 */
function openDatabase() {
  if (typeof indexedDB === "undefined")
    return Promise.reject("No IndexedDB support");

  if (!databaseRef) {
    databaseRef = new Promise((resolve, reject) => {
      let req = indexedDB.open(DATABASE_NAME, 1);
      req.onsuccess = () => resolve(req.result);
      req.onerror = reject;
      req.onupgradeneeded = () => req.result.createObjectStore(TABLE_NAME);
    });
  }
  return databaseRef;
}

/**
 * Checks for WebGL 2 offscreen support.
 * @returns {Boolean} Returns a boolean indicating WebGL 2 support
 */
function checkWebGlSupport() {
  if (typeof OffscreenCanvas === "undefined")
    return false;
  let testCanvas = new OffscreenCanvas(0, 0);
  try {
    if (testCanvas.getContext("webgl2"))
      return true;
  }
  catch (e) { /* no-op */ }
  return false;
}

/**
 * Prints debug output to the console if debug mode is active.
 * @param {String} message - A message to be printed
 */
function debugOut(message, error = false) {
  if (debug) {
    // eslint-disable-next-line no-console
    console.log(
      "%cMLDBG \u2665 %c| %s%c |",
      "color:cyan",
      error ? "color:red" : "color:inherit",
      message,
      "color:inherit"
    );
  }
}

chrome.runtime.onMessageExternal.addListener(messageListener);

// Copyright 2022 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "ui/views/widget/desktop_aura/desktop_native_cursor_manager_win.h"

#include <windows.h>

#include <winuser.h>

#include <utility>

#include "base/feature_list.h"
#include "base/functional/bind.h"
#include "base/functional/callback.h"
#include "base/numerics/safe_conversions.h"
#include "base/win/windows_types.h"
#include "ui/base/ui_base_features.h"
#include "ui/wm/core/native_cursor_manager_delegate.h"

namespace views {

namespace {

constexpr int kDefaultCursorSize = 32;

BASE_FEATURE(kUseCursorEventHook,
             "UseCursorEventHook",
             base::FEATURE_ENABLED_BY_DEFAULT);

HWINEVENTHOOK g_cursor_event_hook = nullptr;
raw_ptr<DesktopNativeCursorManagerWin> g_instance = nullptr;
raw_ptr<wm::NativeCursorManagerDelegate> g_delegate = nullptr;

bool IsSystemCursorVisible() {
  CURSORINFO cursor_info;
  cursor_info.cbSize = sizeof(cursor_info);

  if (!GetCursorInfo(&cursor_info)) {
    PLOG(ERROR) << "Unable to get cursor info. Error = " << GetLastError();
    return false;
  }

  return cursor_info.flags == CURSOR_SHOWING;
}

void CALLBACK CursorEventProc(HWINEVENTHOOK hook,
                              DWORD event,
                              HWND hwnd,
                              LONG id_object,
                              LONG id_child,
                              DWORD id_event_thread,
                              DWORD time) {
  if (hwnd == nullptr && id_object == OBJID_CURSOR &&
      id_child == CHILDID_SELF) {
    g_instance->OnSystemCursorVisibilityChanged(IsSystemCursorVisible());
  }
}

}  // namespace

DesktopNativeCursorManagerWin::DesktopNativeCursorManagerWin() = default;

DesktopNativeCursorManagerWin::~DesktopNativeCursorManagerWin() {
  if (g_cursor_event_hook) {
    UnhookWinEvent(g_cursor_event_hook);
    g_cursor_event_hook = nullptr;
  }
  g_instance = nullptr;
  g_delegate = nullptr;
}

void DesktopNativeCursorManagerWin::SetSystemCursorSize() {
  DWORD cursor_base_size = 0;
  if (hkcu_cursor_regkey_.Valid() &&
      hkcu_cursor_regkey_.ReadValueDW(L"CursorBaseSize", &cursor_base_size) ==
          ERROR_SUCCESS) {
    int size = base::checked_cast<int>(cursor_base_size);
    system_cursor_size_ = gfx::Size(size, size);
  }

  // Report cursor size.
  DCHECK(g_delegate);
  g_delegate->CommitSystemCursorSize(system_cursor_size_);
}

void DesktopNativeCursorManagerWin::RegisterCursorRegkeyObserver() {
  if (!hkcu_cursor_regkey_.Valid()) {
    return;
  }

  hkcu_cursor_regkey_.StartWatching(base::BindOnce(
      [](DesktopNativeCursorManagerWin* manager) {
        manager->SetSystemCursorSize();
        // RegKey::StartWatching only provides one notification.
        // Reregistration is required to get future notifications.
        manager->RegisterCursorRegkeyObserver();
      },
      // It's safe to use |base::Unretained(this)| here, because |this| owns
      // the |hkcu_cursor_regkey_|, and the callback will be cancelled if
      // |hkcu_cursor_regkey_| is destroyed.
      base::Unretained(this)));
}

void DesktopNativeCursorManagerWin::InitSystemCursorObservers(
    wm::NativeCursorManagerDelegate* delegate) {
  DCHECK(!g_instance);
  g_instance = this;

  DCHECK(!g_delegate);
  g_delegate = delegate;

  // Register cursor size observer if enabled.
  if (features::IsSystemCursorSizeSupported()) {
    // Validity of this key is checked at time-of-use.
    (void)hkcu_cursor_regkey_.Open(HKEY_CURRENT_USER, L"Control Panel\\Cursors",
                                   KEY_READ | KEY_NOTIFY);
    system_cursor_size_ = gfx::Size(kDefaultCursorSize, kDefaultCursorSize);
    RegisterCursorRegkeyObserver();
    SetSystemCursorSize();
  }

  // Register cursor visibility observer if enabled.
  if (base::FeatureList::IsEnabled(kUseCursorEventHook)) {
    // Register for cursor show/hide events. WINEVENT_SKIPOWNPROCESS is set to
    // skip the events generated by Chromium itself.
    DCHECK(!g_cursor_event_hook);
    g_cursor_event_hook = SetWinEventHook(
        EVENT_OBJECT_SHOW, EVENT_OBJECT_HIDE, nullptr, CursorEventProc, 0, 0,
        WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNPROCESS);

    // Report the initial cursor visibility.
    OnSystemCursorVisibilityChanged(IsSystemCursorVisible());
  }
}

void DesktopNativeCursorManagerWin::OnSystemCursorVisibilityChanged(
    bool visible) {
  if (system_cursor_visible_ == visible) {
    return;
  }

  system_cursor_visible_ = visible;
  DCHECK(g_delegate);
  g_delegate->CommitSystemCursorVisibility(visible);
}

}  // namespace views
